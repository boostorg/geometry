<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.Geometry (aka GGL, Generic Geometry Library)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.Geometry" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="design">Design rationale </a></h1><h2><a class="anchor" name="par1">
Introduction</a></h2>
Suppose you need C++ software to calculate the distance between two points. You might define a struct:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>mypoint
{
    <span class="keywordtype">double</span> x, y;
};
</pre></div><p>
And a function, containing the algorithm: <div class="fragment"><pre class="fragment"><span class="keywordtype">double</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(mypoint <span class="keyword">const</span>&amp; a, mypoint <span class="keyword">const</span>&amp; b)
{
    <span class="keywordtype">double</span> dx = a.x - b.x;
    <span class="keywordtype">double</span> dy = a.y - b.y;
    <span class="keywordflow">return</span> sqrt(dx * dx + dy * dy);
}
</pre></div><p>
Quite simple, and it is usable, but not generic. For a library it has to be designed way further. The design above can only be used for 2D points, for the struct <b>mypoint</b> (and no other struct), in a Cartesian coordinate system. A generic library should be able to calculate the distance:<ul>
<li>for any point class or struct, not on just this <b>mypoint</b> type</li><li>in more than two dimensions</li><li>for other coordinate systems, e.g. over the earth or on a sphere</li><li>between a point and a line or between other geometry combinations</li><li>in other (e.g. higher) precision than ‘double’</li><li>avoiding the square root: often we don’t want to calculate the square because it is a relatively expensive function, and for comparing distances it is not necessary. In this page we will make the design step by step more generic.</li></ul>
<h2><a class="anchor" name="par2">
Using templates</a></h2>
The distance function can be changed into a template function. This is trivial and allows calculating the distance between other point types than just <b>mypoint</b>. We add two template parameters, allowing input of two different point types.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2&gt;
<span class="keywordtype">double</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(P1 <span class="keyword">const</span>&amp; a, P2 <span class="keyword">const</span>&amp; b)
{
    <span class="keywordtype">double</span> dx = a.x - b.x;
    <span class="keywordtype">double</span> dy = a.y - b.y;
    <span class="keywordflow">return</span> sqrt(dx * dx + dy * dy);
}
</pre></div><p>
This template version is slightly better, but not much. Consider a C++ class where member variables are protected… Such a class does not allow to access .x and .y directly. So this paragraph is short and we just go on.<h2><a class="anchor" name="par3">
Using traits</a></h2>
We need to take a generic approach, to allow any point type as input to the distance function. Instead of accessing .x and .y, we will add a few levels of indirection, using a traits system. The distance function then becomes: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2&gt;
<span class="keywordtype">double</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(P1 <span class="keyword">const</span>&amp; a, P2 <span class="keyword">const</span>&amp; b)
{
    <span class="keywordtype">double</span> dx = get&lt;0&gt;(a) - get&lt;0&gt;(b);
    <span class="keywordtype">double</span> dy = get&lt;1&gt;(a) - get&lt;1&gt;(b);
    <span class="keywordflow">return</span> sqrt(dx * dx + dy * dy);
}
</pre></div><p>
This adapted distance function uses a generic get-function, with dimension as a template parameter, to access the coordinates of a point. This get-function forwards to the traits system, defined as following: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>traits
{
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P, <span class="keywordtype">int</span> D&gt;
    <span class="keyword">struct </span>access {};
}
</pre></div><p>
which is then specialized for our <b>mypoint</b> type, implementing a static method called ‘get’: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>traits
{
    <span class="keyword">template</span> &lt;&gt;
    <span class="keyword">struct </span>access&lt;mypoint, 0&gt;
    {
        <span class="keyword">static</span> <span class="keywordtype">double</span> <span class="keyword">get</span>(mypoint <span class="keyword">const</span>&amp; p)
        {
            <span class="keywordflow">return</span> p.x;
        }
    };
    <span class="comment">// same for 1: p.y</span>
    ...
}
</pre></div><p>
Calling traits::access&lt;mypoint, 0&gt;::get(a) now returns us our x-coordinate. Nice? It is quite verbose for a function like this, used so often in the library. We can shorten the syntax by adding an extra <b>free</b> <b>function:</b> <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> D, <span class="keyword">typename</span> P&gt;
<span class="keyword">inline</span> <span class="keywordtype">double</span> <span class="keyword">get</span>(P <span class="keyword">const</span>&amp; p)
{
    <span class="keywordflow">return</span> <a class="code" href="group__access.html#g369b4a9519f357a05b68739fcf4ab374" title="get coordinate value of a Point ( / Sphere)">traits::access&lt;P, D&gt;::get</a>(p);
}
</pre></div><p>
This enables us to call get&lt;0&gt;(a), for any point having the traits::access specialization, as shown in the distance algorithm at the start of this paragraph. So we wanted to enable classes with methods like .x(), and they are supported as long as there is a specialization of the access struct with a static get function returning .x() for dimension 0, and similar for 1 and .y().<p>
Alternatively we could implement, in the traits class, the dimension as a template parameter in a member template function:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct </span>access&lt;mypoint&gt;
{
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> D&gt;
    <span class="keyword">static</span> <span class="keywordtype">double</span> <span class="keyword">get</span>(mypoint <span class="keyword">const</span>&amp; p)
    <span class="comment">// either return x/y using an if-clause</span>
    <span class="comment">// or call a detail-struct specialized</span>
    <span class="comment">//   per dimension</span>
};
</pre></div><p>
This alternative gives in the end the same functionality. It however is either using an if-clause (which is not compile-time, so not preferred; it is slightly slower), or adding another level of indirection (a sub-structure specialized on dimension). Therefore the form with the dimension as a template parameter of the struct is preferred.<h2><a class="anchor" name="par4">
Dimension agnosticism</a></h2>
Now we can calculate the distance between points in 2D, points of any structure or class. However, we wanted to have 3D as well. So we have to make it dimension agnostic. This complicates our distance function. We can use a for-loop to walk through dimensions, but for loops have another performance than the straightforward coordinate addition which was there originally. However, we can make more usage of templates and implement the distance algorithm as following; it is more complex but attractive for template fans: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2, <span class="keywordtype">int</span> D&gt;
<span class="keyword">struct </span>pythagoras
{
    <span class="keyword">static</span> <span class="keywordtype">double</span> apply(P1 <span class="keyword">const</span>&amp; a, P2 <span class="keyword">const</span>&amp; b)
    {
        <span class="keywordtype">double</span> d = <span class="keyword">get</span>&lt;D-1&gt;(a) - get&lt;D-1&gt;(b);
        <span class="keywordflow">return</span> d * d + pythagoras&lt;P1, P2, D-1&gt;::apply(a, b);
   }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2 &gt;
<span class="keyword">struct </span>pythagoras&lt;P1, P2, 0&gt;
{
    <span class="keyword">static</span> <span class="keywordtype">double</span> apply(P1 <span class="keyword">const</span>&amp;, P2 <span class="keyword">const</span>&amp;)
    {
        <span class="keywordflow">return</span> 0;
    }
};
</pre></div><p>
The distance function is calling that pythagoras struct, specifying the number of dimensions: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2&gt;
<span class="keywordtype">double</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(P1 <span class="keyword">const</span>&amp; a, P2 <span class="keyword">const</span>&amp; b)
{
    BOOST_STATIC_ASSERT(( <a class="code" href="classcore__dispatch_1_1dimension.html">dimension&lt;P1&gt;::value</a> == <a class="code" href="classcore__dispatch_1_1dimension.html">dimension&lt;P2&gt;::value</a> ));

    <span class="keywordflow">return</span> sqrt(pythagoras&lt;P1, P2, <a class="code" href="classcore__dispatch_1_1dimension.html">dimension&lt;P1&gt;::value</a>&gt;::apply(a, b));
}
</pre></div><p>
The dimension which is referred to is defined using another traits class: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>traits
{
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;
    <span class="keyword">struct </span><a class="code" href="classcore__dispatch_1_1dimension.html">dimension</a> {};
}
</pre></div><p>
which has to be specialized again for the struct <b>mypoint</b>. Because it only has to publish a value, it can be conveniently derived from the Boost Meta-Programming Library (MPL) class boost::mpl::int_: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>traits
{
    <span class="keyword">template</span> &lt;&gt;
    <span class="keyword">struct </span><a class="code" href="classcore__dispatch_1_1dimension.html">dimension</a>&lt;mypoint&gt;
        : boost::mpl::int_&lt;2&gt;
    {};
}
</pre></div><p>
Like the free function <b>get</b>, the library also contains a metafunction <b>dimension</b>. <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;
<span class="keyword">struct </span><a class="code" href="classcore__dispatch_1_1dimension.html">dimension</a> : traits::<a class="code" href="classcore__dispatch_1_1dimension.html">dimension</a>&lt;P&gt;
{};
</pre></div><p>
The extra declaration is convenient to not call the traits namespace. But there is a more important reason why it is useful. This is explained below. Now we have agnosticism in the number of dimensions. Our more generic distance function now accepts points of three or more dimensions. The compile-time assertion will prevent point <b>a</b> having two dimension and point <b>b</b> having three dimensions.<h2><a class="anchor" name="par5">
Coordinate type</a></h2>
We assumed double above. What if our points are in integer? We can easily add a traits class, and we will do that. However, the distance between two integer coordinates can still be a irrational value. Besides that, a design goal was to avoid square roots. We handle these cases below, in another paragraph. For the moment we keep returning double, but we allow integer coordinates for our point types. To define the coordinate type, we add another traits class, coordinate_type, which should be specialized by the library user: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>traits
{
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;
    <span class="keyword">struct </span>coordinate_type{};

    <span class="comment">// specialization for our mypoint</span>
    <span class="keyword">template</span> &lt;&gt;
    <span class="keyword">struct </span>coordinate_type&lt;mypoint&gt;
    {
        <span class="keyword">typedef</span> <span class="keywordtype">double</span> type;
    };
}
</pre></div><p>
Like the access function, where we had a free get function, we add a proxy here as well. A longer version is presented later on, the short function would look like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;
<span class="keyword">struct </span>coordinate_type :    traits::coordinate_type&lt;P&gt; {};
</pre></div><p>
We now can modify our distance algorithm again. Because it still returns double, we only modify the Pythagoras computation class. It should return the coordinate type of its input. But... it has two, possibly different, input point types. They might also differ in their coordinate types. Not that that is very likely, but we’re designing a generic library and we should handle those strange cases. We have to choose one of the coordinate types and of course we select the one with the highest precision. This is not worked out here, it would be too long, and it is not related to geometry. We just assume that there is a metafunction <b>select_most_precise</b> selecting the best type. So our computation class becomes: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2, <span class="keywordtype">int</span> D&gt;
<span class="keyword">struct </span>pythagoras
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> select_most_precise
        &lt;
            <span class="keyword">typename</span> coordinate_type&lt;P1&gt;::type,
            <span class="keyword">typename</span> coordinate_type&lt;P2&gt;::type
        &gt;::type computation_type;

    <span class="keyword">static</span> computation_type apply(P1 <span class="keyword">const</span>&amp; a, P2 <span class="keyword">const</span>&amp; b)
    {
        computation_type d = <span class="keyword">get</span>&lt;D-1&gt;(a) - get&lt;D-1&gt;(b);
        <span class="keywordflow">return</span> d * d + pythagoras &lt;P1, P2, D-1&gt; ::apply(a, b);
   }
};
</pre></div><h2><a class="anchor" name="par6">
Different geometries</a></h2>
At this point, we’ve designed a dimension agnostic system supporting any point type of any coordinate type. There are still some tweaks but they will be worked out later. Now we will see how we calculate the distance between a point and a polygon, or between a point and a line-segment. These formulae are more complex, and the influence on design is even larger. We don’t want to add a function with another name: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P, <span class="keyword">typename</span> S&gt;
<span class="keywordtype">double</span> distance_point_segment(P <span class="keyword">const</span>&amp; p, S <span class="keyword">const</span>&amp; s)
</pre></div><p>
We want to be generic, the distance function has to be called from code not knowing the type of geometry it handles, so it has to be named distance. We also cannot create an overload because that would be ambiguous, having the same template signature. There are two solutions to avoid this ambiguity:<ul>
<li>tag dispatching</li><li>SFINAE</li></ul>
<p>
We select tag dispatching because it fits into the traits system, and also because SFINAE has several drawbacks, listed in another paragraph. With tag dispatching the distance algorithm inspects the type of geometry of the input parameters. The distance function will be changed into this: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G1, <span class="keyword">typename</span> G2&gt;
<span class="keywordtype">double</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(G1 <span class="keyword">const</span>&amp; g1, G2 <span class="keyword">const</span>&amp; g2)
{
    <span class="keywordflow">return</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">dispatch::distance</a>
        &lt;
            <span class="keyword">typename</span> tag&lt;G1&gt;::type,
            <span class="keyword">typename</span> tag&lt;G2&gt;::type,
            G1, G2
        &gt;::apply(g1, g2);
}
</pre></div><p>
It is referring to a metafunction called <b>tag</b> and forwarding the call to the method <b>apply</b> of a dispatch::distance structure. The tag metafunction is another traits class, and should be specialized for per point type, both shown here: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>traits
{
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;
    <span class="keyword">struct </span>tag {};

    <span class="comment">// specialization</span>
    <span class="keyword">template</span> &lt;&gt;
    <span class="keyword">struct </span>tag&lt;mypoint&gt;
    {
        <span class="keyword">typedef</span> point_tag type;
    };
}
</pre></div><p>
There is again a free metafunction, like we did for <b>coordinate_system</b> and <b>get:</b> <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;
<span class="keyword">struct </span>tag : traits::tag&lt;G&gt; {};
</pre></div><p>
Tags (point_tag, segment_tag, etc) are empty structures with the sole purpose to specialize a dispatch class. The dispatch class for distance, and its specializations, are all defined in a separate namespace and look like the following:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>dispatch {
<span class="keyword">template</span> &lt; <span class="keyword">typename</span> Tag1, <span class="keyword">typename</span> Tag2, <span class="keyword">typename</span> G1, <span class="keyword">typename</span> G2 &gt;
<span class="keyword">struct </span><a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>
{};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2&gt;
<span class="keyword">struct </span><a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a> &lt; point_tag, point_tag, P1, P2 &gt;
{
    <span class="keyword">static</span> <span class="keywordtype">double</span> apply(P1 <span class="keyword">const</span>&amp; a, P2 <span class="keyword">const</span>&amp; b)
    {
        <span class="comment">// here we call pythagoras</span>
        <span class="comment">// exactly like we did before</span>
        ...
    }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> P, <span class="keyword">typename</span> S&gt;
<span class="keyword">struct </span><a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>
&lt;
    point_tag, segment_tag, P, S
&gt;
{
    <span class="keyword">static</span> <span class="keywordtype">double</span> apply(P <span class="keyword">const</span>&amp; p, S <span class="keyword">const</span>&amp; s)
    {
        <span class="comment">// here we refer to another function</span>
        <span class="comment">// implementing point-segment</span>
        <span class="comment">// calculations in 2 or 3</span>
        <span class="comment">// dimensions...</span>
        ...
    }
};
<span class="comment">// here we might have many more</span>
<span class="comment">// specializations,</span>
<span class="comment">// for point-polygon, box-circle, etc.</span>

} <span class="comment">// namespace</span>
</pre></div><p>
So yes, it is possible; the distance algorithm is generic now in the sense that it also supports different geometry types. One drawback: we have to define two dispatch specializations for point - segment and for segment - point separately. That will also be solved, in the paragraph reversibility below. The example below shows where we are now: different point types, geometry types, dimensions. <div class="fragment"><pre class="fragment">point a(1,1);
point b(2,2);
std::cout &lt;&lt; <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(a,b) &lt;&lt; std::endl;
segment s1(0,0,5,3);
std::cout &lt;&lt; <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(a, s1) &lt;&lt; std::endl;
rgb red(255, 0, 0);
rbc orange(255, 128, 0);
std::cout &lt;&lt; <span class="stringliteral">"color distance: "</span> &lt;&lt; <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(red, orange) &lt;&lt; std::endl;
</pre></div><h2><a class="anchor" name="par7">
Kernel revisited</a></h2>
We described above that we had a traits class coordinate_type, defined in namespace traits, and defined a separate coordinate_type class as well. This was actually not really necessary before, because the only difference was the namespace clause. But now that we have another geometry type, a segment in this case, it is essential. We can call the coordinate_type metafunction for any geometry type, point, segment, polygon, etc, implemented again by tag dispatching:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;
<span class="keyword">struct </span>coordinate_type
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> dispatch::coordinate_type
        &lt;
            <span class="keyword">typename</span> tag&lt;G&gt;::type, G
        &gt;::type type;
};
</pre></div><p>
Inside the dispatch namespace this metafunction is implemented twice: a generic version and one specialization for points. The specialization for points calls the traits class. The generic version calls the point specialization, as a sort of recursive metafunction definition:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>dispatch
{

<span class="comment">// Version for any geometry:</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> GeometryTag, <span class="keyword">typename</span> G&gt;
<span class="keyword">struct </span>coordinate_type
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> point_type
        &lt;
            GeometryTag, G
        &gt;::type point_type;

    <span class="comment">// Call specialization on point-tag</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> coordinate_type &lt; point_tag, point_type &gt;::type type;
};

<span class="comment">// Specialization for point-type:</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;
<span class="keyword">struct </span>coordinate_type&lt;point_tag, P&gt;
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span>
        traits::coordinate_type&lt;P&gt;::type
        type;
};
</pre></div><p>
So it calls another metafunction point_type. This is not elaborated in here but realize that it is available for all geometry types, and typedefs the point type which makes up the geometry, calling it type.<p>
The same applies for the metafunction dimension and for the upcoming metafunction coordinate system.<h2><a class="anchor" name="par8">
Coordinate system</a></h2>
Until here we assumed a Cartesian system. But we know that the Earth is not flat. Calculating a distance between two GPS-points with the system above would result in nonsense. So we again extend our design. We define for each point type a coordinate system type, using the traits system again. Then we make the calculation dependant on that coordinate system.<p>
Coordinate system is similar to coordinate type, a metafunction, calling a dispatch function to have it for any geometry-type, forwarding to its point specialization, and finally calling a traits class, defining a typedef type with a coordinate system. We don’t show that all here again. We only show the definition of a few coordinate systems: <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>cartesian {};

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> DegreeOrRadian&gt;
<span class="keyword">struct </span>geographic
{
    <span class="keyword">typedef</span> DegreeOrRadian units;
};
</pre></div><p>
So Cartesian is simple; for geographic we can also select if its coordinates are stored in degrees or in radians.<p>
The distance function will now change: it will select the computation method for the corresponding coordinate system and then call the dispatch struct for distance. We call the computation method specialized for coordinate systems a <b>strategy</b>. So the new version of the distance function is:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G1, <span class="keyword">typename</span> G2&gt;
<span class="keywordtype">double</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(G1 <span class="keyword">const</span>&amp; g1, G2 <span class="keyword">const</span>&amp; g2)
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> strategy_distance
        &lt;
            <span class="keyword">typename</span> coordinate_system&lt;G1&gt;::type,
            <span class="keyword">typename</span> coordinate_system&lt;G2&gt;::type,
            <span class="keyword">typename</span> point_type&lt;G1&gt;::type,
            <span class="keyword">typename</span> point_type&lt;G2&gt;::type,
            <a class="code" href="classcore__dispatch_1_1dimension.html">dimension&lt;G1&gt;::value</a>
        &gt;::type strategy;

    <span class="keywordflow">return</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">dispatch::distance</a>
        &lt;
            <span class="keyword">typename</span> tag&lt;G1&gt;::type,
            <span class="keyword">typename</span> tag&lt;G2&gt;::type,
            G1, G2, strategy
        &gt;::apply(g1, g2, strategy());
}
</pre></div><p>
The strategy_distance mentioned here is a metafunction with specializations for different coordinate systems.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2, <span class="keywordtype">int</span> D&gt;
<span class="keyword">struct </span>strategy_distance
{
    <span class="comment">// undefined; type is not defined</span>
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2, <span class="keywordtype">int</span> D&gt;
<span class="keyword">struct </span>strategy_distance&lt;cartesian, cartesian, P1, P2, D&gt;
{
    <span class="keyword">typedef</span> pythagoras&lt;P1, P2, D&gt; type;
};
</pre></div><p>
So here is our Pythagoras again, now defined as a strategy. The distance dispatch function just calls its apply method.<p>
So this is an important step: for spherical or geographical coordinate systems, another strategy (computation method) can be implemented. For spherical coordinate systems we have the haversine formula. So the dispatching traits struct is specialized like this <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2, <span class="keywordtype">int</span> D = 2&gt;
<span class="keyword">struct </span>strategy_distance&lt;spherical, spherical, P1, P2, D&gt;
{
    <span class="keyword">typedef</span> haversine&lt;P1, P2&gt; type;
};

<span class="comment">// struct haversine with apply function</span>
<span class="comment">// is omitted here</span>
</pre></div><p>
For geography, we have some alternatives for distance calculation. There is the Andoyer method, fast and precise, and there is the Vincenty method, slower and more precise, and there are some less precise approaches as well.<p>
Per coordinate system, one strategy is defined as the default strategy. To be able to use another strategy as well, we modify our design again and add an overload for the distance algorithm, taking a strategy object as a third parameter.<p>
This new overload distance function also has the advantage that the strategy can be constructed outside the distance function. Because it was constructed inside above, it could not have construction parameters. But for Andoyer or Vincenty, or the haversine formula, it certainly makes sense to have a constructor taking the radius of the earth as a parameter. So the distance overloaded function is:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G1, <span class="keyword">typename</span> G2, <span class="keyword">typename</span> S&gt;
<span class="keywordtype">double</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(G1 <span class="keyword">const</span>&amp; g1, G2 <span class="keyword">const</span>&amp; g2, S <span class="keyword">const</span>&amp; strategy)
{
    <span class="keywordflow">return</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">dispatch::distance</a>
        &lt;
            <span class="keyword">typename</span> tag&lt;G1&gt;::type,
            <span class="keyword">typename</span> tag&lt;G2&gt;::type,
            G1, G2, S
        &gt;::apply(g1, g2, strategy);
}
</pre></div><p>
The strategy has to have a method <b>apply</b> taking two points as arguments (for points). It is not required that it is a static method. A strategy might define a constructor, where a configuration value is passed and stored as a member variable. In those cases a static method would be inconvenient. It can be implemented as a normal method (with the const qualifier).<p>
We do not list all implementations here, Vincenty would cover half a page of mathematics, but you will understand the idea. We can call distance like this: <div class="fragment"><pre class="fragment"><a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(c1, c2)
</pre></div><p>
where c1,c2 are Cartesian points, or like this:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(g1, g2)
</pre></div><p>
where g1,g2 are Geographic points, calling the default strategy for Geographic points (e.g. Andoyer), and like this:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(g1, g2, vincenty&lt;G1, G2&gt;(6275))
</pre></div><p>
where a strategy is specified explicitly and constructed with a radius.<h2><a class="anchor" name="par9">
Point concept</a></h2>
The five traits classes mentioned in the paragraphs above form together the Point Concept. Any point type for which specializations are implemented in the traits namespace should be handled correctly by the library. So the Point concept consists of:<ul>
<li>a specialization for traits::tag</li><li>a specialization for traits::coordinate_system</li><li>a specialization for traits::coordinate_type</li><li>a specialization for traits::dimension</li><li>a specialization for traits::access</li></ul>
<p>
The last one is a class, containing the method <b>get</b> and the (optional) method <b>set</b>, the first four are metafunctions, either defining <b>type</b> or declaring <b>value</b> (conform MPL conventions). So we now have agnosticism for the number of dimensions, agnosticism for coordinate systems, our design can handle any coordinate type, and it can handle different geometry types. Furthermore we can specify our own strategies, the code will not compile in case of two points with different dimensions (because of the assertion), and it will not compile for two points with different coordinate systems (because there is no specialization). We still have the distance function returning double. Next paragraph will solve that.<h2><a class="anchor" name="par10">
Return type</a></h2>
We promised that calling sqrt was not always necessary. So we define a distance result struct that contains the squared value and is convertible to a double value. This, however, only has to be done for Pythagoras. The spherical distance functions do not take the square root so for them it is not necessary to avoid the expensive square root call; they can just return their distance. So the distance result struct is dependant on strategy, therefore made a member type of the strategy. The result struct looks like this: <div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keywordtype">double</span>&gt;
<span class="keyword">struct </span>cartesian_distance
{
    T sq;
    <span class="keyword">explicit</span> cartesian_distance(T <span class="keyword">const</span>&amp; v) : sq (v) {}

    <span class="keyword">inline</span> operator T()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> std::sqrt(sq);
    }
};
</pre></div><p>
It also has operators defined to compare itself to other results without taking the square root.<p>
Each strategy should define its return type, within the strategy class, e.g.:<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> cartesian_distance&lt;T&gt; return_type;
</pre></div> or:<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <span class="keywordtype">double</span> return_type
</pre></div><p>
for Pythagoras and spherical, respectively.<p>
Again our distance function will be modified, as expected, to reflect the new return type. For the overload with a strategy it is not complex: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> G1, <span class="keyword">typename</span> G2, <span class="keyword">typename</span> Strategy &gt;
<span class="keyword">typename</span> Strategy::return_type <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>( G1 <span class="keyword">const</span>&amp; G1 , G2 <span class="keyword">const</span>&amp; G2 , S <span class="keyword">const</span>&amp; strategy)
</pre></div><p>
But for the one without strategy we have to select strategy, coordinate type, etc. It would be spacious to do it in one line so we add a separate metafunction: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G1, <span class="keyword">typename</span> G2 = G1&gt;
<span class="keyword">struct </span>distance_result
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> point_type&lt;G1&gt;::type P1;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> point_type&lt;G2&gt;::type P2;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> strategy_distance
        &lt;
            <span class="keyword">typename</span> cs_tag&lt;P1&gt;::type,
            <span class="keyword">typename</span> cs_tag&lt;P2&gt;::type,
            P1, P2
        &gt;::type S;

    <span class="keyword">typedef</span> <span class="keyword">typename</span> S::return_type type;
};
</pre></div><p>
and modify our distance function: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G1, <span class="keyword">typename</span> G2&gt;
<span class="keyword">inline</span> <span class="keyword">typename</span> distance_result&lt;G1, G2&gt;::type <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(G1 <span class="keyword">const</span>&amp; g1, G2 <span class="keyword">const</span>&amp; g2)
{ ... }
</pre></div><p>
Of course also the apply functions in the dispatch specializations will return a result like this. They have a strategy as a template parameter everywhere, making the less verbose version possible.<h2><a class="anchor" name="par11">
Reversibility</a></h2>
Our dispatch::distance class was specialized for pairs of geometries, like &lt;point_tag, point_tag&gt; or &lt;point_tag, segment_tag&gt;. But library users can also call the distance function with a segment and a point, in that order. Actually, there are many geometry types (polygon, box, linestring), how to implement all combinations without duplicating all tag dispatching functions? The answer is that we automatically reverse the arguments, if appropriate. For distance it is appropriate because distance is a commutative function. We add a metafunction geometry_id, which has specializations for each geometry type, just derived from boost::mpl::int_, such that it can be ordered. Point is 1, segment is e.g. 2.<p>
Then we add a metafunction reverse_dispatch: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G1, <span class="keyword">typename</span> G2&gt;
<span class="keyword">struct </span>reverse_dispatch : detail::reverse_dispatch
    &lt;
        geometry_id&lt;G1&gt;::type::value,
        geometry_id&lt;G2&gt;::type::value
    &gt;
{};
</pre></div><p>
Because of the order in geometry_id, we can arrange (template) parameters in that order, in specializations. So the detail structure looks like: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>detail
{
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> Id1, <span class="keywordtype">int</span> Id2&gt;
    <span class="keyword">struct </span>reverse_dispatch : boost::mpl::if_c
        &lt;
            (Id1 &gt; Id2),
            boost::true_type,
            boost::false_type
        &gt;
    {};
</pre></div><p>
And our distance function will be modified again with some template meta-programming: We get <div class="fragment"><pre class="fragment"><span class="keywordflow">return</span> boost::mpl::if_c
    &lt;
        <a class="code" href="structboost_1_1geometry_1_1reverse__dispatch.html">boost::geometry::reverse_dispatch &lt;G1, G2&gt;::type::value</a>,
        detail::distance_reversed
            &lt;
                <span class="keyword">typename</span> tag&lt;G1&gt;::type,
                <span class="keyword">typename</span> tag&lt;G2&gt;::type,
                G1, G2,
                <span class="comment">// strategy</span>
            &gt;,
        <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">dispatch::distance</a>
            &lt;
                <span class="keyword">typename</span> tag&lt;G1&gt;::type,
                <span class="keyword">typename</span> tag&lt;G2&gt;::type,
                G1, G2,
                <span class="comment">// strategy</span>
            &gt;
        &gt;
    &gt;::type::apply(g1, g2, s);
</pre></div><p>
Where the detail::distance_reversed is a specific struct, forwarding its call to dispatch::distance, reversing all its template arguments and function arguments.<h2><a class="anchor" name="par13">
Multi-geometries</a></h2>
Consider Hawaii as a multi_polygon: it is a set of islands (polygons), forming together one entity. The shortest distance from a ship to Hawaii is the shortest distance to the closest island. That algorithm also holds for the shortest distance from a point to a multi-line or a multi-point. So we don't want to implement that functionality three times. Instead we add a metafunction, is_multi, which is always true for a multi-geometry (multi-point, multi-linestring, multi-polygon) and always false for the single versions.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Geometry&gt;
<span class="keyword">struct </span>is_multi : core_dispatch::is_multi&lt;typename tag&lt;Geometry&gt;::type&gt;
{};


<span class="keyword">namespace </span>dispatch
{

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> GeometryTag&gt;
<span class="keyword">struct </span>is_multi : boost::false_type {};

<span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct </span>is_multi&lt;multi_point_tag&gt; : boost::true_type {};


<span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct </span>is_multi&lt;multi_linestring_tag&gt; : boost::true_type {};


<span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct </span>is_multi&lt;multi_polygon_tag&gt; : boost::true_type {};

} <span class="comment">// namespace dispatch</span>
</pre></div><p>
Now we can specialize on is_multi, so we add two boolean IsMulti's, one for each geometry type, to our distance dispatch struct and make the call to them in the distance function:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// specialization:</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> GeometryTag1, <span class="keyword">typename</span> GeometryTag2, <span class="keyword">typename</span> G1, <span class="keyword">typename</span> G2, <span class="keyword">typename</span> Strategy&gt;
<span class="keyword">struct </span><a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>
    &lt;
        GeometryTag1, GeometryTag2, G1, G2, Strategy,
        false, <span class="comment">// G1 is_multi == false, so dispatch a 'single' geometry</span>
        true   <span class="comment">// G2 is_multi == true, so dispatch a multi-geometry</span>
    &gt;
   : detail::<a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>::distance_single_to_multi&lt;G1, G2, Strategy&gt;
{};
</pre></div><p>
If that relatively simple change is done, we have to do one thing: implement the single-to-multi distance implementation structure<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Geometry, <span class="keyword">typename</span> MultiGeometry, <span class="keyword">typename</span> Strategy&gt;
<span class="keyword">struct </span>distance_single_to_multi
{
   <span class="keyword">typedef</span> <span class="keyword">typename</span> Strategy::return_type return_type;

   <span class="keyword">static</span> return_type apply(Geometry <span class="keyword">const</span>&amp; geometry,
               MultiGeometry <span class="keyword">const</span>&amp; multi,
               Strategy <span class="keyword">const</span>&amp; strategy)
   {
       <span class="keyword">using namespace </span>boost;

       return_type mindist = make_distance_result&lt;return_type&gt;(
                       numeric::bounds&lt;typename select_coordinate_type&lt;Geometry, MultiGeometry&gt;::type&gt;::highest());

       <span class="keyword">typedef</span> <span class="keyword">typename</span> range_const_iterator&lt;MultiGeometry&gt;::type iterator;
       <span class="keywordflow">for</span>(iterator it = begin(multi); it != end(multi); ++it)
       {
           return_type dist = <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">boost::geometry::distance</a>(geometry, *it);
           <span class="keywordflow">if</span> (dist &lt; mindist)
           {
               mindist = dist;
           }
       }

       <span class="keywordflow">return</span> mindist;
   }
};
</pre></div><p>
which iterates over a collection of multi-shapes, and returns the shortest distance. Another function can implement the multi-to-multi function. Note that because of reversibility we don't have to implement the multi-to-single version (as long as multi's always have an higher ID than single's).<h2><a class="anchor" name="par14">
SFINAE</a></h2>
Instead of tag dispatching we alternatively could have chosen for SFINAE, mentioned above. With SFINAE (Substitution Failure Is Not An Error) we add optional parameters to the distance function, which sole use is to make an overload invalid for other geometry types than specified. So like: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2&gt;
<span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>(P1 <span class="keyword">const</span>&amp; p1, P2 <span class="keyword">const</span>&amp; p2
    , <span class="keyword">typename</span> boost::enable_if &lt;is_point&lt;P1&gt;   &gt;::type* = 0
    , <span class="keyword">typename</span> boost::enable_if &lt;is_point&lt;P2&gt;   &gt;::type* = 0
    )
    {
        <span class="keywordflow">return</span> impl::distance::point_to_point(p1, p2);
    }
</pre></div><p>
There would then be overloads for point-segment, point-polygon, etc. This SFINAE:<ul>
<li>gives often compiler troubles and headaches: if a user makes an error somewhere, the compiler will not select any of the methods, and/or it will give completely incomprehensible error listings, just because of this SFINAE. Stated otherwise (pasted from an answer on the list): With SFINAE the real error is hidden behind the phrase "Failed to specialize". The compiler discards all overloads, because of an error somewhere, and you get this error with no clue how to go on. What you get is the error that it is just failing. All overloads are gone, the compiler is not wrong, there is an error somewhere, but the only visible error message which makes sense for the compiler to give is something like "failed to specialize" or "no matching function call". With tag dispatching you get the real error message. That can also be difficult, but the message(s), sometimes a whole list, give at least a clue of what's wrong. In this case: add the banana-tag or add an implementation for banana. The usage of concepts should reduce the length of the list and give a clearer error message.</li><li>So the essence is: compiler errors in code based on tag dispatching are easier to find than compiler errors in code based on SFINAE, because the SFINAE-case is based on discarding overloads and <em>meaningful error messages are discarded as well</em></li><li>the combination of SFINAE and the BCCL using boost-concept-requires has been quite difficult, or impossible</li><li>does not support partial specializations because it is a function. The tag-dispatching function is of course also not supporting that, but it forwards its call to the dispatch struct where partial specializations (and member template functions) are possible. The SFINAE could do that as well but then: why not just add one tag more and have tag dispatching instead?</li><li>is a trick to deceive the compiler. “As a language behavior it was designed to avoid programs becoming ill-formed” (<a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error</a>), while tag dispatching is based on specialization, a core feature of C++</li><li>is more verbose (tag dispatching makes the main free function declarations shorter)</li><li>several Boost reviewers appreciated the tag dispatching approach and prefered them over SFINAE </li></ul>
</div>
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>December 1, 2009</p>
</small></td>
<td align="right">
<small>Copyright © 1995-2009 Barend Gehrels, Geodan, Amsterdam<br>
Copyright © 2008-2009 Bruno Lalande, Paris<br>
Copyright © 2009 Mateusz Loskot, Cadcorp, London<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
