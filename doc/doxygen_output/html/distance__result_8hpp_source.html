<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.Geometry (aka GGL, Generic Geometry Library)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.Geometry" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>boost/geometry/strategies/distance_result.hpp</h1><a href="distance__result_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Boost.Geometry (aka GGL, Generic Geometry Library)</span>
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright Barend Gehrels 2007-2009, Geodan, Amsterdam, the Netherlands.</span>
<a name="l00004"></a>00004 <span class="comment">// Copyright Bruno Lalande 2008, 2009</span>
<a name="l00005"></a>00005 <span class="comment">// Use, modification and distribution is subject to the Boost Software License,</span>
<a name="l00006"></a>00006 <span class="comment">// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00007"></a>00007 <span class="comment">// http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#ifndef BOOST_GEOMETRY_STRATEGIES_DISTANCE_RESULT_HPP</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_GEOMETRY_STRATEGIES_DISTANCE_RESULT_HPP</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;boost/mpl/if.hpp&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;boost/numeric/conversion/cast.hpp&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;boost/type_traits.hpp&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;<a class="code" href="cs_8hpp.html">boost/geometry/core/cs.hpp</a>&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;<a class="code" href="core_2point__type_8hpp.html">boost/geometry/core/point_type.hpp</a>&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;<a class="code" href="strategies_2distance_8hpp.html">boost/geometry/strategies/distance.hpp</a>&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="math_8hpp.html">boost/geometry/util/math.hpp</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="select__most__precise_8hpp.html">boost/geometry/util/select_most_precise.hpp</a>&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>geometry {
<a name="l00028"></a>00028 
<a name="l00040"></a>00040 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keywordtype">double</span>&gt;
<a name="l00041"></a><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html">00041</a> <span class="keyword">struct </span><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html" title="Encapsulate the results of distance calculation.">cartesian_distance</a>
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043     <span class="keyword">private</span> :
<a name="l00044"></a>00044         T m_squared_distance;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046         <span class="comment">// Because result is square-rooted, for integer, the cast should</span>
<a name="l00047"></a>00047         <span class="comment">// go to double and NOT to T</span>
<a name="l00048"></a>00048         <span class="keyword">typedef</span> <span class="keyword">typename</span>
<a name="l00049"></a>00049             boost::mpl::if_c
<a name="l00050"></a>00050             &lt;
<a name="l00051"></a>00051                 boost::is_integral&lt;T&gt;::type::value,
<a name="l00052"></a>00052                 double,
<a name="l00053"></a>00053                 T
<a name="l00054"></a>00054             &gt;::type cast_type;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 
<a name="l00059"></a>00059     <span class="keyword">public</span> :
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 
<a name="l00063"></a><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#99e0aa68fff7745ba4a54cbcda7aa396">00063</a>         <span class="keyword">explicit</span> <a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#99e0aa68fff7745ba4a54cbcda7aa396" title="Constructor with a value.">cartesian_distance</a>(T <span class="keyword">const</span>&amp; v) : m_squared_distance(v) {}
<a name="l00064"></a>00064 
<a name="l00067"></a><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#3f9f969063a78223888d2e293fc69593">00067</a>         <span class="keyword">inline</span> <a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#3f9f969063a78223888d2e293fc69593">operator cast_type</a>()<span class="keyword"> const</span>
<a name="l00068"></a>00068 <span class="keyword">        </span>{
<a name="l00069"></a>00069             <span class="keywordflow">return</span> boost::numeric_cast&lt;cast_type&gt;
<a name="l00070"></a>00070                 (
<a name="l00071"></a>00071 <span class="preprocessor">#if defined(NUMERIC_ADAPTOR_INCLUDED)</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span>                    boost::sqrt(
<a name="l00073"></a>00073 #<span class="keywordflow">else</span>
<a name="l00074"></a>00074                     std::sqrt(
<a name="l00075"></a>00075 #endif
<a name="l00076"></a>00076                         boost::numeric_cast
<a name="l00077"></a>00077                             &lt;
<a name="l00078"></a>00078                                 <span class="keyword">typename</span> <a class="code" href="structboost_1_1geometry_1_1select__most__precise.html" title="Meta-function to select, of two types, the most accurate type for calculations.">select_most_precise&lt;cast_type, double&gt;::type</a>
<a name="l00079"></a>00079                             &gt;(m_squared_distance)
<a name="l00080"></a>00080                             )
<a name="l00081"></a>00081                 );
<a name="l00082"></a>00082         }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084         <span class="comment">// Compare squared values</span>
<a name="l00085"></a><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#1d0a39dbf91a520f17789350f920e7f7">00085</a>         <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(cartesian_distance&lt;T&gt; <span class="keyword">const</span>&amp; other) <span class="keyword">const</span>
<a name="l00086"></a>00086         {
<a name="l00087"></a>00087             <span class="keywordflow">return</span> this-&gt;m_squared_distance &lt; other.m_squared_distance;
<a name="l00088"></a>00088         }
<a name="l00089"></a><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#ec97dd3194a4b11868e0453e9fcd36aa">00089</a>         <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#ec97dd3194a4b11868e0453e9fcd36aa">operator&gt;</a>(<a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html" title="Encapsulate the results of distance calculation.">cartesian_distance&lt;T&gt;</a> <span class="keyword">const</span>&amp; other)<span class="keyword"> const</span>
<a name="l00090"></a>00090 <span class="keyword">        </span>{
<a name="l00091"></a>00091             <span class="keywordflow">return</span> this-&gt;m_squared_distance &gt; other.m_squared_distance;
<a name="l00092"></a>00092         }
<a name="l00093"></a><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#12b111a0f9254fa82379b69b67b574e3">00093</a>         <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#12b111a0f9254fa82379b69b67b574e3">operator==</a>(<a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html" title="Encapsulate the results of distance calculation.">cartesian_distance&lt;T&gt;</a> <span class="keyword">const</span>&amp; other)<span class="keyword"> const</span>
<a name="l00094"></a>00094 <span class="keyword">        </span>{
<a name="l00095"></a>00095             <span class="keywordflow">return</span> <a class="code" href="group__equals.html#ge18e3cb2ad5b7fbc8f0ce9e0f92397bc" title="Detect if two geometries are spatially equal.">math::equals</a>(this-&gt;m_squared_distance, other.m_squared_distance);
<a name="l00096"></a>00096         }
<a name="l00097"></a>00097 
<a name="l00098"></a>00098         <span class="comment">// Compare just with a corresponding POD value</span>
<a name="l00099"></a>00099         <span class="comment">// Note: this is NOT possible because of the cast to double,</span>
<a name="l00100"></a>00100         <span class="comment">// it makes it for the compiler ambiguous which to take</span>
<a name="l00101"></a>00101         <span class="comment">/*</span>
<a name="l00102"></a>00102 <span class="comment">        inline bool operator&lt;(T const&amp; value) const</span>
<a name="l00103"></a>00103 <span class="comment">        {</span>
<a name="l00104"></a>00104 <span class="comment">            return this-&gt;m_squared_distance &lt; (value * value);</span>
<a name="l00105"></a>00105 <span class="comment">        }</span>
<a name="l00106"></a>00106 <span class="comment">        inline bool operator&gt;(T const&amp; value) const</span>
<a name="l00107"></a>00107 <span class="comment">        {</span>
<a name="l00108"></a>00108 <span class="comment">            return this-&gt;m_squared_distance &gt; (value * value);</span>
<a name="l00109"></a>00109 <span class="comment">        }</span>
<a name="l00110"></a>00110 <span class="comment">        inline bool operator==(T const&amp; value) const</span>
<a name="l00111"></a>00111 <span class="comment">        {</span>
<a name="l00112"></a>00112 <span class="comment">            return this-&gt;m_squared_distance == (value * value);</span>
<a name="l00113"></a>00113 <span class="comment">        }</span>
<a name="l00114"></a>00114 <span class="comment">        */</span>
<a name="l00115"></a>00115 
<a name="l00116"></a>00116         <span class="comment">// Utility method to compare without SQRT, but not with method above because for epsilon that</span>
<a name="l00117"></a>00117         <span class="comment">// makes no sense...</span>
<a name="l00118"></a><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#1ea62140abc516c36d9cd06a49251975">00118</a>         <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#1ea62140abc516c36d9cd06a49251975">very_small</a>()<span class="keyword"> const</span>
<a name="l00119"></a>00119 <span class="keyword">        </span>{
<a name="l00120"></a>00120             <span class="keywordflow">return</span> m_squared_distance &lt;= std::numeric_limits&lt;T&gt;::epsilon();
<a name="l00121"></a>00121         }
<a name="l00122"></a>00122 
<a name="l00124"></a><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#237ffd4ce4d94aaeb9cecb2259e28f9d">00124</a>         <span class="keyword">inline</span> T <a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#237ffd4ce4d94aaeb9cecb2259e28f9d" title="The &amp;quot;squared_value&amp;quot; method returns the internal squared value.">squared_value</a>()<span class="keyword"> const</span>
<a name="l00125"></a>00125 <span class="keyword">        </span>{
<a name="l00126"></a>00126             <span class="keywordflow">return</span> m_squared_distance;
<a name="l00127"></a>00127         }
<a name="l00128"></a>00128 
<a name="l00130"></a>00130         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Char, <span class="keyword">typename</span> Traits&gt;
<a name="l00131"></a>00131         <span class="keyword">inline</span> <span class="keyword">friend</span> std::basic_ostream&lt;Char, Traits&gt;&amp;
<a name="l00132"></a><a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html#01473d5ead508079201fa75545622ef5">00132</a>                 operator&lt;&lt;(std::basic_ostream&lt;Char, Traits&gt;&amp; os,
<a name="l00133"></a>00133                 <a class="code" href="structboost_1_1geometry_1_1cartesian__distance.html" title="Encapsulate the results of distance calculation.">cartesian_distance&lt;T&gt;</a> <span class="keyword">const</span>&amp; d)
<a name="l00134"></a>00134         {
<a name="l00135"></a>00135             <span class="comment">// Avoid "ambiguous function call" for MSVC</span>
<a name="l00136"></a>00136             cast_type <span class="keyword">const</span> sq = d.m_squared_distance;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138             os &lt;&lt;
<a name="l00139"></a>00139 <span class="preprocessor">#if defined(NUMERIC_ADAPTOR_INCLUDED)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>                boost::sqrt(sq);
<a name="l00141"></a>00141 <span class="preprocessor">#else</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span>                std::sqrt(sq);
<a name="l00143"></a>00143 <span class="preprocessor">#endif</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>            <span class="keywordflow">return</span> os;
<a name="l00145"></a>00145         }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 };
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="comment">/*</span>
<a name="l00152"></a>00152 <span class="comment"></span>
<a name="l00153"></a>00153 <span class="comment">    From Phil Endecott, on the list:</span>
<a name="l00154"></a>00154 <span class="comment"></span>
<a name="l00155"></a>00155 <span class="comment">    You can go further.  If I'm searching through a long list of points to</span>
<a name="l00156"></a>00156 <span class="comment">    find the closest to P then I'll avoid the squaring (and conversion to</span>
<a name="l00157"></a>00157 <span class="comment">    double if my co-ordinates are integers) whenever possible.  You can</span>
<a name="l00158"></a>00158 <span class="comment">    achieve this with a more complex distance proxy:</span>
<a name="l00159"></a>00159 <span class="comment"></span>
<a name="l00160"></a>00160 <span class="comment">    class distance_proxy {</span>
<a name="l00161"></a>00161 <span class="comment">       double dx;</span>
<a name="l00162"></a>00162 <span class="comment">       double dy;</span>
<a name="l00163"></a>00163 <span class="comment">       distance_proxy(double dx_, double dy_): dx(dx_), dy(dy_) {}</span>
<a name="l00164"></a>00164 <span class="comment">       friend pythag_distance(point,point);</span>
<a name="l00165"></a>00165 <span class="comment">    public:</span>
<a name="l00166"></a>00166 <span class="comment">       operator double() { return sqrt(dx*dx+dy*dy); }</span>
<a name="l00167"></a>00167 <span class="comment">       bool operator&gt;(double d) {</span>
<a name="l00168"></a>00168 <span class="comment">         return dx&gt;d</span>
<a name="l00169"></a>00169 <span class="comment">             || dy&gt;d</span>
<a name="l00170"></a>00170 <span class="comment">             || (dx*dx+dy*dy &gt; d*d);</span>
<a name="l00171"></a>00171 <span class="comment">       }</span>
<a name="l00172"></a>00172 <span class="comment">    };</span>
<a name="l00173"></a>00173 <span class="comment"></span>
<a name="l00174"></a>00174 <span class="comment">    So this is convertible to double, but can be compared to a distance</span>
<a name="l00175"></a>00175 <span class="comment">    without any need for sqrt() and only multiplication in some cases.</span>
<a name="l00176"></a>00176 <span class="comment">    Further refinement is possible.</span>
<a name="l00177"></a>00177 <span class="comment"></span>
<a name="l00178"></a>00178 <span class="comment"></span>
<a name="l00179"></a>00179 <span class="comment">    Barend:</span>
<a name="l00180"></a>00180 <span class="comment">    feasable, needs to be templatized by the number of dimensions. For distance it</span>
<a name="l00181"></a>00181 <span class="comment">    results in a nice "delayed calculation".</span>
<a name="l00182"></a>00182 <span class="comment">    For searching you might take another approach, first calculate dx, if OK then dy,</span>
<a name="l00183"></a>00183 <span class="comment">    if OK then the sqrs. So as above but than distance does not need to be calculated.</span>
<a name="l00184"></a>00184 <span class="comment">    So it is in fact another strategy.</span>
<a name="l00185"></a>00185 <span class="comment"></span>
<a name="l00186"></a>00186 <span class="comment"></span>
<a name="l00187"></a>00187 <span class="comment">*/</span>
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="preprocessor">#ifndef DOXYGEN_NO_DETAIL</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span><span class="keyword">namespace </span>detail
<a name="l00193"></a>00193 {
<a name="l00194"></a>00194     <span class="keyword">namespace </span><a class="code" href="group__distance.html#g8fb8022d64a75b24c80a64ba46ec4738" title="Calculate distance between two geometries with a specified strategy.">distance</a>
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T&gt;
<a name="l00197"></a>00197         <span class="keyword">struct </span>distance_result_maker
<a name="l00198"></a>00198         {
<a name="l00199"></a>00199         };
<a name="l00200"></a>00200 
<a name="l00201"></a>00201         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T&gt;
<a name="l00202"></a>00202         <span class="keyword">struct </span>distance_result_maker&lt;geometry::cartesian_distance&lt;R&gt;, T&gt;
<a name="l00203"></a>00203         {
<a name="l00204"></a>00204             <span class="keyword">static</span> <span class="keyword">inline</span> geometry::cartesian_distance&lt;R&gt; apply(T <span class="keyword">const</span>&amp; value)
<a name="l00205"></a>00205             {
<a name="l00206"></a>00206                 <span class="keywordflow">return</span> cartesian_distance&lt;R&gt;(value * value);
<a name="l00207"></a>00207             }
<a name="l00208"></a>00208         };
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00211"></a>00211         <span class="keyword">struct </span>distance_result_maker&lt;double, T&gt;
<a name="l00212"></a>00212         {
<a name="l00213"></a>00213             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> apply(T <span class="keyword">const</span>&amp; value)
<a name="l00214"></a>00214             {
<a name="l00215"></a>00215                 <span class="keywordflow">return</span> value;
<a name="l00216"></a>00216             }
<a name="l00217"></a>00217         };
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00221"></a>00221         <span class="keyword">struct </span><a class="code" href="group__distance.html#g6a93c06cf7276a34ea9701d82faf25cd" title="Utility function to check if a distance is very small.">close_to_zero</a>
<a name="l00222"></a>00222         {
<a name="l00223"></a>00223             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> apply(T <span class="keyword">const</span>&amp; value)
<a name="l00224"></a>00224             {
<a name="l00225"></a>00225                 <span class="keywordflow">return</span> value &lt;= std::numeric_limits&lt;T&gt;::epsilon();
<a name="l00226"></a>00226             }
<a name="l00227"></a>00227         };
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 
<a name="l00230"></a>00230         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00231"></a>00231         <span class="keyword">struct </span><a class="code" href="group__distance.html#g6a93c06cf7276a34ea9701d82faf25cd" title="Utility function to check if a distance is very small.">close_to_zero</a>&lt;geometry::cartesian_distance&lt;T&gt; &gt;
<a name="l00232"></a>00232         {
<a name="l00233"></a>00233             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> apply(geometry::cartesian_distance&lt;T&gt; <span class="keyword">const</span>&amp; value)
<a name="l00234"></a>00234             {
<a name="l00235"></a>00235                 <span class="keywordflow">return</span> value.very_small();
<a name="l00236"></a>00236             }
<a name="l00237"></a>00237         };
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 
<a name="l00240"></a>00240         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00241"></a>00241         <span class="keyword">struct </span><a class="code" href="namespaceboost_1_1geometry.html#5a4641921f2b225906be1755fa2cc3f7">fuzzy_equals</a>
<a name="l00242"></a>00242         {
<a name="l00243"></a>00243             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> apply(T <span class="keyword">const</span>&amp; left, T <span class="keyword">const</span>&amp; right)
<a name="l00244"></a>00244             {
<a name="l00245"></a>00245                 <span class="keywordflow">return</span> std::abs(left - right) &lt; 0.01;
<a name="l00246"></a>00246             }
<a name="l00247"></a>00247         };
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00251"></a>00251         <span class="keyword">struct </span><a class="code" href="namespaceboost_1_1geometry.html#5a4641921f2b225906be1755fa2cc3f7">fuzzy_equals</a>&lt;geometry::cartesian_distance&lt;T&gt; &gt;
<a name="l00252"></a>00252         {
<a name="l00253"></a>00253             <span class="keyword">typedef</span> geometry::cartesian_distance&lt;T&gt; D;
<a name="l00254"></a>00254             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> apply(D <span class="keyword">const</span>&amp; left, D <span class="keyword">const</span>&amp; right)
<a name="l00255"></a>00255             {
<a name="l00256"></a>00256                 <span class="keywordflow">return</span> std::abs(left.squared_value() - right.squared_value()) &lt; 1;
<a name="l00257"></a>00257             }
<a name="l00258"></a>00258         };
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     }
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 <span class="preprocessor">#endif</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span>
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 
<a name="l00272"></a>00272 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Geometry1, <span class="keyword">typename</span> Geometry2 = Geometry1&gt;
<a name="l00273"></a><a class="code" href="structboost_1_1geometry_1_1distance__result.html">00273</a> <span class="keyword">struct </span><a class="code" href="structboost_1_1geometry_1_1distance__result.html" title="Shortcut to define return type of distance strategy.">distance_result</a>
<a name="l00274"></a>00274 {
<a name="l00275"></a><a class="code" href="structboost_1_1geometry_1_1distance__result.html#e4af2db01cc76aeaf37fd01133dbee65">00275</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1geometry_1_1point__type.html" title="Meta-function which defines point type of any geometry.">point_type&lt;Geometry1&gt;::type</a> <a class="code" href="structboost_1_1geometry_1_1distance__result.html#e4af2db01cc76aeaf37fd01133dbee65">point_type1</a>;
<a name="l00276"></a><a class="code" href="structboost_1_1geometry_1_1distance__result.html#9e92abe36c842ccb1560ee816355fcf0">00276</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1geometry_1_1point__type.html" title="Meta-function which defines point type of any geometry.">point_type&lt;Geometry2&gt;::type</a> <a class="code" href="structboost_1_1geometry_1_1distance__result.html#9e92abe36c842ccb1560ee816355fcf0">point_type2</a>;
<a name="l00277"></a>00277     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1geometry_1_1strategy__distance.html" title="Traits class binding a distance strategy to a (possibly two) coordinate system(s)...">strategy_distance</a>
<a name="l00278"></a>00278         &lt;
<a name="l00279"></a>00279             <span class="keyword">typename</span> <a class="code" href="structboost_1_1geometry_1_1cs__tag.html" title="Meta-function returning coordinate system tag (cs family) of any geometry.">cs_tag&lt;point_type1&gt;::type</a>,
<a name="l00280"></a>00280             <span class="keyword">typename</span> <a class="code" href="structboost_1_1geometry_1_1cs__tag.html" title="Meta-function returning coordinate system tag (cs family) of any geometry.">cs_tag&lt;point_type2&gt;::type</a>,
<a name="l00281"></a>00281             <a class="code" href="structboost_1_1geometry_1_1distance__result.html#e4af2db01cc76aeaf37fd01133dbee65">point_type1</a>,
<a name="l00282"></a>00282             <a class="code" href="structboost_1_1geometry_1_1distance__result.html#9e92abe36c842ccb1560ee816355fcf0">point_type2</a>
<a name="l00283"></a><a class="code" href="structboost_1_1geometry_1_1distance__result.html#99e65bb6b7a8dfd23301cec1263ec934">00283</a>         &gt;<a class="code" href="structboost_1_1geometry_1_1distance__result.html#c78cf16b4ef80a80aa3bba68005b1191">::type</a> <a class="code" href="structboost_1_1geometry_1_1strategy_1_1not__implemented.html" title="Indicate compiler/library user that strategy is not implemented.">strategy_type</a>;
<a name="l00284"></a><a class="code" href="structboost_1_1geometry_1_1distance__result.html#c78cf16b4ef80a80aa3bba68005b1191">00284</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> strategy_type::return_type <a class="code" href="structboost_1_1geometry_1_1distance__result.html#c78cf16b4ef80a80aa3bba68005b1191">type</a>;
<a name="l00285"></a>00285 };
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 
<a name="l00302"></a>00302 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T&gt;
<a name="l00303"></a><a class="code" href="group__distance.html#gfd1d932eefc782b38776b2c49b56575f">00303</a> <span class="keyword">inline</span> R <a class="code" href="group__distance.html#gfd1d932eefc782b38776b2c49b56575f" title="Object generator to create instance which can be compared.">make_distance_result</a>(T <span class="keyword">const</span>&amp; value)
<a name="l00304"></a>00304 {
<a name="l00305"></a>00305     <span class="keywordflow">return</span> detail::distance::distance_result_maker&lt;R, T&gt;::apply(value);
<a name="l00306"></a>00306 }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 
<a name="l00317"></a>00317 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00318"></a><a class="code" href="group__distance.html#g6a93c06cf7276a34ea9701d82faf25cd">00318</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__distance.html#g6a93c06cf7276a34ea9701d82faf25cd" title="Utility function to check if a distance is very small.">close_to_zero</a>(T <span class="keyword">const</span>&amp; value)
<a name="l00319"></a>00319 {
<a name="l00320"></a>00320     <span class="keywordflow">return</span> detail::distance::close_to_zero&lt;T&gt;::apply(value);
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00324"></a><a class="code" href="namespaceboost_1_1geometry.html#5a4641921f2b225906be1755fa2cc3f7">00324</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1geometry.html#5a4641921f2b225906be1755fa2cc3f7">fuzzy_equals</a>(T <span class="keyword">const</span>&amp; left, T <span class="keyword">const</span>&amp; right)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326     <span class="keywordflow">return</span> detail::distance::fuzzy_equals&lt;T&gt;::apply(left, right);
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 }} <span class="comment">// namespace boost::geometry</span>
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 <span class="preprocessor">#endif // BOOST_GEOMETRY_STRATEGIES_DISTANCE_RESULT_HPP</span>
</pre></div></div>
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>December 1, 2009</p>
</small></td>
<td align="right">
<small>Copyright © 1995-2009 Barend Gehrels, Geodan, Amsterdam<br>
Copyright © 2008-2009 Bruno Lalande, Paris<br>
Copyright © 2009 Mateusz Loskot, Cadcorp, London<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
