[/============================================================================
  Boost.Geometry Index

  Copyright (c) 2011-2012 Adam Wulkiewicz.

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section Introduction]

__rtree__ is a tree data structure used for spatial searching. It was proposed by
Antonin Guttman in 1984 [footnote Guttman, A. (1984). /R-Trees: A Dynamic Index Structure for Spatial Searching/]
as an expansion of B-tree for multi-dimensional data. It may be used to store points or volumetric data in order to
perform a spatial query later. This query may return objects that are inside some area or are close to some point in space.

The __rtree__ structure is presented on the image below. Each __rtree__'s node store a box descring the space occupied by
its children nodes. At the bottom of the structure, there are leaf-nodes which contains values
(geometric objects representations).

[$../images/rstar.png]

The number of maximum and mininimum node's elements must be specified by the user. If the number of elements reaches it's maximum
the new node is created and elements are split between nodes. If the number of elements in node is too small, the node is deleted
and elements are reinserted into the tree.

The __rtree__ is a self-balanced data structure. The key part of balancing algorithm is node splitting algorithm
[footnote Greene, D. (1989). /An implementation and performance analysis of spatial data access methods/]
[footnote Beckmann, N.; Kriegel, H. P.; Schneider, R.; Seeger, B. (1990). /The R*-tree: an efficient and robust access method for points and rectangles/].
Each algorithm produces different splits so the internal structure of a tree may be different for each one of them.
In general more complex algorithms analyses elements better and produces less overlapping nodes. In the searching process less nodes must be traversed
in order to find desired obejcts. On the other hand more complex analysis takes more time. In general faster inserting will result in slower searching
and vice versa. Example structures of trees created by use of three different algorithms and operations time are presented below.

[table
[[]         [linear algorithm] [quadratic algorithm] [R*-tree]]
[[*Structure*][[$../images/linear.png]] [[$../images/quadratic.png]] [[$../images/rstar.png]]]
[[*1M Values inserts*] [1.85s] [3.10s] [24.52s]]
[[*1M spatial queries*][8.60s] [2.74s] [1.31s]]
[[*100k knn queries*]  [3.49s] [1.59s] [0.84s]]
]

Key features of this implementation of the __rtree__ are:

* three different creation algorithms - linear, quadratic or rstar,
* parameters (including maximal and minimal number of elements) may be passed as compile- or run-time parameters - compile-time version is faster,
* capable to store arbitrary __value__ type,
* sophisticated queries - e.g. search for 5 nearest values intersecting some region but not within the other one.

[endsect]


