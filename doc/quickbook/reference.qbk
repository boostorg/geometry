[/
 / Copyright (c) 2010 Mateusz Loskot (mateusz at loskot dot net
 / Copyright (c) 2003-2010 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:reference Reference]

[xinclude quickref.xml]

[include geometry_concepts.qbk]


[section:add_const_if_c add_const_if_c]


Meta-function to define a const or non const type. 




[heading Synopsis]
  template<
      bool ``[link boost_geometry.reference.IsConst IsConst]``,
      typename Type >
  struct add_const_if_c

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.add_const_if_c.type [*type]]]
    []
  
  ]

]


[heading Description]

If the boolean template parameter is true, the type parameter will be defined as const, otherwise it will be defined as it was. This meta-function is used to have one implementation for both const and non const references 

[heading Remarks]
      
This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

Used in a.o. for\_each, interior\_rings, exterior\_ring 


[heading Example]
  


          void foo(typename add_const_if_c<IsConst, Point>::type& point)






[heading Requirements]

[*Header: ][^boost/geometry/util/add_const_if_c.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type add_const_if_c::type]

[indexterm2 type..add_const_if_c] 

  typedef boost::mpl::if_c< IsConst, const Type, Type >::type type;



[heading Requirements]

[*Header: ][^boost/geometry/util/add_const_if_c.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]


[section:add_point add_point]

[indexterm1 add_point] 
Adds a [link boost_geometry.reference.point `point`] to another. 


  template<
      typename Point1 ,
      typename Point2 >
  void add_point(
      Point1 & p1,
      Point2 const & p2);


The coordinates of the second [link boost_geometry.reference.point `point`] will be added to those of the first [link boost_geometry.reference.point `point`]. The second [link boost_geometry.reference.point `point`] is not modified. 
[heading Parameters]
    

[variablelist
  
[[p1][first [link boost_geometry.reference.point `point`] ]]

[[p2][second [link boost_geometry.reference.point `point`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:add_value add_value]

[indexterm1 add_value] 
Adds a value to each coordinate of a [link boost_geometry.reference.point `point`]. 


  template<
      typename Point >
  void add_value(
      Point & p,
      typename detail::param< Point >::type value);



[heading Parameters]
    

[variablelist
  
[[p][[link boost_geometry.reference.point `point`] ]]

[[value][value to add ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:append append]

[indexterm1 append] 
Appends one or more points to a [link boost_geometry.reference.linestring `linestring`], ring, [link boost_geometry.reference.polygon `polygon`], multi. 


  template<
      typename Geometry ,
      typename RoP >
  void append(
      Geometry & geometry,
      RoP const & range_or_point,
      int ring_index = -1,
      int multi_index = 0);



[heading Parameters]
    

[variablelist
  
[[geometry][a [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[range_or_point][the [link boost_geometry.reference.point `point`] or range to add ]]

[[ring_index][the index of the ring in case of a [link boost_geometry.reference.polygon `polygon`]: exterior ring (-1, the default) or interior ring index ]]

[[multi_index][reserved for multi polygons ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/append.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:area area]

[indexterm1 area] 
      
  template<
      typename Geometry >
  area_result< Geometry >::type ``[link boost_geometry.reference.area.overload1 area]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.area.overload1 more...]]``

  template<
      typename Geometry ,
      typename Strategy >
  Strategy::return_type ``[link boost_geometry.reference.area.overload2 area]``(
      Geometry const & geometry,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.area.overload2 more...]]``


[heading Performance]
  
2776 * 1000 area calculations are done in 0.11 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Area1)


[heading Coordinate systems and strategies]
  
Area calculation can be done in Cartesian and in spherical/geographic coordinate systems.


[heading Geometries]
  
The area algorithm calculates the surface area of all geometries having a surface: box, polygon, multi\_polygon. The units are the square of the units used for the points defining the surface. If the polygon is defined in meters, the area is in square meters.


[heading Example:]
  
Example showing area calculation of polygons built  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/area.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 area (1 of 2 overloads)]


Calculate area of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry >
  area_result< Geometry >::type area(
      Geometry const & geometry);


The function area returns the area of a [link boost_geometry.reference.polygon `polygon`], ring, [link boost_geometry.reference.box `box`] using the default area-calculation [link boost_geometry.reference.strategy `strategy`]. Strategies are provided for cartesian and spherical coordinate systems The geometries should correct, polygons should be closed and according to the specified orientation (clockwise/counter clockwise) 
[heading Parameters]
    

[variablelist
  
[[geometry][a [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
the area 




[endsect]



[section:overload2 area (2 of 2 overloads)]


Calculate area of a [link boost_geometry.reference.boost__geometry `boost::geometry`] using a specified [link boost_geometry.reference.strategy `strategy`]. 


  template<
      typename Geometry ,
      typename Strategy >
  Strategy::return_type area(
      Geometry const & geometry,
      Strategy const & strategy);


This version of area calculation takes a [link boost_geometry.reference.strategy `strategy`] 
[heading Parameters]
    

[variablelist
  
[[geometry][a [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[strategy][the [link boost_geometry.reference.strategy `strategy`] to calculate area. Especially for spherical areas there are some approaches. ]]

]



[heading Return Value]
      
the area 




[endsect]


[endsect]

[section:area_result area_result]


Meta-function defining return type of area function. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.Geometry Geometry]``>
  struct area_result

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.area_result.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.area_result.strategy_type [*strategy_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.area_result.type [*type]]]
    []
  
  ]

]


[heading Description]



[heading Remarks]
      
The [link boost_geometry.reference.strategy `strategy`] defines the return-type (so this situation is different from length, where distance is sqr/sqrt, but length always squared) 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/area_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:point_type area_result::point_type]

[indexterm2 point_type..area_result] 

  typedef point_type< Geometry >::type point_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_type.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/area_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:strategy_type area_result::strategy_type]

[indexterm2 strategy_type..area_result] 

  typedef strategy_area< typename cs_tag< point_type >::type, point_type >::type strategy_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_area.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    


[variablelist
  
[[Tag][[link boost_geometry.reference.tag `tag`] of coordinate system ]]

[[PointOfSegment][point-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/strategies/area_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:type area_result::type]

[indexterm2 type..area_result] 

  typedef strategy_type::return_type type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/area_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:as_range as_range]

[indexterm1 as_range] 
Function getting either the range (ring, [link boost_geometry.reference.linestring `linestring`]) itself or the outer ring ([link boost_geometry.reference.polygon `polygon`]). 

    
  template<
      typename Range ,
      typename Geometry >
  Range & ``[link boost_geometry.reference.as_range.overload1 as_range]``(
      Geometry & input);
  ``  [''''&raquo;''' [link boost_geometry.reference.as_range.overload1 more...]]``

  template<
      typename Range ,
      typename Geometry >
  Range const & ``[link boost_geometry.reference.as_range.overload2 as_range]``(
      Geometry const & input);
  ``  [''''&raquo;''' [link boost_geometry.reference.as_range.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/util/as_range.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 as_range (1 of 2 overloads)]


Function getting either the range (ring, [link boost_geometry.reference.linestring `linestring`]) itself or the outer ring ([link boost_geometry.reference.polygon `polygon`]). 


  template<
      typename Range ,
      typename Geometry >
  Range & as_range(
      Geometry & input);


Utility to handle polygon's outer ring as a range 


[endsect]



[section:overload2 as_range (2 of 2 overloads)]


Function getting either the range (ring, [link boost_geometry.reference.linestring `linestring`]) itself or the outer ring ([link boost_geometry.reference.polygon `polygon`]), const version. 


  template<
      typename Range ,
      typename Geometry >
  Range const & as_range(
      Geometry const & input);


Utility to handle polygon's outer ring as a range 


[endsect]


[endsect]


[section:assert_dimension assert_dimension]

[indexterm1 assert_dimension] 
assert\_dimension, enables compile-time checking if coordinate dimensions are as expected 


  template<
      typename G ,
      int ``[link boost_geometry.reference.D D]``>
  void assert_dimension();


[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assert_dimension_equal assert_dimension_equal]

[indexterm1 assert_dimension_equal] 
assert\_dimension\_equal, enables compile-time checking if coordinate dimensions of two geometries are equal 


  template<
      typename G1 ,
      typename G2 >
  void assert_dimension_equal();


[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assert_dimension_greater_equal assert_dimension_greater_equal]

[indexterm1 assert_dimension_greater_equal] 

  template<
      typename G ,
      int ``[link boost_geometry.reference.D D]``>
  void assert_dimension_greater_equal();


[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assert_dimension_less_equal assert_dimension_less_equal]

[indexterm1 assert_dimension_less_equal] 
assert\_dimension, enables compile-time checking if coordinate dimensions are as expected 


  template<
      typename G ,
      int ``[link boost_geometry.reference.D D]``>
  void assert_dimension_less_equal();


[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:assign assign]

[indexterm1 assign] 
assign two values to a 2D [link boost_geometry.reference.point `point`] 

    
  template<
      typename Geometry ,
      typename Type >
  void ``[link boost_geometry.reference.assign.overload1 assign]``(
      Geometry & geometry,
      Type const & c1,
      Type const & c2);
  ``  [''''&raquo;''' [link boost_geometry.reference.assign.overload1 more...]]``

  template<
      typename Geometry ,
      typename Type >
  void ``[link boost_geometry.reference.assign.overload2 assign]``(
      Geometry & geometry,
      Type const & c1,
      Type const & c2,
      Type const & c3);
  ``  [''''&raquo;''' [link boost_geometry.reference.assign.overload2 more...]]``

  template<
      typename Geometry ,
      typename Type >
  void ``[link boost_geometry.reference.assign.overload3 assign]``(
      Geometry & geometry,
      Type const & c1,
      Type const & c2,
      Type const & c3,
      Type const & c4);
  ``  [''''&raquo;''' [link boost_geometry.reference.assign.overload3 more...]]``

  template<
      typename Geometry ,
      typename Range >
  void ``[link boost_geometry.reference.assign.overload4 assign]``(
      Geometry & geometry,
      Range const & range);
  ``  [''''&raquo;''' [link boost_geometry.reference.assign.overload4 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 assign (1 of 4 overloads)]


assign two values to a 2D [link boost_geometry.reference.point `point`] 


  template<
      typename Geometry ,
      typename Type >
  void assign(
      Geometry & geometry,
      Type const & c1,
      Type const & c2);



[endsect]



[section:overload2 assign (2 of 4 overloads)]


assign three values to a 3D [link boost_geometry.reference.point `point`] \[or the center + radius to a circle\] 


  template<
      typename Geometry ,
      typename Type >
  void assign(
      Geometry & geometry,
      Type const & c1,
      Type const & c2,
      Type const & c3);



[endsect]



[section:overload3 assign (3 of 4 overloads)]


assign center + radius to a sphere \[for extension\] 


  template<
      typename Geometry ,
      typename Type >
  void assign(
      Geometry & geometry,
      Type const & c1,
      Type const & c2,
      Type const & c3,
      Type const & c4);



[endsect]



[section:overload4 assign (4 of 4 overloads)]


assign a range of points to a [link boost_geometry.reference.linestring `linestring`], ring or [link boost_geometry.reference.polygon `polygon`] 


  template<
      typename Geometry ,
      typename Range >
  void assign(
      Geometry & geometry,
      Range const & range);




[heading Remarks]
      
The point-type of the range might be different from the point-type of the [link boost_geometry.reference.boost__geometry `boost::geometry`] 




[endsect]


[endsect]


[section:assign_box_corners assign_box_corners]

[indexterm1 assign_box_corners] 
Assign the 4 points of a 2D [link boost_geometry.reference.box `box`]. 


  template<
      typename Box ,
      typename Point >
  void assign_box_corners(
      Box const & box,
      Point & lower_left,
      Point & lower_right,
      Point & upper_left,
      Point & upper_right);




[heading Remarks]
      
The order is crucial. Most logical is LOWER, UPPER and sub-order LEFT, RIGHT so this is how it is implemented. 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assign_inverse assign_inverse]

[indexterm1 assign_inverse] 
assign to a [link boost_geometry.reference.box `box`] inverse infinite 


  template<
      typename Geometry >
  void assign_inverse(
      Geometry & geometry);


The assign\_inverse function initialize a 2D or 3D [link boost_geometry.reference.box `box`] with large coordinates, the min corner is very large, the max corner is very small. This is a convenient `starting` [link boost_geometry.reference.point `point`] to collect the minimum bounding [link boost_geometry.reference.box `box`] of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assign_point_from_index assign_point_from_index]

[indexterm1 assign_point_from_index] 
Assign a [link boost_geometry.reference.point `point`] with a [link boost_geometry.reference.point `point`] of a [link boost_geometry.reference.box `box`] or [link boost_geometry.reference.segment `segment`]. 


  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      typename Point ,
      typename Geometry >
  void assign_point_from_index(
      Geometry const & geometry,
      Point & point);




[variablelist
  
[[Index][indicates which box-corner, min\_corner (0) or max\_corner (1) or which [link boost_geometry.reference.point `point`] of [link boost_geometry.reference.segment `segment`] (0/1) ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assign_point_to_index assign_point_to_index]

[indexterm1 assign_point_to_index] 
Assign a [link boost_geometry.reference.box `box`] or [link boost_geometry.reference.segment `segment`] with the value of a [link boost_geometry.reference.point `point`]. 


  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      typename Geometry ,
      typename Point >
  void assign_point_to_index(
      Point const & point,
      Geometry & geometry);




[variablelist
  
[[Index][indicates which box-corner, min\_corner (0) or max\_corner (1) or which [link boost_geometry.reference.point `point`] of [link boost_geometry.reference.segment `segment`] (0/1) ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assign_zero assign_zero]

[indexterm1 assign_zero] 
assign zero values to a [link boost_geometry.reference.box `box`], [link boost_geometry.reference.point `point`] 


  template<
      typename Geometry >
  void assign_zero(
      Geometry & geometry);


The assign\_zero function initializes a 2D or 3D [link boost_geometry.reference.point `point`] or [link boost_geometry.reference.box `box`] with coordinates of zero 

[variablelist
  
[[Geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:box box]


Class [link boost_geometry.reference.box `box`]: defines a [link boost_geometry.reference.box `box`] made of two describing points. 




[heading Synopsis]
  template<
      typename Point >
  class box

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.box.box [*box]]]
    [

     Constructor taking the minimum corner point and the maximum corner point. ]
  ]
  
  [
    [[link boost_geometry.reference.box.max_corner [*max_corner]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.box.min_corner [*min_corner]]]
    []
  ]
  
]


[heading Description]

Box is always described by a `min_corner()` and a `max_corner()` [link boost_geometry.reference.point `point`]. If another rectangle is used, use [link boost_geometry.reference.linear_ring `linear_ring`] or [link boost_geometry.reference.polygon `polygon`]. 

[heading Remarks]
      
Boxes are for selections and for calculating the envelope of geometries. Not all algorithms are implemented for [link boost_geometry.reference.box `box`]. Boxes are also used in Spatial Indexes. 



[variablelist
  
[[Point][[link boost_geometry.reference.point `point`] type. The [link boost_geometry.reference.box `box`] takes a [link boost_geometry.reference.point `point`] type as template parameter. The [link boost_geometry.reference.point `point`] type can be any [link boost_geometry.reference.point `point`] type. It can be 2D but can also be 3D or more dimensional. The [link boost_geometry.reference.box `box`] can also take a latlong [link boost_geometry.reference.point `point`] type as template parameter. ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/box.hpp]

[*Convenience header: ][^boost/geometry.hpp]

[section:box box::box]

[indexterm2 box..box] 

  ``[link boost_geometry.reference.box.box.overload1 box]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.box.box.overload1 more...]]``


Constructor taking the minimum corner [link boost_geometry.reference.point `point`] and the maximum corner [link boost_geometry.reference.point `point`]. 


  ``[link boost_geometry.reference.box.box.overload2 box]``(
      Point const & min_corner,
      Point const & max_corner);
  ``  [''''&raquo;''' [link boost_geometry.reference.box.box.overload2 more...]]``


[section:overload1 box::box (1 of 2 overloads)]



  box();



[endsect]



[section:overload2 box::box (2 of 2 overloads)]


Constructor taking the minimum corner [link boost_geometry.reference.point `point`] and the maximum corner [link boost_geometry.reference.point `point`]. 


  box(
      Point const & min_corner,
      Point const & max_corner);



[endsect]


[endsect]

[section:max_corner box::max_corner]

[indexterm2 max_corner..box] 

  Point const & ``[link boost_geometry.reference.box.max_corner.overload1 max_corner]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.box.max_corner.overload1 more...]]``

  Point & ``[link boost_geometry.reference.box.max_corner.overload2 max_corner]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.box.max_corner.overload2 more...]]``


[section:overload1 box::max_corner (1 of 2 overloads)]



  Point const & max_corner() const;



[endsect]



[section:overload2 box::max_corner (2 of 2 overloads)]



  Point & max_corner();



[endsect]


[endsect]

[section:min_corner box::min_corner]

[indexterm2 min_corner..box] 

  Point const & ``[link boost_geometry.reference.box.min_corner.overload1 min_corner]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.box.min_corner.overload1 more...]]``

  Point & ``[link boost_geometry.reference.box.min_corner.overload2 min_corner]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.box.min_corner.overload2 more...]]``


[section:overload1 box::min_corner (1 of 2 overloads)]



  Point const & min_corner() const;



[endsect]



[section:overload2 box::min_corner (2 of 2 overloads)]



  Point & min_corner();



[endsect]


[endsect]


[endsect]


[section:box_2d box_2d]

[indexterm1 box_2d] 

  typedef box< point_2d > box_2d;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.box.box [*box]]]
    [

     Constructor taking the minimum corner point and the maximum corner point. ]
  ]
  
  [
    [[link boost_geometry.reference.box.max_corner [*max_corner]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.box.min_corner [*min_corner]]]
    []
  ]
  
]

[heading Typedef Description]
    
Box is always described by a `min_corner()` and a `max_corner()` [link boost_geometry.reference.point `point`]. If another rectangle is used, use [link boost_geometry.reference.linear_ring `linear_ring`] or [link boost_geometry.reference.polygon `polygon`]. 

[heading Remarks]
      
Boxes are for selections and for calculating the envelope of geometries. Not all algorithms are implemented for [link boost_geometry.reference.box `box`]. Boxes are also used in Spatial Indexes. 



[variablelist
  
[[Point][[link boost_geometry.reference.point `point`] type. The [link boost_geometry.reference.box `box`] takes a [link boost_geometry.reference.point `point`] type as template parameter. The [link boost_geometry.reference.point `point`] type can be any [link boost_geometry.reference.point `point`] type. It can be 2D but can also be 3D or more dimensional. The [link boost_geometry.reference.box `box`] can also take a latlong [link boost_geometry.reference.point `point`] type as template parameter. ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:box_3d box_3d]

[indexterm1 box_3d] 

  typedef box< point_3d > box_3d;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.box.box [*box]]]
    [

     Constructor taking the minimum corner point and the maximum corner point. ]
  ]
  
  [
    [[link boost_geometry.reference.box.max_corner [*max_corner]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.box.min_corner [*min_corner]]]
    []
  ]
  
]

[heading Typedef Description]
    
Box is always described by a `min_corner()` and a `max_corner()` [link boost_geometry.reference.point `point`]. If another rectangle is used, use [link boost_geometry.reference.linear_ring `linear_ring`] or [link boost_geometry.reference.polygon `polygon`]. 

[heading Remarks]
      
Boxes are for selections and for calculating the envelope of geometries. Not all algorithms are implemented for [link boost_geometry.reference.box `box`]. Boxes are also used in Spatial Indexes. 



[variablelist
  
[[Point][[link boost_geometry.reference.point `point`] type. The [link boost_geometry.reference.box `box`] takes a [link boost_geometry.reference.point `point`] type as template parameter. The [link boost_geometry.reference.point `point`] type can be any [link boost_geometry.reference.point `point`] type. It can be 2D but can also be 3D or more dimensional. The [link boost_geometry.reference.box `box`] can also take a latlong [link boost_geometry.reference.point `point`] type as template parameter. ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:box_tag box_tag]


Convenience 2D or 3D [link boost_geometry.reference.box `box`] (mbr) identifying [link boost_geometry.reference.tag `tag`]. 




[heading Synopsis]
  struct box_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:buffer buffer]

[indexterm1 buffer] 
Calculate buffer (= new [link boost_geometry.reference.boost__geometry `boost::geometry`]) around specified distance of [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Input ,
      typename Output ,
      typename T >
  void buffer(
      Input const & geometry_in,
      Output & geometry_out,
      T const & distance,
      T const & chord_length = -1);



[heading Parameters]
    

[variablelist
  
[[geometry_in][input [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[distance][the distance used in buffer ]]

[[chord_length][length of the chord's in the generated arcs around points or bends ]]

[[geometry_out][buffered [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Remarks]
      
Currently only implemented for [link boost_geometry.reference.box `box`], the trivial case, but still useful 


[heading Use case:]
  
BOX + distance -> BOX: it is allowed that "geometry\_out" the same object as "geometry\_in" 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/buffer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:cartesian_distance cartesian_distance]


Encapsulate the results of distance calculation. 




[heading Synopsis]
  template<
      typename T  = double>
  struct cartesian_distance

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.cartesian_distance.cartesian_distance [*cartesian_distance]]]
    [Constructor with a value. ]
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_cast_type [*operator cast_type]]]
    [Automatic conversion to double or higher precision, taking squareroot if necessary. ]
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_lt_ [*operator<]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_eq__eq_ [*operator==]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_gt_ [*operator>]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.squared_value [*squared_value]]]
    [The "squared\_value" method returns the internal squared value. ]
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.very_small [*very_small]]]
    []
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.cartesian_distance.operator_lt__lt_ [*operator<<]]]
    [Make streamable to enable std::cout << geometry::distance( ). ]
  ]
  
]


[heading Description]

Distance calculation for xy points or xyz points is done by taking the square root. However, for distance comparison drawing the square root is not necessary. Therefore the distance strategies are allowed to return the squares of the distance. This structure contains the distance, and a boolean to indicate if it is squared. It has an automatic conversion to a double value, which does the square root if necessary. 

[heading Remarks]
      
Thanks to Phil Endecott for his suggestion to change the pair to the double-convertable http://article.gmane.org/gmane.comp.lib.boost.devel/172709/match=greatcircle\_distance 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:cartesian_distance cartesian_distance::cartesian_distance]

[indexterm2 cartesian_distance..cartesian_distance] 
Constructor with a value. 


  cartesian_distance(
      T const & v);



[endsect]



[section:operator_cast_type cartesian_distance::operator cast_type]

[indexterm2 operator cast_type..cartesian_distance] 
Automatic conversion to double or higher precision, taking squareroot if necessary. 


  operator cast_type() const;



[endsect]



[section:operator_lt_ cartesian_distance::operator<]

[indexterm2 operator<..cartesian_distance] 

  bool operator<(
      cartesian_distance< T > const & other) const;



[endsect]



[section:operator_lt__lt_ cartesian_distance::operator<<]

[indexterm2 operator<<..cartesian_distance] 
Make streamable to enable std::cout << `geometry::distance( )`. 


  template<
      typename Char ,
      typename Traits >
  friend std::basic_ostream< Char, Traits > & operator<<(
      std::basic_ostream< Char, Traits > & os,
      cartesian_distance< T > const & d);


[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:operator_eq__eq_ cartesian_distance::operator==]

[indexterm2 operator==..cartesian_distance] 

  bool operator==(
      cartesian_distance< T > const & other) const;



[endsect]



[section:operator_gt_ cartesian_distance::operator>]

[indexterm2 operator>..cartesian_distance] 

  bool operator>(
      cartesian_distance< T > const & other) const;



[endsect]



[section:squared_value cartesian_distance::squared_value]

[indexterm2 squared_value..cartesian_distance] 
The "squared\_value" method returns the internal squared value. 


  T squared_value() const;



[endsect]



[section:very_small cartesian_distance::very_small]

[indexterm2 very_small..cartesian_distance] 

  bool very_small() const;



[endsect]



[endsect]

[section:cartesian_tag cartesian_tag]


Tag indicating Cartesian coordinate system family (cartesian,epsg). 




[heading Synopsis]
  struct cartesian_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:centroid centroid]

[indexterm1 centroid] 
      
  template<
      typename Geometry ,
      typename Point ,
      typename Strategy >
  void ``[link boost_geometry.reference.centroid.overload1 centroid]``(
      Geometry const & geometry,
      Point & c,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.centroid.overload1 more...]]``

  template<
      typename Geometry ,
      typename Point >
  void ``[link boost_geometry.reference.centroid.overload2 centroid]``(
      Geometry const & geometry,
      Point & c);
  ``  [''''&raquo;''' [link boost_geometry.reference.centroid.overload2 more...]]``


[heading Source descriptions:]
  

* OGC description: The mathematical centroid for this Surface as a Point. The result is not guaranteed to be on this Surface.

* From Wikipedia: Informally, it is the "average" of all points 






[heading Remarks]
      
Polygon should be closed, and can be orientated either way 

The "centroid" functions are taking a non const reference to the centroid. The "make\_centroid" functions return the centroid, the type has to be specified. 

Both of them have an overloaded version where a centroid calculation strategy can be specified 


[heading Exceptions]
    

[variablelist
  
[[centroid_exception][if calculation is not successful, e.g. because polygon didn't contain points]]

]


[heading Example:]
  
Example showing centroid calculation  






[heading Performance]
  
2776 * 1000 centroid calculations are done in 0.16 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Centroid1)


[heading Geometries:]
  

* RING: 


* BOX: the centroid of a 2D or 3D box is the center of the box

* POLYGON 


* POINT: the point is the centroid

* LINESTRING: the average of the centers of its segments

* MULTIPOINT: the average of the points 





[heading Requirements]

[*Header: ][^boost/geometry/algorithms/centroid.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 centroid (1 of 2 overloads)]


Calculate centroid using a specified [link boost_geometry.reference.strategy `strategy`]. 


  template<
      typename Geometry ,
      typename Point ,
      typename Strategy >
  void centroid(
      Geometry const & geometry,
      Point & c,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to calculate centroid from ]]

[[c][reference to [link boost_geometry.reference.point `point`] which will contain the centroid ]]

[[strategy][Calculation [link boost_geometry.reference.strategy `strategy`] for centroid ]]

]




[endsect]



[section:overload2 centroid (2 of 2 overloads)]


Calculate centroid. 


  template<
      typename Geometry ,
      typename Point >
  void centroid(
      Geometry const & geometry,
      Point & c);



[heading Parameters]
    

[variablelist
  
[[geometry][a [link boost_geometry.reference.boost__geometry `boost::geometry`] (e.g. closed ring or [link boost_geometry.reference.polygon `polygon`]) ]]

[[c][reference to [link boost_geometry.reference.point `point`] which will contain the centroid ]]

]




[endsect]


[endsect]

[section:centroid_exception centroid_exception]





[heading Synopsis]
  class centroid_exception :    public exception

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.centroid_exception.centroid_exception [*centroid_exception]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.centroid_exception.what [*what]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/centroid.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:centroid_exception centroid_exception::centroid_exception]

[indexterm2 centroid_exception..centroid_exception] 

  centroid_exception();



[endsect]



[section:what centroid_exception::what]

[indexterm2 what..centroid_exception] 

  char const * what() const;



[endsect]



[endsect]

[section:circular_iterator circular_iterator]


Iterator which goes circular through a range, `starting` at a [link boost_geometry.reference.point `point`], ending at that [link boost_geometry.reference.point `point`]. 




[heading Synopsis]
  template<
      typename Iterator >
  struct circular_iterator

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.circular_iterator.circular_iterator [*circular_iterator]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.circular_iterator.moveto [*moveto]]]
    [Navigate to a certain position, should be in \[start .. end\], it at end it will circle again. ]
  ]
  
]


[heading Description]



[variablelist
  
[[Iterator][iterator on which this class is based on ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/iterators/circular_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]

[section:circular_iterator circular_iterator::circular_iterator]

[indexterm2 circular_iterator..circular_iterator] 

  explicit ``[link boost_geometry.reference.circular_iterator.circular_iterator.overload1 circular_iterator]``(
      Iterator begin,
      Iterator end,
      Iterator start);
  ``  [''''&raquo;''' [link boost_geometry.reference.circular_iterator.circular_iterator.overload1 more...]]``

  explicit ``[link boost_geometry.reference.circular_iterator.circular_iterator.overload2 circular_iterator]``(
      Iterator end);
  ``  [''''&raquo;''' [link boost_geometry.reference.circular_iterator.circular_iterator.overload2 more...]]``


[section:overload1 circular_iterator::circular_iterator (1 of 2 overloads)]



  circular_iterator(
      Iterator begin,
      Iterator end,
      Iterator start);



[endsect]



[section:overload2 circular_iterator::circular_iterator (2 of 2 overloads)]



  circular_iterator(
      Iterator end);



[endsect]


[endsect]


[section:moveto circular_iterator::moveto]

[indexterm2 moveto..circular_iterator] 
Navigate to a certain position, should be in \[start .. end\], it at end it will circle again. 


  void moveto(
      Iterator it);



[endsect]



[endsect]


[section:clear clear]

[indexterm1 clear] 
Clears a [link boost_geometry.reference.linestring `linestring`], linear ring or [link boost_geometry.reference.polygon `polygon`] (exterior+interiors) or multi*. 


  template<
      typename Geometry >
  void clear(
      Geometry & geometry);


Generic function to clear a [link boost_geometry.reference.boost__geometry `boost::geometry`]



[heading Remarks]
      
points and boxes cannot be cleared, instead they can be set to zero by "assign\_zero" 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/clear.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:close_to_zero close_to_zero]

[indexterm1 close_to_zero] 
Utility function to check if a distance is very small. 


  template<
      typename T >
  bool close_to_zero(
      T const & value);


Depending on the "distance result" type it checks if it is smaller than epsilon, or (for Cartesian distances) if the square is smaller than epsilon 

[variablelist
  
[[R][the distance result type, either arithmetic or cartesian distance ]]

]


[heading Parameters]
    

[variablelist
  
[[value][the distance result to check ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:combine combine]

[indexterm1 combine] 
Combines a [link boost_geometry.reference.box `box`] with another [link boost_geometry.reference.boost__geometry `boost::geometry`] ([link boost_geometry.reference.box `box`], [link boost_geometry.reference.point `point`]). 


  template<
      typename Box ,
      typename Geometry >
  void combine(
      Box & box,
      Geometry const & geometry);




[variablelist
  
[[Box][type of the [link boost_geometry.reference.box `box`] ]]

[[Geometry][of second [link boost_geometry.reference.boost__geometry `boost::geometry`], to be combined with the [link boost_geometry.reference.box `box`] ]]

]


[heading Parameters]
    

[variablelist
  
[[box][[link boost_geometry.reference.box `box`] to combine another [link boost_geometry.reference.boost__geometry `boost::geometry`] with, might be changed ]]

[[geometry][other [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/combine.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:concept__AreaStrategy concept::AreaStrategy]


Checks [link boost_geometry.reference.strategy `strategy`] for area. 




[heading Synopsis]
  template<
      typename Strategy >
  class AreaStrategy

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/concepts/area_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Box concept::Box]


[link boost_geometry.reference.concept__Box `concept::Box`] [link boost_geometry.reference.concept `concept`]. 




[heading Synopsis]
  template<
      typename Geometry >
  class Box

[heading Description]


[heading Formal definition:]
  
The [link boost_geometry.reference.box `box`] [link boost_geometry.reference.concept `concept`] is defined as following:
* there must be a specialization of traits::tag defining box_tag as type

* there must be a specialization of traits::point_type to define the underlying point type (even if it does not consist of points, it should define this type, to indicate the points it can work with)

* there must be a specialization of traits::indexed_access, per index (min_corner, max_corner) and per dimension, with two functions:get to get a coordinate valueset to set a coordinate value (this one is not checked for ConstBox) 






[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/box_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__CentroidStrategy concept::CentroidStrategy]


Checks [link boost_geometry.reference.strategy `strategy`] for centroid. 




[heading Synopsis]
  template<
      typename Strategy >
  class CentroidStrategy

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/concepts/centroid_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstBox concept::ConstBox]


[link boost_geometry.reference.concept__Box `concept::Box`] [link boost_geometry.reference.concept `concept`] (const version). 




[heading Synopsis]
  template<
      typename Geometry >
  class ConstBox

[heading Description]

The [link boost_geometry.reference.concept__ConstBox `concept::ConstBox`] [link boost_geometry.reference.concept `concept`] apply the same as the [link boost_geometry.reference.concept__Box `concept::Box`] [link boost_geometry.reference.concept `concept`], but does not apply write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/box_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstLinestring concept::ConstLinestring]


[link boost_geometry.reference.concept__Linestring `concept::Linestring`] [link boost_geometry.reference.concept `concept`] (const version). 




[heading Synopsis]
  template<
      typename Geometry >
  class ConstLinestring

[heading Description]

The [link boost_geometry.reference.concept__ConstLinestring `concept::ConstLinestring`] [link boost_geometry.reference.concept `concept`] check the same as the [link boost_geometry.reference.concept__Linestring `concept::Linestring`] [link boost_geometry.reference.concept `concept`], but does not check write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/linestring_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstPoint concept::ConstPoint]


[link boost_geometry.reference.point `point`] [link boost_geometry.reference.concept `concept`] (const version). 




[heading Synopsis]
  template<
      typename Geometry >
  class ConstPoint

[heading Description]

The [link boost_geometry.reference.concept__ConstPoint `concept::ConstPoint`] [link boost_geometry.reference.concept `concept`] apply the same as the [link boost_geometry.reference.concept__Point `concept::Point`] [link boost_geometry.reference.concept `concept`], but does not apply write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/point_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstPolygon concept::ConstPolygon]


[link boost_geometry.reference.concept__Polygon `concept::Polygon`] [link boost_geometry.reference.concept `concept`] (const version). 




[heading Synopsis]
  template<
      typename Geometry >
  class ConstPolygon

[heading Description]

The [link boost_geometry.reference.concept__ConstPolygon `concept::ConstPolygon`] [link boost_geometry.reference.concept `concept`] check the same as the [link boost_geometry.reference.concept__Polygon `concept::Polygon`] [link boost_geometry.reference.concept `concept`], but does not check write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/polygon_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstRing concept::ConstRing]


(linear) ring [link boost_geometry.reference.concept `concept`] (const version) 




[heading Synopsis]
  template<
      typename Geometry >
  class ConstRing

[heading Description]

The ConstLinearRing [link boost_geometry.reference.concept `concept`] check the same as the Geometry [link boost_geometry.reference.concept `concept`], but does not check write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/ring_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstSegment concept::ConstSegment]


[link boost_geometry.reference.concept__Segment `concept::Segment`] [link boost_geometry.reference.concept `concept`] (const version). 




[heading Synopsis]
  template<
      typename Geometry >
  class ConstSegment

[heading Description]

The [link boost_geometry.reference.concept__ConstSegment `concept::ConstSegment`] [link boost_geometry.reference.concept `concept`] verifies the same as the [link boost_geometry.reference.concept__Segment `concept::Segment`] [link boost_geometry.reference.concept `concept`], but does not verify write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/segment_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConvexHullStrategy concept::ConvexHullStrategy]


Checks [link boost_geometry.reference.strategy `strategy`] for convex\_hull. 




[heading Synopsis]
  template<
      typename Strategy >
  class ConvexHullStrategy

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/concepts/convex_hull_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Linestring concept::Linestring]


[link boost_geometry.reference.concept__Linestring `concept::Linestring`] [link boost_geometry.reference.concept `concept`]. 




[heading Synopsis]
  template<
      typename Geometry >
  class Linestring

[heading Description]


[heading Formal definition:]
  
The [link boost_geometry.reference.linestring `linestring`] [link boost_geometry.reference.concept `concept`] is defined as following:
* there must be a specialization of traits::tag defining linestring_tag as type

* it must behave like a Boost.Range

* either it can behave like the std library, having push_back and clear

* or it can implement a mechanism for clearing and adding points:there can be a specialization of traits::use_std class indicating that it does not use the standard library (for modifications)there should then be a specialization of traits::clear to make a linestring emptythere should then be a specialization of traits::append_point to add a point to a linestring






[heading Remarks]
      
to fulfil the concepts, no [link boost_geometry.reference.traits `traits`] class has to be specialized to define the [link boost_geometry.reference.point `point`] type. The [link boost_geometry.reference.point `point`] type is taken using boost::range\_value<X>::type


[heading Example:]
  


A custom [link boost_geometry.reference.linestring `linestring`], defining the necessary specializations to fulfil to the [link boost_geometry.reference.concept `concept`].

Suppose that the following [link boost_geometry.reference.linestring `linestring`] is defined:  





It can then be adapted to the [link boost_geometry.reference.concept `concept`] as following:  







[heading Remarks]
      

* There is also the registration macro BOOST_GEOMETRY_REGISTER_LINESTRING

* For registration of std::vector<P> (and deque, and list) it is enough to include the header-file geometries/adapted/std_as_linestring.hpp. That registers a vector as a linestring (so it cannot be registered as a linear ring then, in the same source code). 





[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/linestring_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Point concept::Point]


[link boost_geometry.reference.concept__Point `concept::Point`] [link boost_geometry.reference.concept `concept`]. 




[heading Synopsis]
  template<
      typename Geometry >
  class Point

[heading Description]


[heading Formal definition:]
  
The [link boost_geometry.reference.point `point`] [link boost_geometry.reference.concept `concept`] is defined as following:
* there must be a specialization of traits::tag defining point_tag as type

* there must be a specialization of traits::coordinate_type defining the type of its coordinates

* there must be a specialization of traits::coordinate_system defining its coordinate system (cartesian, spherical, etc)

* there must be a specialization of traits::dimension defining its number of dimensions (2, 3, ...) (derive it conveniently from boost::mpl::int_<X> for X-D)

* there must be a specialization of traits::access, per dimension, with two functions:get to get a coordinate valueset to set a coordinate value (this one is not checked for ConstPoint)





[heading Example:]
  


A legacy [link boost_geometry.reference.point `point`], defining the necessary specializations to fulfil to the [link boost_geometry.reference.concept `concept`].

Suppose that the following [link boost_geometry.reference.point `point`] is defined:  





It can then be adapted to the [link boost_geometry.reference.concept `concept`] as following:  





Note that it is done like above to show the system. Users will normally use the registration macro.


[heading Example:]
  


A read-only legacy [link boost_geometry.reference.point `point`], using a macro to fulfil to the [link boost_geometry.reference.concept__ConstPoint `concept::ConstPoint`] [link boost_geometry.reference.concept `concept`]. It cannot be modified by the library but can be used in all algorithms where points are not modified.

The [link boost_geometry.reference.point `point`] looks like the following:

 





It uses the macro as following:  





[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/point_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__PointDistanceStrategy concept::PointDistanceStrategy]


Checks [link boost_geometry.reference.strategy `strategy`] for point-segment-distance. 




[heading Synopsis]
  template<
      typename Strategy >
  struct PointDistanceStrategy

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/concepts/distance_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__PointSegmentDistanceStrategy concept::PointSegmentDistanceStrategy]


Checks [link boost_geometry.reference.strategy `strategy`] for point-segment-distance. 




[heading Synopsis]
  template<
      typename Strategy >
  struct PointSegmentDistanceStrategy

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/concepts/distance_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Polygon concept::Polygon]


[link boost_geometry.reference.concept__Polygon `concept::Polygon`] [link boost_geometry.reference.concept `concept`]. 




[heading Synopsis]
  template<
      typename Geometry >
  class Polygon

[heading Description]


[heading Formal definition:]
  
The [link boost_geometry.reference.polygon `polygon`] [link boost_geometry.reference.concept `concept`] is defined as following:
* there must be a specialization of traits::tag defining polygon_tag as type

* there must be a specialization of traits::ring_type defining the type of its exterior ring and interior rings as type

* there must be a specialization of traits::interior_type defining the type of the collection of its interior rings as type

* there must be a specialization of traits::exterior_ring with two functions named "get", returning the exterior ring, a const version and a mutable version

* there must be a specialization of traits::interior_rings with two functions named "get", returning the interior rings, a const version and a mutable version





[heading Remarks]
      
to fulfil the concepts, no [link boost_geometry.reference.traits `traits`] class has to be specialized to define the [link boost_geometry.reference.point `point`] type. The [link boost_geometry.reference.point `point`] type is automatically defined as typename range\_value<typename `ring_type<P>::type`>type 



[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/polygon_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Ring concept::Ring]


ring [link boost_geometry.reference.concept `concept`] 




[heading Synopsis]
  template<
      typename Geometry >
  class Ring

[heading Description]


[heading Formal definition:]
  
The ring [link boost_geometry.reference.concept `concept`] is defined as following:
* there must be a specialization of traits::tag defining ring_tag as type

* it must behave like a Boost.Range

* there can optionally be a specialization of traits::point_order defining the order or orientation of its points, clockwise or counterclockwise.

* either it can behave like the std library, having pushback

* or it can implement a mechanism for clearing and adding points. This is the same as the for the concept Linestring, and described there.





[heading Remarks]
      
to fulfil the concepts, no [link boost_geometry.reference.traits `traits`] class has to be specialized to define the [link boost_geometry.reference.point `point`] type. The [link boost_geometry.reference.point `point`] type is taken using boost::range\_value<X>::type 



[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/ring_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Segment concept::Segment]


[link boost_geometry.reference.concept__Segment `concept::Segment`] [link boost_geometry.reference.concept `concept`]. 




[heading Synopsis]
  template<
      typename Geometry >
  class Segment

[heading Description]

Formal definition: The [link boost_geometry.reference.segment `segment`] [link boost_geometry.reference.concept `concept`] is defined as following:
* there must be a specialization of traits::tag defining segment_tag as type

* there must be a specialization of traits::point_type to define the underlying point type (even if it does not consist of points, it should define this type, to indicate the points it can work with)

* there must be a specialization of traits::indexed_access, per index and per dimension, with two functions:get to get a coordinate valueset to set a coordinate value (this one is not checked for ConstSegment)






[heading Remarks]
      
The [link boost_geometry.reference.segment `segment`] [link boost_geometry.reference.concept `concept`] is similar to the [link boost_geometry.reference.box `box`] [link boost_geometry.reference.concept `concept`], defining another [link boost_geometry.reference.tag `tag`]. However, the [link boost_geometry.reference.box `box`] [link boost_geometry.reference.concept `concept`] assumes the index as min\_corner, max\_corner, while for the [link boost_geometry.reference.segment `segment`] [link boost_geometry.reference.concept `concept`] there is no assumption. 



[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/segment_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__SegmentIntersectStrategy concept::SegmentIntersectStrategy]


Checks [link boost_geometry.reference.strategy `strategy`] for [link boost_geometry.reference.segment `segment`] intersection. 




[heading Synopsis]
  template<
      typename Strategy >
  class SegmentIntersectStrategy

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/concepts/segment_intersect_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__SimplifyStrategy concept::SimplifyStrategy]


Checks [link boost_geometry.reference.strategy `strategy`] for simplify. 




[heading Synopsis]
  template<
      typename Strategy >
  struct SimplifyStrategy

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/concepts/simplify_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__WithinStrategy concept::WithinStrategy]


Checks [link boost_geometry.reference.strategy `strategy`] for within (point-in-polygon). 




[heading Synopsis]
  template<
      typename Strategy >
  class WithinStrategy

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/concepts/within_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:concept__check concept::check]

[indexterm1 concept::check] 
Checks, in compile-time, the [link boost_geometry.reference.concept `concept`] of any [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry >
  void check();


[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/check.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:concept__check_concepts_and_equal_dimensions concept::check_concepts_and_equal_dimensions]

[indexterm1 concept::check_concepts_and_equal_dimensions] 
Checks, in compile-time, the [link boost_geometry.reference.concept `concept`] of two geometries, and if they have equal dimensions. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  void check_concepts_and_equal_dimensions();


[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/check.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:convert convert]

[indexterm1 convert] 
Converts one [link boost_geometry.reference.boost__geometry `boost::geometry`] to another [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  void convert(
      Geometry1 const & geometry1,
      Geometry2 & geometry2);


The convert algorithm converts one [link boost_geometry.reference.boost__geometry `boost::geometry`], e.g. a BOX, to another [link boost_geometry.reference.boost__geometry `boost::geometry`], e.g. a RING. This only if it is possible and applicable.



[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] (source) ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] (target) ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/convert.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:convex_hull convex_hull]

[indexterm1 convex_hull] 
      
  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  void ``[link boost_geometry.reference.convex_hull.overload1 convex_hull]``(
      Geometry1 const & geometry,
      Geometry2 & out,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.convex_hull.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 >
  void ``[link boost_geometry.reference.convex_hull.overload2 convex_hull]``(
      Geometry1 const & geometry,
      Geometry2 & out);
  ``  [''''&raquo;''' [link boost_geometry.reference.convex_hull.overload2 more...]]``


[heading Source descriptions:]
  

* OGC description: Returns a geometric object that represents the convex hull of this geometric object. Convex hulls, being dependent on straight lines, can be accurately represented in linear interpolations for any geometry restricted to linear interpolations. 





[heading Performance]
  
2776 counties of US are "hulled" in 0.9 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Convexhull1)



[heading Remarks]
      
The convex hull is always a ring, holes are not possible. Therefore it is can also be used in combination with an output iterator.


[heading Geometries supported:]
  
In the images below the convex hull is painted in red.


* point: will not compile




* linestring: 




* polygon: will deliver a polygon without holes 





* multi_point: 





* multi_linestring: 




* multi_polygon: 




[heading Output geometries supported:]
  



* polygon 




* ring 




* inserter version (with output iterator) can output to any array supporting points of same type as the input geometry type 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/convex_hull.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 convex_hull (1 of 2 overloads)]



  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  void convex_hull(
      Geometry1 const & geometry,
      Geometry2 & out,
      Strategy const & strategy);



[endsect]



[section:overload2 convex_hull (2 of 2 overloads)]


Calculate the convex hull of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  void convex_hull(
      Geometry1 const & geometry,
      Geometry2 & out);




[variablelist
  
[[Geometry1][the input [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2:][the output [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to calculate convex hull from ]]

[[out][a [link boost_geometry.reference.boost__geometry `boost::geometry`] receiving points of the convex hull ]]

]




[endsect]


[endsect]

[section:convex_hull_inserter convex_hull_inserter]

[indexterm1 convex_hull_inserter] 
    
  template<
      typename Geometry ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator ``[link boost_geometry.reference.convex_hull_inserter.overload1 convex_hull_inserter]``(
      Geometry const & geometry,
      OutputIterator out,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.convex_hull_inserter.overload1 more...]]``

  template<
      typename Geometry ,
      typename OutputIterator >
  OutputIterator ``[link boost_geometry.reference.convex_hull_inserter.overload2 convex_hull_inserter]``(
      Geometry const & geometry,
      OutputIterator out);
  ``  [''''&raquo;''' [link boost_geometry.reference.convex_hull_inserter.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/convex_hull.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 convex_hull_inserter (1 of 2 overloads)]



  template<
      typename Geometry ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator convex_hull_inserter(
      Geometry const & geometry,
      OutputIterator out,
      Strategy const & strategy);



[endsect]



[section:overload2 convex_hull_inserter (2 of 2 overloads)]


Calculate the convex hull of a [link boost_geometry.reference.boost__geometry `boost::geometry`], output-iterator version. 


  template<
      typename Geometry ,
      typename OutputIterator >
  OutputIterator convex_hull_inserter(
      Geometry const & geometry,
      OutputIterator out);




[variablelist
  
[[Geometry][the input [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[OutputIterator:][an output-iterator ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to calculate convex hull from ]]

[[out][an output iterator outputing points of the convex hull ]]

]



[heading Remarks]
      
This overloaded version outputs to an output iterator. In this case, nothing is known about its point-type or about its clockwise order. Therefore, the input point-type and order are copied 




[endsect]


[endsect]

[section:coordinate_system coordinate_system]


Meta-function which defines coordinate system for any [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename G >
  struct coordinate_system

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.coordinate_system.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.coordinate_system.type [*type]]]
    []
  
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_system.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:ncg coordinate_system::ncg]

[indexterm2 ncg..coordinate_system] 

  typedef boost::remove_const< G >::type ncg;



[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_system.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:type coordinate_system::type]

[indexterm2 type..coordinate_system] 

  typedef core_dispatch::coordinate_system< typename tag< G >::type, ncg >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their [link boost_geometry.reference.boost__geometry `boost::geometry`] type ([link boost_geometry.reference.point `point`], [link boost_geometry.reference.linestring `linestring`], [link boost_geometry.reference.polygon `polygon`], etc) by implementing a [link boost_geometry.reference.tag `tag`] [link boost_geometry.reference.traits `traits`] class. This meta-function uses that [link boost_geometry.reference.traits `traits`] class to retrieve the [link boost_geometry.reference.tag `tag`]. If the input type is not a [link boost_geometry.reference.boost__geometry `boost::geometry`] at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_system.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:coordinate_type coordinate_type]


Meta-function which defines coordinate type (int, float, double, etc) of any [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.G G]``>
  struct coordinate_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.coordinate_type.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.coordinate_type.type [*type]]]
    []
  
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:ncg coordinate_type::ncg]

[indexterm2 ncg..coordinate_type] 

  typedef boost::remove_const< G >::type ncg;



[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:type coordinate_type::type]

[indexterm2 type..coordinate_type] 

  typedef core_dispatch::coordinate_type< typename tag< G >::type, ncg >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their [link boost_geometry.reference.boost__geometry `boost::geometry`] type ([link boost_geometry.reference.point `point`], [link boost_geometry.reference.linestring `linestring`], [link boost_geometry.reference.polygon `polygon`], etc) by implementing a [link boost_geometry.reference.tag `tag`] [link boost_geometry.reference.traits `traits`] class. This meta-function uses that [link boost_geometry.reference.traits `traits`] class to retrieve the [link boost_geometry.reference.tag `tag`]. If the input type is not a [link boost_geometry.reference.boost__geometry `boost::geometry`] at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]


[section:copy_coordinates copy_coordinates]

[indexterm1 copy_coordinates] 
Copies coordinates from source to destination [link boost_geometry.reference.point `point`]. 


  template<
      typename Src ,
      typename Dst >
  void copy_coordinates(
      Src const & source,
      Dst & dest);


The function copy\_coordinates copies coordinates from one [link boost_geometry.reference.point `point`] to another [link boost_geometry.reference.point `point`]. Source [link boost_geometry.reference.point `point`] and destination [link boost_geometry.reference.point `point`] might be of different types. 
[heading Parameters]
    

[variablelist
  
[[source][Source [link boost_geometry.reference.point `point`] ]]

[[dest][Destination [link boost_geometry.reference.point `point`] ]]

]



[heading Remarks]
      
If destination type differs from source type, they must have the same coordinate count 



[heading Requirements]

[*Header: ][^boost/geometry/util/copy.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:copy_segment_point copy_segment_point]

[indexterm1 copy_segment_point] 
Helper function, copies a [link boost_geometry.reference.point `point`] from a [link boost_geometry.reference.segment `segment`]. 

    
  template<
      typename Geometry ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool ``[link boost_geometry.reference.copy_segment_point.overload1 copy_segment_point]``(
      Geometry const & geometry,
      SegmentIdentifier const & seg_id,
      bool second,
      PointOut & point_out);
  ``  [''''&raquo;''' [link boost_geometry.reference.copy_segment_point.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool ``[link boost_geometry.reference.copy_segment_point.overload2 copy_segment_point]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      SegmentIdentifier const & seg_id,
      bool second,
      PointOut & point_out);
  ``  [''''&raquo;''' [link boost_geometry.reference.copy_segment_point.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/copy_segment_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 copy_segment_point (1 of 2 overloads)]


Helper function, copies a [link boost_geometry.reference.point `point`] from a [link boost_geometry.reference.segment `segment`]. 


  template<
      typename Geometry ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool copy_segment_point(
      Geometry const & geometry,
      SegmentIdentifier const & seg_id,
      bool second,
      PointOut & point_out);



[endsect]



[section:overload2 copy_segment_point (2 of 2 overloads)]


Helper function, to avoid the same construct several times, copies a [link boost_geometry.reference.point `point`], based on a source-index and two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool copy_segment_point(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      SegmentIdentifier const & seg_id,
      bool second,
      PointOut & point_out);



[endsect]


[endsect]


[section:copy_segment_points copy_segment_points]

[indexterm1 copy_segment_points] 
Helper function, to avoid the same construct several times, copies a [link boost_geometry.reference.point `point`], based on a source-index and two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool copy_segment_points(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      SegmentIdentifier const & seg_id,
      PointOut & point1,
      PointOut & point2);


[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/copy_segment_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:copy_segments copy_segments]

[indexterm1 copy_segments] 
Traverses through intersection points / geometries. 


  template<
      typename Geometry ,
      typename SegmentIdentifier ,
      typename RangeOut >
  void copy_segments(
      Geometry const & geometry,
      SegmentIdentifier const & seg_id,
      int to_index,
      RangeOut & range_out);


[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/copy_segments.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:correct correct]

[indexterm1 correct] 

  template<
      typename Geometry >
  void correct(
      Geometry & geometry);


[heading Requirements]

[*Header: ][^boost/geometry/algorithms/correct.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:cross_product cross_product]

[indexterm1 cross_product] 
Computes the cross product of two vector. 


  template<
      typename P1 ,
      typename P2 >
  P1 cross_product(
      P1 const & p1,
      P2 const & p2);


Both vectors shall be of the same type. This type also determines type of result vector.


[heading Parameters]
    

[variablelist
  
[[p1][first vector ]]

[[p2][second vector ]]

]



[heading Return Value]
      
the cross product vector 



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/cross_product.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:cs__cartesian cs::cartesian]


Cartesian coordinate system. 




[heading Synopsis]
  struct cartesian

[heading Description]

Defines the Cartesian or rectangular coordinate system where points are defined in 2 or 3 (or more) dimensions and usually (but not always) known as x,y,z 


[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:cs__geographic cs::geographic]


Geographic coordinate system, in [link boost_geometry.reference.degree `degree`] or in [link boost_geometry.reference.radian `radian`]. 




[heading Synopsis]
  template<
      typename DegreeOrRadian >
  struct geographic

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.cs__geographic.units [*units]]]
    []
  
  ]

]


[heading Description]

Defines the [link boost_geometry.reference.cs__geographic `cs::geographic`] coordinate system where points are defined in two angles and usually known as lat,long or lo,la or phi,lambda 


[heading Remarks]
      
might be moved to extensions/gis/geographic 



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:units cs::geographic::units]

[indexterm2 units..cs::geographic] 

  typedef DegreeOrRadian units;



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:cs__polar cs::polar]


Polar coordinate system. 




[heading Synopsis]
  template<
      typename DegreeOrRadian >
  struct polar

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.cs__polar.units [*units]]]
    []
  
  ]

]


[heading Description]

Defines the [link boost_geometry.reference.cs__polar `cs::polar`] coordinate system "in which each point
        on a plane is determined by an angle and a distance" 


[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:units cs::polar::units]

[indexterm2 units..cs::polar] 

  typedef DegreeOrRadian units;



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:cs__spherical cs::spherical]


Spherical coordinate system, in [link boost_geometry.reference.degree `degree`] or in [link boost_geometry.reference.radian `radian`]. 




[heading Synopsis]
  template<
      typename DegreeOrRadian >
  struct spherical

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.cs__spherical.units [*units]]]
    []
  
  ]

]


[heading Description]

Defines the [link boost_geometry.reference.cs__spherical `cs::spherical`] coordinate system where points are defined in two angles and an optional radius usually known as r, theta, phi 
[heading Coordinates:]
  

* coordinate 0: 0 <= phi < 2pi is the angle between the positive x-axis and the line from the origin to the P projected onto the xy-plane.

* coordinate 1: 0 <= theta <= pi is the angle between the positive z-axis and the line formed between the origin and P.

* coordinate 2 (if specified): r >= 0 is the distance from the origin to a given point P.






[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:units cs::spherical::units]

[indexterm2 units..cs::spherical] 

  typedef DegreeOrRadian units;



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:cs_tag cs_tag]


Meta-function returning coordinate system [link boost_geometry.reference.tag `tag`] ([link boost_geometry.reference.cs `cs`] family) of any [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.G G]``>
  struct cs_tag

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.cs_tag.type [*type]]]
    []
  
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type cs_tag::type]

[indexterm2 type..cs_tag] 

  typedef traits::cs_tag< typename geometry::coordinate_system< G >::type >::type type;


[heading Typedef Description]
    


[variablelist
  
[[CoordinateSystem][coordinate system ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:de9im de9im]


Dimensionally Extended 9 Intersection Matrix. 




[heading Synopsis]
  struct de9im

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.de9im.as_char [*as_char]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im.contains [*contains]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im.crosses [*crosses]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im.de9im [*de9im]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im.disjoint [*disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im.equals [*equals]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im.intersects [*intersects]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im.overlaps [*overlaps]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im.touches [*touches]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im.within [*within]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.de9im.bb [*bb]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im.be [*be]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im.bi [*bi]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im.eb [*eb]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im.ee [*ee]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im.ei [*ei]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im.ib [*ib]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im.ie [*ie]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im.ii [*ii]]]
    []
  ]

]


[heading Description]




[heading Requirements]

[*Header: ][^boost/geometry/strategies/intersection_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:as_char de9im::as_char]

[indexterm2 as_char..de9im] 

  static char as_char(
      int v);



[endsect]



[section:bb de9im::bb]

[indexterm2 bb..de9im] 

  int bb;



[endsect]



[section:be de9im::be]

[indexterm2 be..de9im] 

  int be;



[endsect]



[section:bi de9im::bi]

[indexterm2 bi..de9im] 

  int bi;



[endsect]



[section:contains de9im::contains]

[indexterm2 contains..de9im] 

  bool contains() const;



[endsect]



[section:crosses de9im::crosses]

[indexterm2 crosses..de9im] 

  bool crosses() const;



[endsect]


[section:de9im de9im::de9im]

[indexterm2 de9im..de9im] 

  ``[link boost_geometry.reference.de9im.de9im.overload1 de9im]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.de9im.de9im.overload1 more...]]``

  ``[link boost_geometry.reference.de9im.de9im.overload2 de9im]``(
      int ii0,
      int ib0,
      int ie0,
      int bi0,
      int bb0,
      int be0,
      int ei0,
      int eb0,
      int ee0);
  ``  [''''&raquo;''' [link boost_geometry.reference.de9im.de9im.overload2 more...]]``


[section:overload1 de9im::de9im (1 of 2 overloads)]



  de9im();



[endsect]



[section:overload2 de9im::de9im (2 of 2 overloads)]



  de9im(
      int ii0,
      int ib0,
      int ie0,
      int bi0,
      int bb0,
      int be0,
      int ei0,
      int eb0,
      int ee0);



[endsect]


[endsect]


[section:disjoint de9im::disjoint]

[indexterm2 disjoint..de9im] 

  bool disjoint() const;



[endsect]



[section:eb de9im::eb]

[indexterm2 eb..de9im] 

  int eb;



[endsect]



[section:ee de9im::ee]

[indexterm2 ee..de9im] 

  int ee;



[endsect]



[section:ei de9im::ei]

[indexterm2 ei..de9im] 

  int ei;



[endsect]



[section:equals de9im::equals]

[indexterm2 equals..de9im] 

  bool equals() const;



[endsect]



[section:ib de9im::ib]

[indexterm2 ib..de9im] 

  int ib;



[endsect]



[section:ie de9im::ie]

[indexterm2 ie..de9im] 

  int ie;



[endsect]



[section:ii de9im::ii]

[indexterm2 ii..de9im] 

  int ii;



[endsect]



[section:intersects de9im::intersects]

[indexterm2 intersects..de9im] 

  bool intersects() const;



[endsect]



[section:overlaps de9im::overlaps]

[indexterm2 overlaps..de9im] 

  bool overlaps() const;



[endsect]



[section:touches de9im::touches]

[indexterm2 touches..de9im] 

  bool touches() const;



[endsect]



[section:within de9im::within]

[indexterm2 within..de9im] 

  bool within() const;



[endsect]



[endsect]

[section:de9im_segment de9im_segment]





[heading Synopsis]
  struct de9im_segment :    public de9im

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.de9im_segment.as_char [*as_char]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.contains [*contains]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.crosses [*crosses]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.de9im_segment [*de9im_segment]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.disjoint [*disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.equals [*equals]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.intersects [*intersects]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.overlaps [*overlaps]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.touches [*touches]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.within [*within]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.de9im_segment.bb [*bb]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.be [*be]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.bi [*bi]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.collinear [*collinear]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.degenerate [*degenerate]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.eb [*eb]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ee [*ee]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ei [*ei]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ib [*ib]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ie [*ie]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ii [*ii]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.opposite [*opposite]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.parallel [*parallel]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ra [*ra]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.rb [*rb]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/intersection_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:as_char de9im_segment::as_char]


['Inherited from de9im.]

[indexterm2 as_char..de9im_segment] 

  static char as_char(
      int v);



[endsect]



[section:bb de9im_segment::bb]


['Inherited from de9im.]

[indexterm2 bb..de9im_segment] 

  int bb;



[endsect]



[section:be de9im_segment::be]


['Inherited from de9im.]

[indexterm2 be..de9im_segment] 

  int be;



[endsect]



[section:bi de9im_segment::bi]


['Inherited from de9im.]

[indexterm2 bi..de9im_segment] 

  int bi;



[endsect]



[section:collinear de9im_segment::collinear]

[indexterm2 collinear..de9im_segment] 

  bool collinear;



[endsect]



[section:contains de9im_segment::contains]


['Inherited from de9im.]

[indexterm2 contains..de9im_segment] 

  bool contains() const;



[endsect]



[section:crosses de9im_segment::crosses]


['Inherited from de9im.]

[indexterm2 crosses..de9im_segment] 

  bool crosses() const;



[endsect]


[section:de9im_segment de9im_segment::de9im_segment]

[indexterm2 de9im_segment..de9im_segment] 

  ``[link boost_geometry.reference.de9im_segment.de9im_segment.overload1 de9im_segment]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.de9im_segment.de9im_segment.overload1 more...]]``

  ``[link boost_geometry.reference.de9im_segment.de9im_segment.overload2 de9im_segment]``(
      double a,
      double b,
      int ii0,
      int ib0,
      int ie0,
      int bi0,
      int bb0,
      int be0,
      int ei0,
      int eb0,
      int ee0,
      bool c = false,
      bool o = false,
      bool p = false,
      bool d = false);
  ``  [''''&raquo;''' [link boost_geometry.reference.de9im_segment.de9im_segment.overload2 more...]]``


[section:overload1 de9im_segment::de9im_segment (1 of 2 overloads)]



  de9im_segment();



[endsect]



[section:overload2 de9im_segment::de9im_segment (2 of 2 overloads)]



  de9im_segment(
      double a,
      double b,
      int ii0,
      int ib0,
      int ie0,
      int bi0,
      int bb0,
      int be0,
      int ei0,
      int eb0,
      int ee0,
      bool c = false,
      bool o = false,
      bool p = false,
      bool d = false);



[endsect]


[endsect]


[section:degenerate de9im_segment::degenerate]

[indexterm2 degenerate..de9im_segment] 

  bool degenerate;



[endsect]



[section:disjoint de9im_segment::disjoint]


['Inherited from de9im.]

[indexterm2 disjoint..de9im_segment] 

  bool disjoint() const;



[endsect]



[section:eb de9im_segment::eb]


['Inherited from de9im.]

[indexterm2 eb..de9im_segment] 

  int eb;



[endsect]



[section:ee de9im_segment::ee]


['Inherited from de9im.]

[indexterm2 ee..de9im_segment] 

  int ee;



[endsect]



[section:ei de9im_segment::ei]


['Inherited from de9im.]

[indexterm2 ei..de9im_segment] 

  int ei;



[endsect]



[section:equals de9im_segment::equals]


['Inherited from de9im.]

[indexterm2 equals..de9im_segment] 

  bool equals() const;



[endsect]



[section:ib de9im_segment::ib]


['Inherited from de9im.]

[indexterm2 ib..de9im_segment] 

  int ib;



[endsect]



[section:ie de9im_segment::ie]


['Inherited from de9im.]

[indexterm2 ie..de9im_segment] 

  int ie;



[endsect]



[section:ii de9im_segment::ii]


['Inherited from de9im.]

[indexterm2 ii..de9im_segment] 

  int ii;



[endsect]



[section:intersects de9im_segment::intersects]


['Inherited from de9im.]

[indexterm2 intersects..de9im_segment] 

  bool intersects() const;



[endsect]



[section:opposite de9im_segment::opposite]

[indexterm2 opposite..de9im_segment] 

  bool opposite;



[endsect]



[section:overlaps de9im_segment::overlaps]


['Inherited from de9im.]

[indexterm2 overlaps..de9im_segment] 

  bool overlaps() const;



[endsect]



[section:parallel de9im_segment::parallel]

[indexterm2 parallel..de9im_segment] 

  bool parallel;



[endsect]



[section:ra de9im_segment::ra]

[indexterm2 ra..de9im_segment] 

  double ra;



[endsect]



[section:rb de9im_segment::rb]

[indexterm2 rb..de9im_segment] 

  double rb;



[endsect]



[section:touches de9im_segment::touches]


['Inherited from de9im.]

[indexterm2 touches..de9im_segment] 

  bool touches() const;



[endsect]



[section:within de9im_segment::within]


['Inherited from de9im.]

[indexterm2 within..de9im_segment] 

  bool within() const;



[endsect]



[endsect]

[section:degree degree]


Unit of plane angle: Degrees. 




[heading Synopsis]
  class degree

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:difference difference]

[indexterm1 difference] 

  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Collection >
  void difference(
      Geometry1 const & geometry1,
      Geometry2 geometry2,
      Collection & output_collection);




[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to make difference ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/difference.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:dimension dimension]


Meta-function which defines coordinate dimensions, i.e. the number of axes of any [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename G >
  struct dimension

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:disjoint disjoint]

[indexterm1 disjoint] 
Calculate if two geometries are disjoint. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool disjoint(
      const Geometry1 & geometry1,
      const Geometry2 & geometry2);




[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
true if disjoint, else false 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/disjoint.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:dissolve dissolve]

[indexterm1 dissolve] 
Removes self intersections from a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry ,
      typename OutputIterator >
  OutputIterator dissolve(
      Geometry const & geometry,
      OutputIterator output);




[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[OutputIterator][type of intersection container (e.g. vector of "intersection/turn point"'s) ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[output][container which will contain intersection points ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/dissolve.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:distance distance]

[indexterm1 distance] 
      
  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  Strategy::return_type ``[link boost_geometry.reference.distance.overload1 distance]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.distance.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 >
  distance_result< Geometry1, Geometry2 >::type ``[link boost_geometry.reference.distance.overload2 distance]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);
  ``  [''''&raquo;''' [link boost_geometry.reference.distance.overload2 more...]]``

The distance algorithm returns the distance between two geometries. 
[heading Coordinate systems and strategies:]
  
With help of strategies the distance function returns the appropriate distance. If the input is in cartesian coordinates, the Euclidian distance (Pythagoras) is calculated. If the input is in spherical coordinates (either degree or radian), the distance over the sphere is returned. If the input is in geographic coordinates, distance is calculated over the globe and returned in meters.


[heading Distance result:]
  
Depending on calculation type the distance result is either a structure, convertable to a double, or a double value. In case of Pythagoras it makes sense to not draw the square root in the strategy itself. Taking a square root is relative expensive and is not necessary when comparing distances.


[heading Geometries:]
  
Currently implemented, for both cartesian and spherical/geographic:
* POINT - POINT

* POINT - SEGMENT and v.v.

* POINT - LINESTRING and v.v.



Not yet implemented:
* POINT - RING etc, note that it will return a zero if the point is anywhere within the ring




[heading Example:]
  
Example showing distance calculation of two points, in xy and in latlong coordinates  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/distance.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 distance (1 of 2 overloads)]


Calculate distance between two geometries with a specified [link boost_geometry.reference.strategy `strategy`]. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  Strategy::return_type distance(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);




[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[S][point-point-distance [link boost_geometry.reference.strategy `strategy`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[strategy][[link boost_geometry.reference.strategy `strategy`] to calculate distance between two points ]]

]



[heading Return Value]
      
the distance (either a double or a [link boost_geometry.reference.distance_result `distance_result`], (convertable to double)) 



[heading Remarks]
      
The [link boost_geometry.reference.strategy `strategy`] can be a point-point [link boost_geometry.reference.strategy `strategy`]. In case of distance point-line/point-polygon it may also be a point-segment [link boost_geometry.reference.strategy `strategy`]. 


[heading Example:]
  
Example showing distance calculation of two lat long points, using the accurate Vincenty approximation  








[endsect]



[section:overload2 distance (2 of 2 overloads)]


Calculate distance between two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  distance_result< Geometry1, Geometry2 >::type distance(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);


The default [link boost_geometry.reference.strategy `strategy`] is used, belonging to the corresponding coordinate system of the geometries 

[variablelist
  
[[G1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[G2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
the distance (either a double or a distance result, convertable to double) 




[endsect]


[endsect]

[section:distance_result distance_result]


Shortcut to define return type of distance [link boost_geometry.reference.strategy `strategy`]. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.Geometry1 Geometry1]``,
      typename ``[link boost_geometry.reference.Geometry2 Geometry2]`` = Geometry1>
  struct distance_result

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.distance_result.point_type1 [*point_type1]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.distance_result.point_type2 [*point_type2]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.distance_result.strategy_type [*strategy_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.distance_result.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:point_type1 distance_result::point_type1]

[indexterm2 point_type1..distance_result] 

  typedef point_type< Geometry1 >::type point_type1;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_type.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:point_type2 distance_result::point_type2]

[indexterm2 point_type2..distance_result] 

  typedef point_type< Geometry2 >::type point_type2;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_type.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:strategy_type distance_result::strategy_type]

[indexterm2 strategy_type..distance_result] 

  typedef strategy_distance< typename cs_tag< point_type1 >::type, typename cs_tag< point_type2 >::type, point_type1, point_type2 >::type strategy_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_distance.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    


[variablelist
  
[[T1][[link boost_geometry.reference.tag `tag`] of coordinate system of first [link boost_geometry.reference.point `point`] type ]]

[[T2][[link boost_geometry.reference.tag `tag`] of coordinate system of second [link boost_geometry.reference.point `point`] type ]]

[[P1][first point-type ]]

[[P2][second point-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:type distance_result::type]

[indexterm2 type..distance_result] 

  typedef strategy_type::return_type type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]


[section:divide_point divide_point]

[indexterm1 divide_point] 
Divides a [link boost_geometry.reference.point `point`] by another. 


  template<
      typename Point1 ,
      typename Point2 >
  void divide_point(
      Point1 & p1,
      Point2 const & p2);


The coordinates of the second [link boost_geometry.reference.point `point`] will be divided by those of the first [link boost_geometry.reference.point `point`]. The second [link boost_geometry.reference.point `point`] is not modified. 
[heading Parameters]
    

[variablelist
  
[[p1][first [link boost_geometry.reference.point `point`] ]]

[[p2][second [link boost_geometry.reference.point `point`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:divide_value divide_value]

[indexterm1 divide_value] 
Divides each coordinate of a [link boost_geometry.reference.point `point`] by a value. 


  template<
      typename Point >
  void divide_value(
      Point & p,
      typename detail::param< Point >::type value);



[heading Parameters]
    

[variablelist
  
[[p][[link boost_geometry.reference.point `point`] ]]

[[value][value to divide by ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:dot_product dot_product]

[indexterm1 dot_product] 
Computes the dot product (or scalar product) of 2 vectors (points). 


  template<
      typename P1 ,
      typename P2 >
  select_coordinate_type< P1, P2 >::type dot_product(
      P1 const & p1,
      P2 const & p2);



[heading Parameters]
    

[variablelist
  
[[p1][first [link boost_geometry.reference.point `point`] ]]

[[p2][second [link boost_geometry.reference.point `point`] ]]

]



[heading Return Value]
      
the dot product 



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/dot_product.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:dsv dsv]

[indexterm1 dsv] 
Main DSV-streaming function. 


  template<
      typename Geometry >
  detail::dsv::dsv_manipulator< Geometry > dsv(
      Geometry const & geometry,
      std::string const & coordinate_separator = ", ",
      std::string const & point_open = "(",
      std::string const & point_close = ")",
      std::string const & point_separator = ", ",
      std::string const & list_open = "(",
      std::string const & list_close = ")",
      std::string const & list_separator = ", ");


DSV stands for Delimiter Separated Values. Geometries can be streamed as DSV. There are defaults for all separators. 

[heading Remarks]
      
Useful for examples and testing purposes 

With this function GeoJSON objects can be created, using the right delimiters 



[heading Requirements]

[*Header: ][^boost/geometry/util/write_dsv.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:enrich_intersection_points enrich_intersection_points]

[indexterm1 enrich_intersection_points] 
All intersection points are enriched with successor information. 


  template<
      typename TurnPoints ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  void enrich_intersection_points(
      TurnPoints & turn_points,
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);




[variablelist
  
[[TurnPoints][type of intersection container (e.g. vector of "intersection/turn point"'s) ]]

]


[heading Parameters]
    

[variablelist
  
[[turn_points][container containing intersectionpoints ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/enrich_intersection_points.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:envelope envelope]

[indexterm1 envelope] 
Calculate envelope of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry ,
      typename Box >
  void envelope(
      Geometry const & geometry,
      Box & mbr);



[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[mbr][the [link boost_geometry.reference.box `box`] receiving the envelope ]]

]


[heading Example:]
  
Example showing envelope calculation, using point\_ll latlong points  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/envelope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:equals equals]

[indexterm1 equals] 
Detect if two geometries are spatially equal. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool equals(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);




[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
true if geometries are spatially equal, else false 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/equals.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:ever_circling_iterator ever_circling_iterator]


Iterator which ever circles through a range. 




[heading Synopsis]
  template<
      typename Iterator >
  struct ever_circling_iterator

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.ever_circling_iterator.ever_circling_iterator [*ever_circling_iterator]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.ever_circling_iterator.moveto [*moveto]]]
    [Navigate to a certain position, should be in \[start .. end\], it at end it will circle again. ]
  ]
  
]


[heading Description]



[variablelist
  
[[Iterator][iterator on which this class is based on]]

]

If the iterator arrives at range.end() it restarts from the beginning. So it has to be stopped in another way. Don't call for(....; it++) because it will turn in an endless loop 

[heading Remarks]
      
Name inspired on David Bowie's "Chant Of The Ever Circling Skeletal Family" 



[heading Requirements]

[*Header: ][^boost/geometry/iterators/ever_circling_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]

[section:ever_circling_iterator ever_circling_iterator::ever_circling_iterator]

[indexterm2 ever_circling_iterator..ever_circling_iterator] 

  explicit ``[link boost_geometry.reference.ever_circling_iterator.ever_circling_iterator.overload1 ever_circling_iterator]``(
      Iterator begin,
      Iterator end,
      bool skip_first = false);
  ``  [''''&raquo;''' [link boost_geometry.reference.ever_circling_iterator.ever_circling_iterator.overload1 more...]]``

  explicit ``[link boost_geometry.reference.ever_circling_iterator.ever_circling_iterator.overload2 ever_circling_iterator]``(
      Iterator begin,
      Iterator end,
      Iterator start,
      bool skip_first = false);
  ``  [''''&raquo;''' [link boost_geometry.reference.ever_circling_iterator.ever_circling_iterator.overload2 more...]]``


[section:overload1 ever_circling_iterator::ever_circling_iterator (1 of 2 overloads)]



  ever_circling_iterator(
      Iterator begin,
      Iterator end,
      bool skip_first = false);



[endsect]



[section:overload2 ever_circling_iterator::ever_circling_iterator (2 of 2 overloads)]



  ever_circling_iterator(
      Iterator begin,
      Iterator end,
      Iterator start,
      bool skip_first = false);



[endsect]


[endsect]


[section:moveto ever_circling_iterator::moveto]

[indexterm2 moveto..ever_circling_iterator] 
Navigate to a certain position, should be in \[start .. end\], it at end it will circle again. 


  void moveto(
      Iterator it);



[endsect]



[endsect]

[section:exception exception]


Base [link boost_geometry.reference.exception `exception`] class for GGL. 




[heading Synopsis]
  struct exception

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/exception.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:exterior_ring exterior_ring]

[indexterm1 exterior_ring] 
Function to get the exterior\_ring ring of a [link boost_geometry.reference.polygon `polygon`]. 

    
  template<
      typename Polygon >
  ring_type< Polygon >::type & ``[link boost_geometry.reference.exterior_ring.overload1 exterior_ring]``(
      Polygon & polygon);
  ``  [''''&raquo;''' [link boost_geometry.reference.exterior_ring.overload1 more...]]``

  template<
      typename Polygon >
  const ring_type< Polygon >::type & ``[link boost_geometry.reference.exterior_ring.overload2 exterior_ring]``(
      Polygon const & polygon);
  ``  [''''&raquo;''' [link boost_geometry.reference.exterior_ring.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/core/exterior_ring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 exterior_ring (1 of 2 overloads)]


Function to get the exterior\_ring ring of a [link boost_geometry.reference.polygon `polygon`]. 


  template<
      typename Polygon >
  ring_type< Polygon >::type & exterior_ring(
      Polygon & polygon);




[heading Remarks]
      
OGC compliance: instead of ExteriorRing 



[variablelist
  
[[P][[link boost_geometry.reference.polygon `polygon`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[polygon][the [link boost_geometry.reference.polygon `polygon`] to get the exterior ring from ]]

]



[heading Return Value]
      
a reference to the exterior ring 




[endsect]



[section:overload2 exterior_ring (2 of 2 overloads)]


Function to get the exterior ring of a [link boost_geometry.reference.polygon `polygon`] (const version). 


  template<
      typename Polygon >
  const ring_type< Polygon >::type & exterior_ring(
      Polygon const & polygon);




[heading Remarks]
      
OGC compliance: instead of ExteriorRing 



[variablelist
  
[[Polygon][[link boost_geometry.reference.polygon `polygon`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[polygon][the [link boost_geometry.reference.polygon `polygon`] to get the exterior ring from ]]

]



[heading Return Value]
      
a const reference to the exterior ring 




[endsect]


[endsect]


[section:for_each_coordinate for_each_coordinate]

[indexterm1 for_each_coordinate] 

  template<
      typename Point ,
      typename Op >
  void for_each_coordinate(
      Point & point,
      Op operation);


[heading Requirements]

[*Header: ][^boost/geometry/util/for_each_coordinate.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:for_each_point for_each_point]

[indexterm1 for_each_point] 
Calls functor for [link boost_geometry.reference.boost__geometry `boost::geometry`]. 

    
  template<
      typename Geometry ,
      typename Functor >
  Functor ``[link boost_geometry.reference.for_each_point.overload1 for_each_point]``(
      Geometry const & geometry,
      Functor f);
  ``  [''''&raquo;''' [link boost_geometry.reference.for_each_point.overload1 more...]]``

  template<
      typename Geometry ,
      typename Functor >
  Functor ``[link boost_geometry.reference.for_each_point.overload2 for_each_point]``(
      Geometry & geometry,
      Functor f);
  ``  [''''&raquo;''' [link boost_geometry.reference.for_each_point.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/for_each.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 for_each_point (1 of 2 overloads)]


Calls functor for [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry ,
      typename Functor >
  Functor for_each_point(
      Geometry const & geometry,
      Functor f);



[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to loop through ]]

[[f][functor to use]]

]

Calls the functor the specified const [link boost_geometry.reference.boost__geometry `boost::geometry`] 


[endsect]



[section:overload2 for_each_point (2 of 2 overloads)]


Calls functor for [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry ,
      typename Functor >
  Functor for_each_point(
      Geometry & geometry,
      Functor f);



[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to loop through ]]

[[f][functor to use]]

]

Calls the functor for the specified [link boost_geometry.reference.boost__geometry `boost::geometry`] 


[endsect]


[endsect]


[section:for_each_range for_each_range]

[indexterm1 for_each_range] 

  template<
      typename Geometry ,
      typename Actor >
  void for_each_range(
      Geometry const & geometry,
      Actor & actor);


[heading Requirements]

[*Header: ][^boost/geometry/util/for_each_range.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:for_each_segment for_each_segment]

[indexterm1 for_each_segment] 
Calls functor for segments on linestrings, rings, polygons, ... 

    
  template<
      typename Geometry ,
      typename Functor >
  Functor ``[link boost_geometry.reference.for_each_segment.overload1 for_each_segment]``(
      Geometry const & geometry,
      Functor f);
  ``  [''''&raquo;''' [link boost_geometry.reference.for_each_segment.overload1 more...]]``

  template<
      typename Geometry ,
      typename Functor >
  Functor ``[link boost_geometry.reference.for_each_segment.overload2 for_each_segment]``(
      Geometry & geometry,
      Functor f);
  ``  [''''&raquo;''' [link boost_geometry.reference.for_each_segment.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/for_each.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 for_each_segment (1 of 2 overloads)]


Calls functor for segments on linestrings, rings, polygons, ... 


  template<
      typename Geometry ,
      typename Functor >
  Functor for_each_segment(
      Geometry const & geometry,
      Functor f);



[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to loop through ]]

[[f][functor to use]]

]

Calls the functor all const segments of the specified const [link boost_geometry.reference.boost__geometry `boost::geometry`] 


[endsect]



[section:overload2 for_each_segment (2 of 2 overloads)]


Calls functor for segments on linestrings, rings, polygons, ... 


  template<
      typename Geometry ,
      typename Functor >
  Functor for_each_segment(
      Geometry & geometry,
      Functor f);



[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to loop through ]]

[[f][functor to use]]

]

Calls the functor all segments of the specified [link boost_geometry.reference.boost__geometry `boost::geometry`] 


[endsect]


[endsect]


[section:fuzzy_equals fuzzy_equals]

[indexterm1 fuzzy_equals] 

  template<
      typename T >
  bool fuzzy_equals(
      T const & left,
      T const & right);


[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:geographic_tag geographic_tag]


Tag indicating Geographic coordinate system family (geographic). 




[heading Synopsis]
  struct geographic_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:geometry_id geometry_id]


Meta-function the id for a [link boost_geometry.reference.boost__geometry `boost::geometry`] type. 




[heading Synopsis]
  template<
      typename Geometry >
  struct geometry_id

[heading Description]



[heading Remarks]
      
Used for e.g. reverse meta-function 



[heading Requirements]

[*Header: ][^boost/geometry/core/geometry_id.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:geometry_not_recognized_tag geometry_not_recognized_tag]


"default" [link boost_geometry.reference.tag `tag`] 




[heading Synopsis]
  struct geometry_not_recognized_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:get get]

[indexterm1 get] 
get coordinate value of a Point ( / Sphere) 

    
  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type ``[link boost_geometry.reference.get.overload1 get]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.get.overload1 more...]]``

  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type ``[link boost_geometry.reference.get.overload2 get]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.get.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 get (1 of 2 overloads)]


get coordinate value of a Point ( / Sphere) 


  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type get(
      Geometry const & geometry);




[variablelist
  
[[Dimension][[link boost_geometry.reference.dimension `dimension`] ]]

[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to query coordinate value from ]]

]



[heading Return Value]
      
coordinate value 




[endsect]



[section:overload2 get (2 of 2 overloads)]


get coordinate value of a Box / Segment 


  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type get(
      Geometry const & geometry);




[variablelist
  
[[Index][for Point: do not specifyfor Box: min\_corner or max\_cornerfor Segment: 0 / 1 
]]

[[Dimension][[link boost_geometry.reference.dimension `dimension`] ]]

[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to query coordinate value from ]]

]



[heading Return Value]
      
coordinate value 




[endsect]


[endsect]


[section:get_as_radian get_as_radian]

[indexterm1 get_as_radian] 
get coordinate value of a [link boost_geometry.reference.point `point`], result is in Radian 


  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type get_as_radian(
      const Geometry & geometry);


Result is in Radian, even if source coordinate system is in Degrees 

[heading Return Value]
      
coordinate value



[variablelist
  
[[Dimension][[link boost_geometry.reference.dimension `dimension`] ]]

[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to get coordinate value from ]]

]



[heading Remarks]
      
Only applicable to coordinate systems templatized by units, e.g. spherical or geographic coordinate systems 



[heading Requirements]

[*Header: ][^boost/geometry/core/radian_access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:get_section get_section]

[indexterm1 get_section] 
Get iterators for a specified [link boost_geometry.reference.section `section`]. 


  template<
      typename Geometry ,
      typename Section >
  void get_section(
      Geometry const & geometry,
      Section const & section,
      typename boost::range_const_iterator< typename geometry::range_type< Geometry >::type >::type & begin,
      typename boost::range_const_iterator< typename geometry::range_type< Geometry >::type >::type & end);




[variablelist
  
[[Geometry][type ]]

[[Section][type of [link boost_geometry.reference.section `section`] to get from ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] which might be located in the neighborhood ]]

[[section][structure with [link boost_geometry.reference.section `section`] ]]

[[begin][begin-iterator (const iterator over points of [link boost_geometry.reference.section `section`]) ]]

[[end][end-iterator (const iterator over points of [link boost_geometry.reference.section `section`]) ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/get_section.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:get_turns get_turns]

[indexterm1 get_turns] 
Calculate intersection points of two geometries. 

    
  template<
      typename AssignPolicy ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename Turns ,
      typename InterruptPolicy >
  void ``[link boost_geometry.reference.get_turns.overload1 get_turns]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Turns & turns,
      InterruptPolicy & interrupt_policy);
  ``  [''''&raquo;''' [link boost_geometry.reference.get_turns.overload1 more...]]``

  template<
      typename AssignPolicy ,
      typename Geometry ,
      typename Turns ,
      typename InterruptPolicy >
  void ``[link boost_geometry.reference.get_turns.overload2 get_turns]``(
      Geometry const & geometry,
      Turns & turns,
      InterruptPolicy & interrupt_policy);
  ``  [''''&raquo;''' [link boost_geometry.reference.get_turns.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/get_turns.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 get_turns (1 of 2 overloads)]


Calculate intersection points of two geometries. 


  template<
      typename AssignPolicy ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename Turns ,
      typename InterruptPolicy >
  void get_turns(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Turns & turns,
      InterruptPolicy & interrupt_policy);




[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Turns][type of turn-container (e.g. vector of "intersection/turn point"'s) ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[turns][container which will contain intersection points ]]

]




[endsect]



[section:overload2 get_turns (2 of 2 overloads)]


Calculate self intersections of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename AssignPolicy ,
      typename Geometry ,
      typename Turns ,
      typename InterruptPolicy >
  void get_turns(
      Geometry const & geometry,
      Turns & turns,
      InterruptPolicy & interrupt_policy);




[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Turns][type of intersection container (e.g. vector of "intersection/turn point"'s) ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[turns][container which will contain intersection points ]]

]




[endsect]


[endsect]

[section:interior_rings interior_rings]

[indexterm1 interior_rings] 
Function to get the interior rings of a [link boost_geometry.reference.polygon `polygon`] (non const version). 

    
  template<
      typename Polygon >
  interior_type< Polygon >::type & ``[link boost_geometry.reference.interior_rings.overload1 interior_rings]``(
      Polygon & polygon);
  ``  [''''&raquo;''' [link boost_geometry.reference.interior_rings.overload1 more...]]``

  template<
      typename Polygon >
  const interior_type< Polygon >::type & ``[link boost_geometry.reference.interior_rings.overload2 interior_rings]``(
      Polygon const & polygon);
  ``  [''''&raquo;''' [link boost_geometry.reference.interior_rings.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 interior_rings (1 of 2 overloads)]


Function to get the interior rings of a [link boost_geometry.reference.polygon `polygon`] (non const version). 


  template<
      typename Polygon >
  interior_type< Polygon >::type & interior_rings(
      Polygon & polygon);




[heading Remarks]
      
OGC compliance: instead of InteriorRingN 



[variablelist
  
[[P][[link boost_geometry.reference.polygon `polygon`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[polygon][the [link boost_geometry.reference.polygon `polygon`] to get the interior rings from ]]

]



[heading Return Value]
      
a reference to the interior rings 




[endsect]



[section:overload2 interior_rings (2 of 2 overloads)]


Function to get the interior rings of a [link boost_geometry.reference.polygon `polygon`] (const version). 


  template<
      typename Polygon >
  const interior_type< Polygon >::type & interior_rings(
      Polygon const & polygon);




[heading Remarks]
      
OGC compliance: instead of InteriorRingN 



[variablelist
  
[[P][[link boost_geometry.reference.polygon `polygon`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[polygon][the [link boost_geometry.reference.polygon `polygon`] to get the interior rings from ]]

]



[heading Return Value]
      
a const reference to the interior rings 




[endsect]


[endsect]

[section:interior_type interior_type]


Meta-function defining container type of inner rings of (multi)[link boost_geometry.reference.polygon `polygon`] geometriy. 




[heading Synopsis]
  template<
      typename Geometry >
  struct interior_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.interior_type.type [*type]]]
    []
  
  ]

]


[heading Description]

the interior rings should be organized as a container (std::vector, std::deque, boost::array) with `boost` range support. This meta function defines the type of that container. 

[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type interior_type::type]

[indexterm2 type..interior_type] 

  typedef core_dispatch::interior_type< typename tag< Geometry >::type, Geometry >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their [link boost_geometry.reference.boost__geometry `boost::geometry`] type ([link boost_geometry.reference.point `point`], [link boost_geometry.reference.linestring `linestring`], [link boost_geometry.reference.polygon `polygon`], etc) by implementing a [link boost_geometry.reference.tag `tag`] [link boost_geometry.reference.traits `traits`] class. This meta-function uses that [link boost_geometry.reference.traits `traits`] class to retrieve the [link boost_geometry.reference.tag `tag`]. If the input type is not a [link boost_geometry.reference.boost__geometry `boost::geometry`] at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]


[section:intersection intersection]

[indexterm1 intersection] 
Intersects two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Collection >
  void intersection(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Collection & output_collection);


The two input geometries are intersected and the resulting linestring(s), ring(s) or polygon(s) are added to the specified collection. 

[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Collection][collection of rings, polygons (e.g. a vector<polygon> or a multi\_polygon) ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[output_collection][the collection ]]

]



[heading Return Value]
      
true if successful 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/intersection.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:intersection_inserter intersection_inserter]

[indexterm1 intersection_inserter] 
Intersects two geometries. 

    
  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator ``[link boost_geometry.reference.intersection_inserter.overload1 intersection_inserter]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.intersection_inserter.overload1 more...]]``

  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator >
  OutputIterator ``[link boost_geometry.reference.intersection_inserter.overload2 intersection_inserter]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out);
  ``  [''''&raquo;''' [link boost_geometry.reference.intersection_inserter.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/intersection.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 intersection_inserter (1 of 2 overloads)]


Intersects two geometries. 


  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator intersection_inserter(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out,
      Strategy const & strategy);


The two input geometries are intersected and the resulting linestring(s), ring(s) or polygon(s) are sent to the specified output operator. 

[variablelist
  
[[GeometryOut][output [link boost_geometry.reference.boost__geometry `boost::geometry`] type, must be specified ]]

[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[OutputIterator][output iterator ]]

[[Strategy][compound [link boost_geometry.reference.strategy `strategy`] for intersection ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[out][the output iterator, outputting linestrings or polygons ]]

[[strategy][the [link boost_geometry.reference.strategy `strategy`] ]]

]



[heading Return Value]
      
the output iterator 




[endsect]



[section:overload2 intersection_inserter (2 of 2 overloads)]


Intersects two geometries. 


  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator >
  OutputIterator intersection_inserter(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out);


The two input geometries are intersected and the resulting linestring(s), ring(s) or polygon(s) are sent to the specified output operator. 

[variablelist
  
[[GeometryOut][output [link boost_geometry.reference.boost__geometry `boost::geometry`] type, must be specified ]]

[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[OutputIterator][output iterator ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[out][the output iterator, outputting linestrings or polygons ]]

]



[heading Return Value]
      
the output iterator 




[endsect]


[endsect]

[section:intersects intersects]

[indexterm1 intersects] 
      
  template<
      typename Geometry >
  bool ``[link boost_geometry.reference.intersects.overload1 intersects]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.intersects.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool ``[link boost_geometry.reference.intersects.overload2 intersects]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);
  ``  [''''&raquo;''' [link boost_geometry.reference.intersects.overload2 more...]]``


[heading Source descriptions:]
  

* OGC description: Returns 1 (TRUE) if this geometric object spatially intersects anotherGeometry.

* OGC: a.Intersects(b) <=> ! a.Disjoint(b) 





[heading Remarks]
      
There are two overloaded versions:
* with one geometry, detecting self-intersections

* with two geometries, deferring to disjoint, returning !disjoint




[heading Geometries:]
  

* ring 

* polygon 

* for two geometries: same is disjoint





[heading Remarks]
      
if one geometry is completely within another geometry, it "intersects" 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/intersects.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 intersects (1 of 2 overloads)]


Determine if there is at least one intersection (crossing or self-tangency). 


  template<
      typename Geometry >
  bool intersects(
      Geometry const & geometry);




[heading Remarks]
      
This function can be called for one [link boost_geometry.reference.boost__geometry `boost::geometry`] (self-intersection) and also for two geometries (intersection)



[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
true if there are intersections, else false 




[endsect]



[section:overload2 intersects (2 of 2 overloads)]


Determine if there is at least one intersection. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool intersects(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);




[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
true if there are intersection(s), else false 




[endsect]


[endsect]

[section:is_linear is_linear]


Meta-function defining "true" for linear types ([link boost_geometry.reference.linestring `linestring`],ring), "false" for non-linear typse. 




[heading Synopsis]
  template<
      typename Geometry >
  struct is_linear

[heading Description]



[heading Remarks]
      
Used for [link boost_geometry.reference.tag `tag`] dispatching and meta-function finetuning 



[heading Requirements]

[*Header: ][^boost/geometry/core/is_linear.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:is_multi is_multi]


Meta-function defining "true" for multi geometries (multi\_point, etc). 




[heading Synopsis]
  template<
      typename Geometry >
  struct is_multi

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/is_multi.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:is_radian is_radian]


Meta-function to verify if a coordinate system is [link boost_geometry.reference.radian `radian`]. 




[heading Synopsis]
  template<
      typename CoordinateSystem >
  struct is_radian

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:length length]

[indexterm1 length] 
      
  template<
      typename Geometry >
  length_result< Geometry >::type ``[link boost_geometry.reference.length.overload1 length]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.length.overload1 more...]]``

  template<
      typename Geometry ,
      typename Strategy >
  length_result< Geometry >::type ``[link boost_geometry.reference.length.overload2 length]``(
      Geometry const & geometry,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.length.overload2 more...]]``

The length algorithm is implemented for the linestring and the multi\_linestring geometry and results in the length of the linestring. If the points of a linestring have coordinates expressed in kilometers, the length of the line is expressed in kilometers as well. 
[heading Example:]
  
Example showing length calculation  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/length.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 length (1 of 2 overloads)]


Calculate length of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry >
  length_result< Geometry >::type length(
      Geometry const & geometry);


The function length returns the length of a [link boost_geometry.reference.boost__geometry `boost::geometry`], using the default distance-calculation-strategy 
[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`], being a [link boost_geometry.reference.linestring `linestring`], vector, iterator pair, or any other `boost` compatible range ]]

]



[heading Return Value]
      
the length Example showing length calculation on a vector  








[endsect]



[section:overload2 length (2 of 2 overloads)]


Calculate length of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry ,
      typename Strategy >
  length_result< Geometry >::type length(
      Geometry const & geometry,
      Strategy const & strategy);


The function length returns the length of a [link boost_geometry.reference.boost__geometry `boost::geometry`], using specified [link boost_geometry.reference.strategy `strategy`] 
[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`], being a [link boost_geometry.reference.linestring `linestring`], vector, iterator pair, or any other `boost` compatible range ]]

[[strategy][[link boost_geometry.reference.strategy `strategy`] to be used for distance calculations. ]]

]



[heading Return Value]
      
the length 


[heading Example:]
  
Example showing length calculation using iterators and the Vincenty [link boost_geometry.reference.strategy `strategy`]  








[endsect]


[endsect]

[section:length_result length_result]


Meta-function defining return type of length function. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.Geometry Geometry]``>
  struct length_result

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.length_result.type [*type]]]
    []
  
  ]

]


[heading Description]



[heading Remarks]
      
Length of a line of integer coordinates can be double. So we take at least a double. If Big Number types are used, we take that type. 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/length_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type length_result::type]

[indexterm2 type..length_result] 

  typedef select_most_precise< typename coordinate_type< Geometry >::type, long double >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_most_precise.type [*type]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.select_most_precise.both_same [*both_same]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.one_not_fundamental [*one_not_fundamental]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.second_larger [*second_larger]]]
    []
  ]

]

[heading Typedef Description]
    
[link boost_geometry.reference.select_most_precise `select_most_precise`] classes, compares two types on compile time. For example, if an addition must be done with a double and an integer, the result must be a double. If both types are integer, the result can be an integer. 

[heading Remarks]
      
It is different from the "promote" class, already in `boost`. That class promotes e.g. a (one) float to a double. This class selects a type from two types. It takes the most accurate, but does not promote afterwards. 

This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

If the input is a non-fundamental type, it might be a calculation type such as a GMP-value or another high precision value. Therefore, if one is non-fundamental, that one is chosen. 

If both types are non-fundamental, the result is indeterminate and currently the first one is chosen. 




[heading Requirements]

[*Header: ][^boost/geometry/strategies/length_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:linear_ring linear_ring]


A [link boost_geometry.reference.linear_ring `linear_ring`] (linear [link boost_geometry.reference.linear_ring `linear_ring`]) is a closed line which should not be selfintersecting. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.P P]``,
      template< typename, typename > class ``[link boost_geometry.reference.V V]`` = std::vector,
      bool ``[link boost_geometry.reference.ClockWise ClockWise]`` = true,
      template< typename > class ``[link boost_geometry.reference.A A]`` = std::allocator>
  class linear_ring

[heading Description]



[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/linear_ring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:linestring linestring]


A [link boost_geometry.reference.linestring `linestring`] (named so by OGC) is a collection (default a vector) of points. 




[heading Synopsis]
  template<
      typename P ,
      template< typename, typename > class ``[link boost_geometry.reference.V V]`` = std::vector,
      template< typename > class ``[link boost_geometry.reference.A A]`` = std::allocator>
  class linestring

[heading Description]



[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type (see http://accu.org/index.php/journals/427#ftn.d0e249 ) ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/linestring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:linestring_2d linestring_2d]

[indexterm1 linestring_2d] 

  typedef linestring< point_2d > linestring_2d;


[heading Typedef Description]
    


[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type (see http://accu.org/index.php/journals/427#ftn.d0e249 ) ]]

]





[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:linestring_3d linestring_3d]

[indexterm1 linestring_3d] 

  typedef linestring< point_3d > linestring_3d;


[heading Typedef Description]
    


[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type (see http://accu.org/index.php/journals/427#ftn.d0e249 ) ]]

]





[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:linestring_tag linestring_tag]


OGC Linestring identifying [link boost_geometry.reference.tag `tag`]. 




[heading Synopsis]
  struct linestring_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:make make]

[indexterm1 make] 
Make a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 

    
  template<
      typename Geometry ,
      typename T >
  Geometry ``[link boost_geometry.reference.make.overload1 make]``(
      T const & c1,
      T const & c2);
  ``  [''''&raquo;''' [link boost_geometry.reference.make.overload1 more...]]``

  template<
      typename Geometry ,
      typename T >
  Geometry ``[link boost_geometry.reference.make.overload2 make]``(
      T const & c1,
      T const & c2,
      T const & c3);
  ``  [''''&raquo;''' [link boost_geometry.reference.make.overload2 more...]]``

  template<
      typename Geometry ,
      typename T >
  Geometry ``[link boost_geometry.reference.make.overload3 make]``(
      T const & c1,
      T const & c2,
      T const & c3,
      T const & c4);
  ``  [''''&raquo;''' [link boost_geometry.reference.make.overload3 more...]]``

  template<
      typename Geometry ,
      typename Range >
  Geometry ``[link boost_geometry.reference.make.overload4 make]``(
      Range const & range);
  ``  [''''&raquo;''' [link boost_geometry.reference.make.overload4 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/make.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 make (1 of 4 overloads)]


Make a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry ,
      typename T >
  Geometry make(
      T const & c1,
      T const & c2);


the Generic Geometry Library uses concepts for all its geometries. Therefore it does not rely on constructors. The "make" functions are object generators creating geometries. There are overloads with two, three, four or six values, which are implemented depending on the [link boost_geometry.reference.boost__geometry `boost::geometry`] specified. 

[heading Remarks]
      
It does not work with array-point types, like int\[2\] 



[variablelist
  
[[G][the [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[T][the coordinate type ]]

]



[heading Return Value]
      
the [link boost_geometry.reference.boost__geometry `boost::geometry`] 




[endsect]



[section:overload2 make (2 of 4 overloads)]


Make a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry ,
      typename T >
  Geometry make(
      T const & c1,
      T const & c2,
      T const & c3);




[heading Return Value]
      
a 3D [link boost_geometry.reference.point `point`] 




[endsect]



[section:overload3 make (3 of 4 overloads)]



  template<
      typename Geometry ,
      typename T >
  Geometry make(
      T const & c1,
      T const & c2,
      T const & c3,
      T const & c4);



[endsect]



[section:overload4 make (4 of 4 overloads)]



  template<
      typename Geometry ,
      typename Range >
  Geometry make(
      Range const & range);



[endsect]


[endsect]


[section:make_buffer make_buffer]

[indexterm1 make_buffer] 
Calculate and return buffer (= new [link boost_geometry.reference.boost__geometry `boost::geometry`]) around specified distance of [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Output ,
      typename Input ,
      typename T >
  Output make_buffer(
      Input const & geometry,
      T const & distance,
      T const & chord_length = -1);



[heading Parameters]
    

[variablelist
  
[[geometry][input [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[distance][the distance used in buffer ]]

[[chord_length][length of the chord's in the generated arcs around points or bends ]]

]



[heading Return Value]
      
the buffered [link boost_geometry.reference.boost__geometry `boost::geometry`] 



[heading Remarks]
      
See also: buffer 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/buffer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:make_centroid make_centroid]

[indexterm1 make_centroid] 
Calculate and return centroid. 

    
  template<
      typename Point ,
      typename Geometry >
  Point ``[link boost_geometry.reference.make_centroid.overload1 make_centroid]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.make_centroid.overload1 more...]]``

  template<
      typename Point ,
      typename Geometry ,
      typename Strategy >
  Point ``[link boost_geometry.reference.make_centroid.overload2 make_centroid]``(
      Geometry const & geometry,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.make_centroid.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/centroid.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 make_centroid (1 of 2 overloads)]


Calculate and return centroid. 


  template<
      typename Point ,
      typename Geometry >
  Point make_centroid(
      Geometry const & geometry);



[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to calculate centroid from ]]

]



[heading Return Value]
      
the centroid 




[endsect]



[section:overload2 make_centroid (2 of 2 overloads)]


Calculate and return centroid, using a specified [link boost_geometry.reference.strategy `strategy`]. 


  template<
      typename Point ,
      typename Geometry ,
      typename Strategy >
  Point make_centroid(
      Geometry const & geometry,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to calculate centroid from ]]

[[strategy][Calculation [link boost_geometry.reference.strategy `strategy`] for centroid ]]

]



[heading Return Value]
      
the centroid 




[endsect]


[endsect]


[section:make_distance_result make_distance_result]

[indexterm1 make_distance_result] 
Object generator to create instance which can be compared. 


  template<
      typename R ,
      typename T >
  R make_distance_result(
      T const & value);


If distance results have to be compared to a certain value it makes sense to use this function to generate a distance result of a certain value, and compare the distance result with this instance. SQRT calculations are then avoided 

[variablelist
  
[[R][distance result type ]]

[[T][arithmetic type, e.g. double ]]

]


[heading Parameters]
    

[variablelist
  
[[value][the distance to compare with ]]

]



[heading Return Value]
      
the distance result 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:make_envelope make_envelope]

[indexterm1 make_envelope] 
Calculate and return envelope of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Box ,
      typename Geometry >
  Box make_envelope(
      Geometry const & geometry);



[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/envelope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:make_inverse make_inverse]

[indexterm1 make_inverse] 
Create a [link boost_geometry.reference.box `box`] with inverse infinite coordinates. 


  template<
      typename Geometry >
  Geometry make_inverse();


The make\_inverse function initialize a 2D or 3D [link boost_geometry.reference.box `box`] with large coordinates, the min corner is very large, the max corner is very small 

[variablelist
  
[[Geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]



[heading Return Value]
      
the [link boost_geometry.reference.box `box`] 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/make.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:make_segment_iterator make_segment_iterator]

[indexterm1 make_segment_iterator] 

  template<
      typename C >
  segment_iterator< typename C::iterator, typename C::value_type > make_segment_iterator(
      C & c);


[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:make_zero make_zero]

[indexterm1 make_zero] 
Create a [link boost_geometry.reference.boost__geometry `boost::geometry`] with "zero" coordinates. 


  template<
      typename Geometry >
  Geometry make_zero();


The make\_zero function initializes a 2D or 3D [link boost_geometry.reference.point `point`] or [link boost_geometry.reference.box `box`] with coordinates of zero 

[variablelist
  
[[Geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]



[heading Return Value]
      
the [link boost_geometry.reference.boost__geometry `boost::geometry`] 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/make.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:math__d2r math::d2r]

[indexterm1 math::d2r] 

  double const d2r =pi / 180.0;


[heading Requirements]

[*Header: ][^boost/geometry/util/math.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:math__equals math::equals]

[indexterm1 math::equals] 
returns true if both arguments are equal. 


  template<
      typename T1 ,
      typename T2 >
  bool equals(
      T1 const & a,
      T2 const & b);



[heading Parameters]
    

[variablelist
  
[[a][first argument ]]

[[b][second argument ]]

]



[heading Return Value]
      
true if a == b 



[heading Remarks]
      
If both a and b are of an integral type, comparison is done by ==. If one of the types is floating [link boost_geometry.reference.point `point`], comparison is done by abs and comparing with epsilon. If one of the types is non-fundamental, it might be a high-precision number and comparison is done using the == operator of that class. 



[heading Requirements]

[*Header: ][^boost/geometry/util/math.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:math__hav math::hav]

[indexterm1 math::hav] 
Calculates the haversine of an angle. 


  template<
      typename T >
  T hav(
      T const & theta);




[heading Remarks]
      
See http://en.wikipedia.org/wiki/Haversine\_formula haversin(alpha) = sin2(alpha/2) 



[heading Requirements]

[*Header: ][^boost/geometry/util/math.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:math__pi math::pi]

[indexterm1 math::pi] 

  double const pi = boost::math::constants::pi<double>();


[heading Requirements]

[*Header: ][^boost/geometry/util/math.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:math__r2d math::r2d]

[indexterm1 math::r2d] 

  double const r2d = 1.0 / d2r;


[heading Requirements]

[*Header: ][^boost/geometry/util/math.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:math__sqr math::sqr]

[indexterm1 math::sqr] 
Short utility to return the square. 


  template<
      typename T >
  T sqr(
      T const & value);



[heading Parameters]
    

[variablelist
  
[[value][Value to calculate the square from ]]

]



[heading Return Value]
      
The squared value 



[heading Requirements]

[*Header: ][^boost/geometry/util/math.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:math__two_pi math::two_pi]

[indexterm1 math::two_pi] 

  double const two_pi = 2.0 * pi;


[heading Requirements]

[*Header: ][^boost/geometry/util/math.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:max_corner max_corner]

[indexterm1 max_corner] 
Index of maximum corner of the [link boost_geometry.reference.box `box`]. 


  const int max_corner = 1;


[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:min_corner min_corner]

[indexterm1 min_corner] 
Index of minimum corner of the [link boost_geometry.reference.box `box`]. 


  const int min_corner = 0;


[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:multiply_point multiply_point]

[indexterm1 multiply_point] 
Multiplies a [link boost_geometry.reference.point `point`] by another. 


  template<
      typename Point1 ,
      typename Point2 >
  void multiply_point(
      Point1 & p1,
      Point2 const & p2);


The coordinates of the second [link boost_geometry.reference.point `point`] will be multiplied by those of the first [link boost_geometry.reference.point `point`]. The second [link boost_geometry.reference.point `point`] is not modified. 
[heading Parameters]
    

[variablelist
  
[[p1][first [link boost_geometry.reference.point `point`] ]]

[[p2][second [link boost_geometry.reference.point `point`] ]]

]



[heading Remarks]
      
This is *not* a dot, cross or wedge product. It is a mere field-by-field multiplication. 



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:multiply_value multiply_value]

[indexterm1 multiply_value] 
Multiplies each coordinate of a [link boost_geometry.reference.point `point`] by a value. 


  template<
      typename Point >
  void multiply_value(
      Point & p,
      typename detail::param< Point >::type value);



[heading Parameters]
    

[variablelist
  
[[p][[link boost_geometry.reference.point `point`] ]]

[[value][value to multiply by ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:num_geometries num_geometries]

[indexterm1 num_geometries] 
Function to get the number of geometries of a composite [link boost_geometry.reference.boost__geometry `boost::geometry`]. For a single [link boost_geometry.reference.boost__geometry `boost::geometry`] it is always 0 (also for a [link boost_geometry.reference.polygon `polygon`] with holes). 


  template<
      typename Geometry >
  std::size_t num_geometries(
      Geometry const & geometry);




[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.polygon `polygon`] or other [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
the number of interior rings of the [link boost_geometry.reference.boost__geometry `boost::geometry`] 



[heading Requirements]

[*Header: ][^boost/geometry/core/num_geometries.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:num_interior_rings num_interior_rings]

[indexterm1 num_interior_rings] 
Function to get the number of interior rings of a [link boost_geometry.reference.polygon `polygon`]. 


  template<
      typename Geometry >
  std::size_t num_interior_rings(
      Geometry const & geometry);




[heading Remarks]
      
Defined by OGC as "numInteriorRing". To be consistent with "numPoints" letter "s" is appended 

Can be used for any [link boost_geometry.reference.boost__geometry `boost::geometry`], returning 0 for geometries not having interior rings 



[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.polygon `polygon`] or other [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
the number of interior rings of the [link boost_geometry.reference.boost__geometry `boost::geometry`] 



[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:num_points num_points]

[indexterm1 num_points] 
get number of points 


  template<
      typename Geometry >
  std::size_t num_points(
      Geometry const & geometry);




[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to get number of points from ]]

]



[heading Return Value]
      
number of points 



[heading Remarks]
      
For linestrings/rings also boost::size or .size() could be used, however, for polygons this is less obvious. So this function is provided. Besides that it is described by OGC (numPoints) 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/num_points.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:one_section_segment_iterator one_section_segment_iterator]





[heading Synopsis]
  template<
      typename G ,
      typename SEC ,
      typename B ,
      size_t ``[link boost_geometry.reference.D D]``>
  struct one_section_segment_iterator

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.one_section_segment_iterator.normal_iterator [*normal_iterator]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.one_section_segment_iterator.one_section_segment_iterator [*one_section_segment_iterator]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/iterators/section_iterators.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:normal_iterator one_section_segment_iterator::normal_iterator]

[indexterm2 normal_iterator..one_section_segment_iterator] 

  typedef boost::range_const_iterator< G >::type normal_iterator;



[heading Requirements]

[*Header: ][^boost/geometry/iterators/section_iterators.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:one_section_segment_iterator one_section_segment_iterator::one_section_segment_iterator]

[indexterm2 one_section_segment_iterator..one_section_segment_iterator] 

  ``[link boost_geometry.reference.one_section_segment_iterator.one_section_segment_iterator.overload1 one_section_segment_iterator]``(
      const G & ring,
      const SEC & section,
      const B & box);
  ``  [''''&raquo;''' [link boost_geometry.reference.one_section_segment_iterator.one_section_segment_iterator.overload1 more...]]``

  ``[link boost_geometry.reference.one_section_segment_iterator.one_section_segment_iterator.overload2 one_section_segment_iterator]``(
      normal_iterator end);
  ``  [''''&raquo;''' [link boost_geometry.reference.one_section_segment_iterator.one_section_segment_iterator.overload2 more...]]``


[section:overload1 one_section_segment_iterator::one_section_segment_iterator (1 of 2 overloads)]



  one_section_segment_iterator(
      const G & ring,
      const SEC & section,
      const B & box);



[endsect]



[section:overload2 one_section_segment_iterator::one_section_segment_iterator (2 of 2 overloads)]



  one_section_segment_iterator(
      normal_iterator end);



[endsect]


[endsect]


[endsect]


[section:operator_not__eq_ operator!=]

[indexterm1 operator!=] 

  template<
      typename Base ,
      typename Point >
  bool operator!=(
      segment_iterator< Base, Point > const & lhs,
      segment_iterator< Base, Point > const & rhs);


[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:operator_eq__eq_ operator==]

[indexterm1 operator==] 

  template<
      typename Base ,
      typename Point >
  bool operator==(
      segment_iterator< Base, Point > const & lhs,
      segment_iterator< Base, Point > const & rhs);


[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:order_selector order_selector]

[indexterm1 order_selector] 

  enum order_selector

[indexterm2 clockwise..order_selector]
[indexterm2 counterclockwise..order_selector]
[indexterm2 order_undetermined..order_selector]

[heading Values]
[variablelist

  [
    [clockwise]
    []
  ]

  [
    [counterclockwise]
    []
  ]

  [
    [order_undetermined]
    []
  ]

]


[heading Requirements]

[*Header: ][^boost/geometry/core/point_order.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:overlaps overlaps]

[indexterm1 overlaps] 
Determines overlap between two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool overlaps(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);




[heading Return Value]
      
true if there is overlap 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlaps.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:parse parse]

[indexterm1 parse] 
      
  template<
      typename Geometry >
  void ``[link boost_geometry.reference.parse.overload1 parse]``(
      Geometry & geometry,
      std::string const & c1,
      std::string const & c2);
  ``  [''''&raquo;''' [link boost_geometry.reference.parse.overload1 more...]]``

  template<
      typename Geometry ,
      typename S >
  void ``[link boost_geometry.reference.parse.overload2 parse]``(
      Geometry & geometry,
      std::string const & c1,
      std::string const & c2,
      S const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.parse.overload2 more...]]``

  template<
      typename Geometry >
  Geometry ``[link boost_geometry.reference.parse.overload3 parse]``(
      std::string const & c1,
      std::string const & c2);
  ``  [''''&raquo;''' [link boost_geometry.reference.parse.overload3 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/parse.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 parse (1 of 3 overloads)]


parse two strings to a spherical/geographic [link boost_geometry.reference.point `point`], using W/E/N/S 


  template<
      typename Geometry >
  void parse(
      Geometry & geometry,
      std::string const & c1,
      std::string const & c2);



[endsect]



[section:overload2 parse (2 of 3 overloads)]


parse two strings to a spherical/geographic [link boost_geometry.reference.point `point`], using a specified [link boost_geometry.reference.strategy `strategy`] 


  template<
      typename Geometry ,
      typename S >
  void parse(
      Geometry & geometry,
      std::string const & c1,
      std::string const & c2,
      S const & strategy);


user can use N/E/S/O or N/O/Z/W or other formats 


[endsect]



[section:overload3 parse (3 of 3 overloads)]



  template<
      typename Geometry >
  Geometry parse(
      std::string const & c1,
      std::string const & c2);



[endsect]


[endsect]

[section:perimeter perimeter]

[indexterm1 perimeter] 
      
  template<
      typename Geometry >
  length_result< Geometry >::type ``[link boost_geometry.reference.perimeter.overload1 perimeter]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.perimeter.overload1 more...]]``

  template<
      typename Geometry ,
      typename Strategy >
  length_result< Geometry >::type ``[link boost_geometry.reference.perimeter.overload2 perimeter]``(
      Geometry const & geometry,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.perimeter.overload2 more...]]``


[heading Geometries:]
  

* polygon 

* box 

* linear_ring 

* multi_polygon 





[heading Requirements]

[*Header: ][^boost/geometry/algorithms/perimeter.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 perimeter (1 of 2 overloads)]


Calculate perimeter of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry >
  length_result< Geometry >::type perimeter(
      Geometry const & geometry);


The function perimeter returns the perimeter of a [link boost_geometry.reference.boost__geometry `boost::geometry`], using the default distance-calculation-strategy 
[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`], be it a geometry::ring, vector, iterator pair, or any other `boost` compatible range ]]

]



[heading Return Value]
      
the perimeter 




[endsect]



[section:overload2 perimeter (2 of 2 overloads)]


Calculate perimeter of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry ,
      typename Strategy >
  length_result< Geometry >::type perimeter(
      Geometry const & geometry,
      Strategy const & strategy);


The function perimeter returns the perimeter of a [link boost_geometry.reference.boost__geometry `boost::geometry`], using specified [link boost_geometry.reference.strategy `strategy`] 
[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`], be it a geometry::ring, vector, iterator pair, or any other `boost` compatible range ]]

[[strategy][[link boost_geometry.reference.strategy `strategy`] to be used for distance calculations. ]]

]



[heading Return Value]
      
the perimeter 




[endsect]


[endsect]

[section:point point]


Basic [link boost_geometry.reference.point `point`] class, having coordinates defined in a neutral way. 




[heading Synopsis]
  template<
      typename T,
      std::size_t ``[link boost_geometry.reference.D D]``,
      typename ``[link boost_geometry.reference.C C]``>
  class point

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point.coordinate_system [*coordinate_system]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point.coordinate_type [*coordinate_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point.get [*get]]]
    [Compile time access to coordinate values. ]
  ]
  
  [
    [[link boost_geometry.reference.point.point [*point]]]
    [Default constructor, no initialization at all. 

     Constructs with one, or optionally two or three values. ]
  ]
  
  [
    [[link boost_geometry.reference.point.set [*set]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point.coordinate_count [*coordinate_count]]]
    []
  ]

]


[heading Description]



[variablelist
  
[[T][numeric type, for example double, float, int ]]

[[D][coordinate [link boost_geometry.reference.dimension `dimension`] as number of coordinates, for example 2 ]]

[[C][coordinate system, for example [link boost_geometry.reference.cs__cartesian `cs::cartesian`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:coordinate_count point::coordinate_count]

[indexterm2 coordinate_count..point] 

  static const std::size_t coordinate_count = D;



[endsect]



[section:coordinate_system point::coordinate_system]

[indexterm2 coordinate_system..point] 

  typedef C coordinate_system;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:coordinate_type point::coordinate_type]

[indexterm2 coordinate_type..point] 

  typedef T coordinate_type;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:get point::get]

[indexterm2 get..point] 
Compile time access to coordinate values. 


  template<
      std::size_t ``[link boost_geometry.reference.K K]``>
  T const & get() const;



[endsect]


[section:point point::point]

[indexterm2 point..point] 
Default constructor, no initialization at all. 


  ``[link boost_geometry.reference.point.point.overload1 point]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.point.point.overload1 more...]]``


Constructs with one, or optionally two or three values. 


  ``[link boost_geometry.reference.point.point.overload2 point]``(
      T const & v0,
      T const & v1 = 0,
      T const & v2 = 0);
  ``  [''''&raquo;''' [link boost_geometry.reference.point.point.overload2 more...]]``


[section:overload1 point::point (1 of 2 overloads)]


Default constructor, no initialization at all. 


  point();



[endsect]



[section:overload2 point::point (2 of 2 overloads)]


Constructs with one, or optionally two or three values. 


  point(
      T const & v0,
      T const & v1 = 0,
      T const & v2 = 0);



[endsect]


[endsect]


[section:set point::set]

[indexterm2 set..point] 

  template<
      std::size_t ``[link boost_geometry.reference.K K]``>
  void set(
      T value);



[endsect]



[endsect]


[section:point_2d point_2d]

[indexterm1 point_2d] 

  typedef point_xy< double, cs::cartesian > point_2d;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_xy.coordinate_system [*coordinate_system]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point_xy.coordinate_type [*coordinate_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_xy.get [*get]]]
    [Compile time access to coordinate values. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.point_xy [*point_xy]]]
    [Default constructor, does not initialize anything. 

     Constructor with x/y values. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.set [*set]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.point_xy.x [*x]]]
    [Get x-value. 

     Set x-value. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.y [*y]]]
    [Get y-value. 

     Set y-value. ]
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_xy.coordinate_count [*coordinate_count]]]
    []
  ]

]

[heading Typedef Description]
    


[variablelist
  
[[T][numeric type, arguments can be, for example, double, float, int ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:point_3d point_3d]

[indexterm1 point_3d] 

  typedef point< double, 3, cs::cartesian > point_3d;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point.coordinate_system [*coordinate_system]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point.coordinate_type [*coordinate_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point.get [*get]]]
    [Compile time access to coordinate values. ]
  ]
  
  [
    [[link boost_geometry.reference.point.point [*point]]]
    [Default constructor, no initialization at all. 

     Constructs with one, or optionally two or three values. ]
  ]
  
  [
    [[link boost_geometry.reference.point.set [*set]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point.coordinate_count [*coordinate_count]]]
    []
  ]

]

[heading Typedef Description]
    


[variablelist
  
[[T][numeric type, for example double, float, int ]]

[[D][coordinate [link boost_geometry.reference.dimension `dimension`] as number of coordinates, for example 2 ]]

[[C][coordinate system, for example [link boost_geometry.reference.cs__cartesian `cs::cartesian`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:point_order point_order]


Meta-function which defines [link boost_geometry.reference.point `point`] type of any [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename Geometry >
  struct point_order

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_order.ncg [*ncg]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_order.value [*value]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/point_order.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:ncg point_order::ncg]

[indexterm2 ncg..point_order] 

  typedef boost::remove_const< Geometry >::type ncg;



[heading Requirements]

[*Header: ][^boost/geometry/core/point_order.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:value point_order::value]

[indexterm2 value..point_order] 

  static const order_selector value = core_dispatch::point_order
        <
            typename tag<Geometry>::type,
            ncg
        >::value;



[endsect]



[endsect]

[section:point_tag point_tag]


OGC Point identifying [link boost_geometry.reference.tag `tag`]. 




[heading Synopsis]
  struct point_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:point_type point_type]


Meta-function which defines [link boost_geometry.reference.point `point`] type of any [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.Geometry Geometry]``>
  struct point_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_type.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point_type.type [*type]]]
    []
  
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:ncg point_type::ncg]

[indexterm2 ncg..point_type] 

  typedef boost::remove_const< Geometry >::type ncg;



[heading Requirements]

[*Header: ][^boost/geometry/core/point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:type point_type::type]

[indexterm2 type..point_type] 

  typedef core_dispatch::point_type< typename tag< Geometry >::type, ncg >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their [link boost_geometry.reference.boost__geometry `boost::geometry`] type ([link boost_geometry.reference.point `point`], [link boost_geometry.reference.linestring `linestring`], [link boost_geometry.reference.polygon `polygon`], etc) by implementing a [link boost_geometry.reference.tag `tag`] [link boost_geometry.reference.traits `traits`] class. This meta-function uses that [link boost_geometry.reference.traits `traits`] class to retrieve the [link boost_geometry.reference.tag `tag`]. If the input type is not a [link boost_geometry.reference.boost__geometry `boost::geometry`] at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:point_xy point_xy]


2D [link boost_geometry.reference.point `point`] in Cartesian coordinate system 




[heading Synopsis]
  template<
      typename T ,
      typename C  = cs::cartesian>
  class point_xy :    public point< T, 2, C >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_xy.coordinate_system [*coordinate_system]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point_xy.coordinate_type [*coordinate_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_xy.get [*get]]]
    [Compile time access to coordinate values. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.point_xy [*point_xy]]]
    [Default constructor, does not initialize anything. 

     Constructor with x/y values. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.set [*set]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.point_xy.x [*x]]]
    [Get x-value. 

     Set x-value. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.y [*y]]]
    [Get y-value. 

     Set y-value. ]
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_xy.coordinate_count [*coordinate_count]]]
    []
  ]

]


[heading Description]



[variablelist
  
[[T][numeric type, arguments can be, for example, double, float, int ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point_xy.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:coordinate_count point_xy::coordinate_count]


['Inherited from point.]

[indexterm2 coordinate_count..point_xy] 

  static const std::size_t coordinate_count;



[endsect]



[section:coordinate_system point_xy::coordinate_system]


['Inherited from point.]

[indexterm2 coordinate_system..point_xy] 

  typedef C coordinate_system;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point_xy.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:coordinate_type point_xy::coordinate_type]


['Inherited from point.]

[indexterm2 coordinate_type..point_xy] 

  typedef T coordinate_type;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point_xy.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:get point_xy::get]


['Inherited from point.]

[indexterm2 get..point_xy] 
Compile time access to coordinate values. 


  Tconst & get() const;



[endsect]


[section:point_xy point_xy::point_xy]

[indexterm2 point_xy..point_xy] 
Default constructor, does not initialize anything. 


  ``[link boost_geometry.reference.point_xy.point_xy.overload1 point_xy]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.point_xy.overload1 more...]]``


Constructor with x/y values. 


  ``[link boost_geometry.reference.point_xy.point_xy.overload2 point_xy]``(
      T const & x,
      T const & y);
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.point_xy.overload2 more...]]``


[section:overload1 point_xy::point_xy (1 of 2 overloads)]


Default constructor, does not initialize anything. 


  point_xy();



[endsect]



[section:overload2 point_xy::point_xy (2 of 2 overloads)]


Constructor with x/y values. 


  point_xy(
      T const & x,
      T const & y);



[endsect]


[endsect]


[section:set point_xy::set]


['Inherited from point.]

[indexterm2 set..point_xy] 

  void set(
      Tvalue );



[endsect]


[section:x point_xy::x]

[indexterm2 x..point_xy] 
Get x-value. 


  T const & ``[link boost_geometry.reference.point_xy.x.overload1 x]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.x.overload1 more...]]``


Set x-value. 


  void ``[link boost_geometry.reference.point_xy.x.overload2 x]``(
      T const & v);
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.x.overload2 more...]]``


[section:overload1 point_xy::x (1 of 2 overloads)]


Get x-value. 


  T const & x() const;



[endsect]



[section:overload2 point_xy::x (2 of 2 overloads)]


Set x-value. 


  void x(
      T const & v);



[endsect]


[endsect]

[section:y point_xy::y]

[indexterm2 y..point_xy] 
Get y-value. 


  T const & ``[link boost_geometry.reference.point_xy.y.overload1 y]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.y.overload1 more...]]``


Set y-value. 


  void ``[link boost_geometry.reference.point_xy.y.overload2 y]``(
      T const & v);
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.y.overload2 more...]]``


[section:overload1 point_xy::y (1 of 2 overloads)]


Get y-value. 


  T const & y() const;



[endsect]



[section:overload2 point_xy::y (2 of 2 overloads)]


Set y-value. 


  void y(
      T const & v);



[endsect]


[endsect]


[endsect]

[section:policies__relate__direction_type policies::relate::direction_type]





[heading Synopsis]
  struct direction_type

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.direction_type [*direction_type]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.arrival [*arrival]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.dir_a [*dir_a]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.dir_b [*dir_b]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.how [*how]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.how_a [*how_a]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.how_b [*how_b]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.opposite [*opposite]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.sides [*sides]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/direction.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:arrival policies::relate::direction_type::arrival]

[indexterm2 arrival..policies::relate::direction_type] 

  int arrival;



[endsect]



[section:dir_a policies::relate::direction_type::dir_a]

[indexterm2 dir_a..policies::relate::direction_type] 

  int dir_a;



[endsect]



[section:dir_b policies::relate::direction_type::dir_b]

[indexterm2 dir_b..policies::relate::direction_type] 

  int dir_b;



[endsect]


[section:direction_type policies::relate::direction_type::direction_type]

[indexterm2 direction_type..policies::relate::direction_type] 

  ``[link boost_geometry.reference.policies__relate__direction_type.direction_type.overload1 direction_type]``(
      side_info const & s,
      char h,
      int ha,
      int hb,
      int da = 0,
      int db = 0,
      bool op = false);
  ``  [''''&raquo;''' [link boost_geometry.reference.policies__relate__direction_type.direction_type.overload1 more...]]``

  ``[link boost_geometry.reference.policies__relate__direction_type.direction_type.overload2 direction_type]``(
      char h,
      bool op,
      int ha = 0,
      int hb = 0);
  ``  [''''&raquo;''' [link boost_geometry.reference.policies__relate__direction_type.direction_type.overload2 more...]]``


[section:overload1 policies::relate::direction_type::direction_type (1 of 2 overloads)]



  direction_type(
      side_info const & s,
      char h,
      int ha,
      int hb,
      int da = 0,
      int db = 0,
      bool op = false);



[endsect]



[section:overload2 policies::relate::direction_type::direction_type (2 of 2 overloads)]



  direction_type(
      char h,
      bool op,
      int ha = 0,
      int hb = 0);



[endsect]


[endsect]


[section:how policies::relate::direction_type::how]

[indexterm2 how..policies::relate::direction_type] 

  char how;



[endsect]



[section:how_a policies::relate::direction_type::how_a]

[indexterm2 how_a..policies::relate::direction_type] 

  int how_a;



[endsect]



[section:how_b policies::relate::direction_type::how_b]

[indexterm2 how_b..policies::relate::direction_type] 

  int how_b;



[endsect]



[section:opposite policies::relate::direction_type::opposite]

[indexterm2 opposite..policies::relate::direction_type] 

  bool opposite;



[endsect]



[section:sides policies::relate::direction_type::sides]

[indexterm2 sides..policies::relate::direction_type] 

  side_info sides;



[endsect]



[endsect]

[section:policies__relate__segments_de9im policies::relate::segments_de9im]





[heading Synopsis]
  template<
      typename S1 ,
      typename S2 >
  struct segments_de9im

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.policies__relate__segments_de9im.coordinate_type [*coordinate_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_de9im.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_de9im.segment_type1 [*segment_type1]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_de9im.segment_type2 [*segment_type2]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.collinear_a_in_b [*collinear_a_in_b]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.collinear_b_in_a [*collinear_b_in_a]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.collinear_disjoint [*collinear_disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.collinear_interior_boundary_intersect [*collinear_interior_boundary_intersect]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.collinear_overlaps [*collinear_overlaps]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.collinear_touch [*collinear_touch]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.degenerate [*degenerate]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.parallel [*parallel]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.rays_intersect [*rays_intersect]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_de9im.segment_equal [*segment_equal]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/de9im.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:collinear_a_in_b policies::relate::segments_de9im::collinear_a_in_b]

[indexterm2 collinear_a_in_b..policies::relate::segments_de9im] 

  static return_type collinear_a_in_b(
      S1 const & s,
      bool opposite);



[endsect]



[section:collinear_b_in_a policies::relate::segments_de9im::collinear_b_in_a]

[indexterm2 collinear_b_in_a..policies::relate::segments_de9im] 

  static return_type collinear_b_in_a(
      const S2 & s,
      bool opposite);



[endsect]



[section:collinear_disjoint policies::relate::segments_de9im::collinear_disjoint]

[indexterm2 collinear_disjoint..policies::relate::segments_de9im] 

  static return_type collinear_disjoint();



[endsect]



[section:collinear_interior_boundary_intersect policies::relate::segments_de9im::collinear_interior_boundary_intersect]

[indexterm2 collinear_interior_boundary_intersect..policies::relate::segments_de9im] 

  template<
      typename S >
  static return_type collinear_interior_boundary_intersect(
      S const & s,
      bool a_within_b,
      bool opposite);



[endsect]



[section:collinear_overlaps policies::relate::segments_de9im::collinear_overlaps]

[indexterm2 collinear_overlaps..policies::relate::segments_de9im] 

  static return_type collinear_overlaps(
      coordinate_type const & x1,
      coordinate_type const & y1,
      coordinate_type const & x2,
      coordinate_type const & y2,
      bool opposite);



[endsect]



[section:collinear_touch policies::relate::segments_de9im::collinear_touch]

[indexterm2 collinear_touch..policies::relate::segments_de9im] 

  static return_type collinear_touch(
      coordinate_type const & x,
      coordinate_type const & y,
      bool opposite,
      char );



[endsect]



[section:coordinate_type policies::relate::segments_de9im::coordinate_type]

[indexterm2 coordinate_type..policies::relate::segments_de9im] 

  typedef select_coordinate_type< S1, S2 >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/de9im.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:degenerate policies::relate::segments_de9im::degenerate]

[indexterm2 degenerate..policies::relate::segments_de9im] 

  static return_type degenerate(
      S1 const & segment,
      bool a_degenerate);



[endsect]



[section:parallel policies::relate::segments_de9im::parallel]

[indexterm2 parallel..policies::relate::segments_de9im] 

  static return_type parallel();



[endsect]



[section:rays_intersect policies::relate::segments_de9im::rays_intersect]

[indexterm2 rays_intersect..policies::relate::segments_de9im] 

  static return_type rays_intersect(
      bool on_segment,
      double ra,
      double rb,
      coordinate_type const & dx1,
      coordinate_type const & dy1,
      coordinate_type const & dx2,
      coordinate_type const & dy2,
      coordinate_type const & wx,
      coordinate_type const & wy,
      S1 const & s1,
      S2 const & s2);



[endsect]



[section:return_type policies::relate::segments_de9im::return_type]

[indexterm2 return_type..policies::relate::segments_de9im] 

  typedef de9im_segment return_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.de9im_segment.as_char [*as_char]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.contains [*contains]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.crosses [*crosses]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.de9im_segment [*de9im_segment]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.disjoint [*disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.equals [*equals]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.intersects [*intersects]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.overlaps [*overlaps]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.touches [*touches]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.de9im_segment.within [*within]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.de9im_segment.bb [*bb]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.be [*be]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.bi [*bi]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.collinear [*collinear]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.degenerate [*degenerate]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.eb [*eb]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ee [*ee]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ei [*ei]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ib [*ib]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ie [*ie]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ii [*ii]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.opposite [*opposite]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.parallel [*parallel]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.ra [*ra]]]
    []
  ]

  [
    [[link boost_geometry.reference.de9im_segment.rb [*rb]]]
    []
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/de9im.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_equal policies::relate::segments_de9im::segment_equal]

[indexterm2 segment_equal..policies::relate::segments_de9im] 

  static return_type segment_equal(
      S1 const & s,
      bool opposite);



[endsect]



[section:segment_type1 policies::relate::segments_de9im::segment_type1]

[indexterm2 segment_type1..policies::relate::segments_de9im] 

  typedef S1 segment_type1;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/de9im.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_type2 policies::relate::segments_de9im::segment_type2]

[indexterm2 segment_type2..policies::relate::segments_de9im] 

  typedef S2 segment_type2;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/de9im.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:policies__relate__segments_direction policies::relate::segments_direction]





[heading Synopsis]
  template<
      typename S1 ,
      typename S2 ,
      typename CalculationType  = void>
  struct segments_direction

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.policies__relate__segments_direction.coordinate_type [*coordinate_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_direction.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_direction.rtype [*rtype]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_direction.segment_type1 [*segment_type1]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_direction.segment_type2 [*segment_type2]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.policies__relate__segments_direction.collinear_a_in_b [*collinear_a_in_b]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.collinear_b_in_a [*collinear_b_in_a]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.collinear_disjoint [*collinear_disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.collinear_interior_boundary_intersect [*collinear_interior_boundary_intersect]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.collinear_overlaps [*collinear_overlaps]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.collinear_touch [*collinear_touch]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.degenerate [*degenerate]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.disjoint [*disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.error [*error]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.parallel [*parallel]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.segment_equal [*segment_equal]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_direction.segments_intersect [*segments_intersect]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/direction.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:collinear_a_in_b policies::relate::segments_direction::collinear_a_in_b]

[indexterm2 collinear_a_in_b..policies::relate::segments_direction] 

  static return_type collinear_a_in_b(
      S1 const & ,
      bool opposite);



[endsect]



[section:collinear_b_in_a policies::relate::segments_direction::collinear_b_in_a]

[indexterm2 collinear_b_in_a..policies::relate::segments_direction] 

  static return_type collinear_b_in_a(
      S2 const & ,
      bool opposite);



[endsect]



[section:collinear_disjoint policies::relate::segments_direction::collinear_disjoint]

[indexterm2 collinear_disjoint..policies::relate::segments_direction] 

  static return_type collinear_disjoint();



[endsect]



[section:collinear_interior_boundary_intersect policies::relate::segments_direction::collinear_interior_boundary_intersect]

[indexterm2 collinear_interior_boundary_intersect..policies::relate::segments_direction] 

  template<
      typename S >
  static return_type collinear_interior_boundary_intersect(
      S const & ,
      bool ,
      int arrival_a,
      int arrival_b,
      bool opposite);



[endsect]



[section:collinear_overlaps policies::relate::segments_direction::collinear_overlaps]

[indexterm2 collinear_overlaps..policies::relate::segments_direction] 

  static return_type collinear_overlaps(
      coordinate_type const & ,
      coordinate_type const & ,
      coordinate_type const & ,
      coordinate_type const & ,
      int arrival_a,
      int arrival_b,
      bool opposite);



[endsect]



[section:collinear_touch policies::relate::segments_direction::collinear_touch]

[indexterm2 collinear_touch..policies::relate::segments_direction] 

  static return_type collinear_touch(
      coordinate_type const & ,
      coordinate_type const & ,
      int arrival_a,
      int arrival_b);



[endsect]



[section:coordinate_type policies::relate::segments_direction::coordinate_type]

[indexterm2 coordinate_type..policies::relate::segments_direction] 

  typedef select_calculation_type< S1, S2, CalculationType >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_calculation_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
Based on two input [link boost_geometry.reference.boost__geometry `boost::geometry`] types, and an input calculation type, (which defaults to void in the calling function), this meta-function selects the most appropriate:
* if calculation type is specified, that one is used,

* if it is void, the most precise of the two points is used 




[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/direction.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:degenerate policies::relate::segments_direction::degenerate]

[indexterm2 degenerate..policies::relate::segments_direction] 

  static return_type degenerate(
      S1 const & ,
      bool );



[endsect]



[section:disjoint policies::relate::segments_direction::disjoint]

[indexterm2 disjoint..policies::relate::segments_direction] 

  static return_type disjoint();



[endsect]



[section:error policies::relate::segments_direction::error]

[indexterm2 error..policies::relate::segments_direction] 

  static return_type error(
      std::string const & msg);



[endsect]



[section:parallel policies::relate::segments_direction::parallel]

[indexterm2 parallel..policies::relate::segments_direction] 

  static return_type parallel();



[endsect]



[section:return_type policies::relate::segments_direction::return_type]

[indexterm2 return_type..policies::relate::segments_direction] 

  typedef direction_type return_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.direction_type [*direction_type]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.arrival [*arrival]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.dir_a [*dir_a]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.dir_b [*dir_b]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.how [*how]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.how_a [*how_a]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.how_b [*how_b]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.opposite [*opposite]]]
    []
  ]

  [
    [[link boost_geometry.reference.policies__relate__direction_type.sides [*sides]]]
    []
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/direction.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:rtype policies::relate::segments_direction::rtype]

[indexterm2 rtype..policies::relate::segments_direction] 

  typedef select_most_precise< coordinate_type, double >::type rtype;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_most_precise.type [*type]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.select_most_precise.both_same [*both_same]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.one_not_fundamental [*one_not_fundamental]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.second_larger [*second_larger]]]
    []
  ]

]

[heading Typedef Description]
    
[link boost_geometry.reference.select_most_precise `select_most_precise`] classes, compares two types on compile time. For example, if an addition must be done with a double and an integer, the result must be a double. If both types are integer, the result can be an integer. 

[heading Remarks]
      
It is different from the "promote" class, already in `boost`. That class promotes e.g. a (one) float to a double. This class selects a type from two types. It takes the most accurate, but does not promote afterwards. 

This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

If the input is a non-fundamental type, it might be a calculation type such as a GMP-value or another high precision value. Therefore, if one is non-fundamental, that one is chosen. 

If both types are non-fundamental, the result is indeterminate and currently the first one is chosen. 




[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/direction.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_equal policies::relate::segments_direction::segment_equal]

[indexterm2 segment_equal..policies::relate::segments_direction] 

  static return_type segment_equal(
      S1 const & ,
      bool opposite);



[endsect]



[section:segment_type1 policies::relate::segments_direction::segment_type1]

[indexterm2 segment_type1..policies::relate::segments_direction] 

  typedef S1 segment_type1;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/direction.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_type2 policies::relate::segments_direction::segment_type2]

[indexterm2 segment_type2..policies::relate::segments_direction] 

  typedef S2 segment_type2;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/direction.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segments_intersect policies::relate::segments_direction::segments_intersect]

[indexterm2 segments_intersect..policies::relate::segments_direction] 

  static return_type segments_intersect(
      side_info const & sides,
      coordinate_type const & dx1,
      coordinate_type const & dy1,
      coordinate_type const & dx2,
      coordinate_type const & dy2,
      S1 const & s1,
      S2 const & s2);



[endsect]



[endsect]

[section:policies__relate__segments_intersection_points policies::relate::segments_intersection_points]





[heading Synopsis]
  template<
      typename S1 ,
      typename S2 ,
      typename ReturnType ,
      typename CalculationType  = void>
  struct segments_intersection_points

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.policies__relate__segments_intersection_points.coordinate_type [*coordinate_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_intersection_points.promoted_type [*promoted_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_intersection_points.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_intersection_points.segment_type1 [*segment_type1]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_intersection_points.segment_type2 [*segment_type2]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.collinear_a_in_b [*collinear_a_in_b]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.collinear_b_in_a [*collinear_b_in_a]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.collinear_disjoint [*collinear_disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.collinear_inside [*collinear_inside]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.collinear_interior_boundary_intersect [*collinear_interior_boundary_intersect]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.collinear_overlaps [*collinear_overlaps]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.collinear_touch [*collinear_touch]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.cross [*cross]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.degenerate [*degenerate]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.disjoint [*disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.error [*error]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.parallel [*parallel]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.rico [*rico]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.segment_equal [*segment_equal]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_intersection_points.segments_intersect [*segments_intersect]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/intersection_points_slope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:collinear_a_in_b policies::relate::segments_intersection_points::collinear_a_in_b]

[indexterm2 collinear_a_in_b..policies::relate::segments_intersection_points] 

  static return_type collinear_a_in_b(
      S1 const & s,
      bool );



[endsect]



[section:collinear_b_in_a policies::relate::segments_intersection_points::collinear_b_in_a]

[indexterm2 collinear_b_in_a..policies::relate::segments_intersection_points] 

  static return_type collinear_b_in_a(
      S2 const & s,
      bool );



[endsect]



[section:collinear_disjoint policies::relate::segments_intersection_points::collinear_disjoint]

[indexterm2 collinear_disjoint..policies::relate::segments_intersection_points] 

  static return_type collinear_disjoint();



[endsect]



[section:collinear_inside policies::relate::segments_intersection_points::collinear_inside]

[indexterm2 collinear_inside..policies::relate::segments_intersection_points] 

  template<
      typename S >
  static return_type collinear_inside(
      S const & s);



[endsect]



[section:collinear_interior_boundary_intersect policies::relate::segments_intersection_points::collinear_interior_boundary_intersect]

[indexterm2 collinear_interior_boundary_intersect..policies::relate::segments_intersection_points] 

  template<
      typename S >
  static return_type collinear_interior_boundary_intersect(
      S const & s,
      bool ,
      bool );



[endsect]



[section:collinear_overlaps policies::relate::segments_intersection_points::collinear_overlaps]

[indexterm2 collinear_overlaps..policies::relate::segments_intersection_points] 

  static return_type collinear_overlaps(
      coordinate_type const & x1,
      coordinate_type const & y1,
      coordinate_type const & x2,
      coordinate_type const & y2,
      bool );



[endsect]



[section:collinear_touch policies::relate::segments_intersection_points::collinear_touch]

[indexterm2 collinear_touch..policies::relate::segments_intersection_points] 

  static return_type collinear_touch(
      coordinate_type const & x,
      coordinate_type const & y,
      bool ,
      char );



[endsect]



[section:coordinate_type policies::relate::segments_intersection_points::coordinate_type]

[indexterm2 coordinate_type..policies::relate::segments_intersection_points] 

  typedef select_calculation_type< S1, S2, CalculationType >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_calculation_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
Based on two input [link boost_geometry.reference.boost__geometry `boost::geometry`] types, and an input calculation type, (which defaults to void in the calling function), this meta-function selects the most appropriate:
* if calculation type is specified, that one is used,

* if it is void, the most precise of the two points is used 




[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/intersection_points_slope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:cross policies::relate::segments_intersection_points::cross]

[indexterm2 cross..policies::relate::segments_intersection_points] 

  static return_type cross(
      S1 const & s1,
      S2 const & s2);



[endsect]



[section:degenerate policies::relate::segments_intersection_points::degenerate]

[indexterm2 degenerate..policies::relate::segments_intersection_points] 

  static return_type degenerate(
      S1 const & s,
      bool );



[endsect]



[section:disjoint policies::relate::segments_intersection_points::disjoint]

[indexterm2 disjoint..policies::relate::segments_intersection_points] 

  static return_type disjoint();



[endsect]



[section:error policies::relate::segments_intersection_points::error]

[indexterm2 error..policies::relate::segments_intersection_points] 

  static return_type error(
      std::string const & msg);



[endsect]



[section:parallel policies::relate::segments_intersection_points::parallel]

[indexterm2 parallel..policies::relate::segments_intersection_points] 

  static return_type parallel();



[endsect]



[section:promoted_type policies::relate::segments_intersection_points::promoted_type]

[indexterm2 promoted_type..policies::relate::segments_intersection_points] 

  typedef select_most_precise< coordinate_type, double >::type promoted_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_most_precise.type [*type]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.select_most_precise.both_same [*both_same]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.one_not_fundamental [*one_not_fundamental]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.second_larger [*second_larger]]]
    []
  ]

]

[heading Typedef Description]
    
[link boost_geometry.reference.select_most_precise `select_most_precise`] classes, compares two types on compile time. For example, if an addition must be done with a double and an integer, the result must be a double. If both types are integer, the result can be an integer. 

[heading Remarks]
      
It is different from the "promote" class, already in `boost`. That class promotes e.g. a (one) float to a double. This class selects a type from two types. It takes the most accurate, but does not promote afterwards. 

This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

If the input is a non-fundamental type, it might be a calculation type such as a GMP-value or another high precision value. Therefore, if one is non-fundamental, that one is chosen. 

If both types are non-fundamental, the result is indeterminate and currently the first one is chosen. 




[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/intersection_points_slope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:return_type policies::relate::segments_intersection_points::return_type]

[indexterm2 return_type..policies::relate::segments_intersection_points] 

  typedef ReturnType return_type;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/intersection_points_slope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:rico policies::relate::segments_intersection_points::rico]

[indexterm2 rico..policies::relate::segments_intersection_points] 

  template<
      int ``[link boost_geometry.reference.Dimension Dimension]``>
  static return_type rico(
      coordinate_type const & dm1,
      coordinate_type const & dn1,
      coordinate_type const & dm2,
      coordinate_type const & dn2,
      S1 const & s1,
      S2 const & s2);



[endsect]



[section:segment_equal policies::relate::segments_intersection_points::segment_equal]

[indexterm2 segment_equal..policies::relate::segments_intersection_points] 

  static return_type segment_equal(
      S1 const & s,
      bool );



[endsect]



[section:segment_type1 policies::relate::segments_intersection_points::segment_type1]

[indexterm2 segment_type1..policies::relate::segments_intersection_points] 

  typedef S1 segment_type1;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/intersection_points_slope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_type2 policies::relate::segments_intersection_points::segment_type2]

[indexterm2 segment_type2..policies::relate::segments_intersection_points] 

  typedef S2 segment_type2;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/intersection_points_slope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segments_intersect policies::relate::segments_intersection_points::segments_intersect]

[indexterm2 segments_intersect..policies::relate::segments_intersection_points] 

  static return_type segments_intersect(
      side_info const & sides,
      coordinate_type const & dx1,
      coordinate_type const & dy1,
      coordinate_type const & dx2,
      coordinate_type const & dy2,
      S1 const & s1,
      S2 const & s2);



[endsect]



[endsect]

[section:policies__relate__segments_tupled policies::relate::segments_tupled]





[heading Synopsis]
  template<
      typename Policy1 ,
      typename Policy2 ,
      typename CalculationType  = void>
  struct segments_tupled

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.policies__relate__segments_tupled.coordinate_type [*coordinate_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_tupled.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_tupled.rtype [*rtype]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_tupled.segment_type1 [*segment_type1]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.policies__relate__segments_tupled.segment_type2 [*segment_type2]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.collinear_a_in_b [*collinear_a_in_b]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.collinear_b_in_a [*collinear_b_in_a]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.collinear_disjoint [*collinear_disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.collinear_interior_boundary_intersect [*collinear_interior_boundary_intersect]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.collinear_overlaps [*collinear_overlaps]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.collinear_touch [*collinear_touch]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.degenerate [*degenerate]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.disjoint [*disjoint]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.error [*error]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.parallel [*parallel]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.segment_equal [*segment_equal]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.policies__relate__segments_tupled.segments_intersect [*segments_intersect]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/tupled.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:collinear_a_in_b policies::relate::segments_tupled::collinear_a_in_b]

[indexterm2 collinear_a_in_b..policies::relate::segments_tupled] 

  static return_type collinear_a_in_b(
      segment_type1 const & segment,
      bool opposite);



[endsect]



[section:collinear_b_in_a policies::relate::segments_tupled::collinear_b_in_a]

[indexterm2 collinear_b_in_a..policies::relate::segments_tupled] 

  static return_type collinear_b_in_a(
      segment_type2 const & segment,
      bool opposite);



[endsect]



[section:collinear_disjoint policies::relate::segments_tupled::collinear_disjoint]

[indexterm2 collinear_disjoint..policies::relate::segments_tupled] 

  static return_type collinear_disjoint();



[endsect]



[section:collinear_interior_boundary_intersect policies::relate::segments_tupled::collinear_interior_boundary_intersect]

[indexterm2 collinear_interior_boundary_intersect..policies::relate::segments_tupled] 

  template<
      typename S >
  static return_type collinear_interior_boundary_intersect(
      S const & segment,
      bool a_within_b,
      int arrival_a,
      int arrival_b,
      bool opposite);



[endsect]



[section:collinear_overlaps policies::relate::segments_tupled::collinear_overlaps]

[indexterm2 collinear_overlaps..policies::relate::segments_tupled] 

  static return_type collinear_overlaps(
      coordinate_type const & x1,
      coordinate_type const & y1,
      coordinate_type const & x2,
      coordinate_type const & y2,
      int arrival_a,
      int arrival_b,
      bool opposite);



[endsect]



[section:collinear_touch policies::relate::segments_tupled::collinear_touch]

[indexterm2 collinear_touch..policies::relate::segments_tupled] 

  static return_type collinear_touch(
      coordinate_type const & x,
      coordinate_type const & y,
      int arrival_a,
      int arrival_b);



[endsect]



[section:coordinate_type policies::relate::segments_tupled::coordinate_type]

[indexterm2 coordinate_type..policies::relate::segments_tupled] 

  typedef select_calculation_type< segment_type1, segment_type2, CalculationType >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_calculation_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
Based on two input [link boost_geometry.reference.boost__geometry `boost::geometry`] types, and an input calculation type, (which defaults to void in the calling function), this meta-function selects the most appropriate:
* if calculation type is specified, that one is used,

* if it is void, the most precise of the two points is used 




[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/tupled.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:degenerate policies::relate::segments_tupled::degenerate]

[indexterm2 degenerate..policies::relate::segments_tupled] 

  static return_type degenerate(
      segment_type1 const & segment,
      bool a_degenerate);



[endsect]



[section:disjoint policies::relate::segments_tupled::disjoint]

[indexterm2 disjoint..policies::relate::segments_tupled] 

  static return_type disjoint();



[endsect]



[section:error policies::relate::segments_tupled::error]

[indexterm2 error..policies::relate::segments_tupled] 

  static return_type error(
      std::string const & msg);



[endsect]



[section:parallel policies::relate::segments_tupled::parallel]

[indexterm2 parallel..policies::relate::segments_tupled] 

  static return_type parallel();



[endsect]



[section:return_type policies::relate::segments_tupled::return_type]

[indexterm2 return_type..policies::relate::segments_tupled] 

  typedef boost::tuple< typename Policy1::return_type, typename Policy2::return_type > return_type;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/tupled.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:rtype policies::relate::segments_tupled::rtype]

[indexterm2 rtype..policies::relate::segments_tupled] 

  typedef select_most_precise< coordinate_type, double >::type rtype;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_most_precise.type [*type]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.select_most_precise.both_same [*both_same]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.one_not_fundamental [*one_not_fundamental]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.second_larger [*second_larger]]]
    []
  ]

]

[heading Typedef Description]
    
[link boost_geometry.reference.select_most_precise `select_most_precise`] classes, compares two types on compile time. For example, if an addition must be done with a double and an integer, the result must be a double. If both types are integer, the result can be an integer. 

[heading Remarks]
      
It is different from the "promote" class, already in `boost`. That class promotes e.g. a (one) float to a double. This class selects a type from two types. It takes the most accurate, but does not promote afterwards. 

This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

If the input is a non-fundamental type, it might be a calculation type such as a GMP-value or another high precision value. Therefore, if one is non-fundamental, that one is chosen. 

If both types are non-fundamental, the result is indeterminate and currently the first one is chosen. 




[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/tupled.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_equal policies::relate::segments_tupled::segment_equal]

[indexterm2 segment_equal..policies::relate::segments_tupled] 

  static return_type segment_equal(
      segment_type1 const & s,
      bool opposite);



[endsect]



[section:segment_type1 policies::relate::segments_tupled::segment_type1]

[indexterm2 segment_type1..policies::relate::segments_tupled] 

  typedef Policy1::segment_type1 segment_type1;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/tupled.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_type2 policies::relate::segments_tupled::segment_type2]

[indexterm2 segment_type2..policies::relate::segments_tupled] 

  typedef Policy1::segment_type2 segment_type2;



[heading Requirements]

[*Header: ][^boost/geometry/policies/relate/tupled.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segments_intersect policies::relate::segments_tupled::segments_intersect]

[indexterm2 segments_intersect..policies::relate::segments_tupled] 

  static return_type segments_intersect(
      side_info const & sides,
      coordinate_type const & dx1,
      coordinate_type const & dy1,
      coordinate_type const & dx2,
      coordinate_type const & dy2,
      segment_type1 const & s1,
      segment_type2 const & s2);



[endsect]



[endsect]

[section:polygon polygon]


The [link boost_geometry.reference.polygon `polygon`] contains an outer ring and zero or more inner rings. 




[heading Synopsis]
  template<
      typename Point ,
      template< typename, typename > class ``[link boost_geometry.reference.PointList PointList]`` = std::vector,
      template< typename, typename > class ``[link boost_geometry.reference.RingList RingList]`` = std::vector,
      bool ``[link boost_geometry.reference.ClockWise ClockWise]`` = true,
      template< typename > class ``[link boost_geometry.reference.PointAlloc PointAlloc]`` = std::allocator,
      template< typename > class ``[link boost_geometry.reference.RingAlloc RingAlloc]`` = std::allocator>
  class polygon

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.polygon.inner_container_type [*inner_container_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.ring_type [*ring_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.polygon.clear [*clear]]]
    [Utility method, clears outer and inner rings. ]
  ]
  
  [
    [[link boost_geometry.reference.polygon.inners [*inners]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.polygon.outer [*outer]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[PointList][optional container type for points, for example std::vector, std::list, std::deque ]]

[[RingList][optional container type for inner rings, for example std::vector, std::list, std::deque ]]

[[ClockWise][optional parameter, true for clockwise direction, false for CounterClockWise direction ]]

[[PointAlloc][container-allocator-type ]]

[[RingAlloc][container-allocator-type ]]

]



[heading Remarks]
      
The container collecting the points in the rings can be different from the container collecting the inner rings. They all default to vector. 



[heading Requirements]

[*Header: ][^boost/geometry/geometries/polygon.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:clear polygon::clear]

[indexterm2 clear..polygon] 
Utility method, clears outer and inner rings. 


  void clear();



[endsect]



[section:inner_container_type polygon::inner_container_type]

[indexterm2 inner_container_type..polygon] 

  typedef RingList< ring_type, RingAlloc< ring_type > > inner_container_type;


[heading Typedef Description]
    


[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/polygon.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:inners polygon::inners]

[indexterm2 inners..polygon] 

  inner_container_type const & ``[link boost_geometry.reference.polygon.inners.overload1 inners]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.polygon.inners.overload1 more...]]``

  inner_container_type & ``[link boost_geometry.reference.polygon.inners.overload2 inners]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.polygon.inners.overload2 more...]]``


[section:overload1 polygon::inners (1 of 2 overloads)]



  inner_container_type const & inners() const;



[endsect]



[section:overload2 polygon::inners (2 of 2 overloads)]



  inner_container_type & inners();



[endsect]


[endsect]

[section:outer polygon::outer]

[indexterm2 outer..polygon] 

  ring_type const & ``[link boost_geometry.reference.polygon.outer.overload1 outer]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.polygon.outer.overload1 more...]]``

  ring_type & ``[link boost_geometry.reference.polygon.outer.overload2 outer]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.polygon.outer.overload2 more...]]``


[section:overload1 polygon::outer (1 of 2 overloads)]



  ring_type const & outer() const;



[endsect]



[section:overload2 polygon::outer (2 of 2 overloads)]



  ring_type & outer();



[endsect]


[endsect]


[section:point_type polygon::point_type]

[indexterm2 point_type..polygon] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/polygon.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:ring_type polygon::ring_type]

[indexterm2 ring_type..polygon] 

  typedef linear_ring< Point, PointList, ClockWise, PointAlloc > ring_type;


[heading Typedef Description]
    


[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/polygon.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]


[section:polygon_2d polygon_2d]

[indexterm1 polygon_2d] 

  typedef polygon< point_2d > polygon_2d;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.polygon.inner_container_type [*inner_container_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.ring_type [*ring_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.polygon.clear [*clear]]]
    [Utility method, clears outer and inner rings. ]
  ]
  
  [
    [[link boost_geometry.reference.polygon.inners [*inners]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.polygon.outer [*outer]]]
    []
  ]
  
]

[heading Typedef Description]
    


[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[PointList][optional container type for points, for example std::vector, std::list, std::deque ]]

[[RingList][optional container type for inner rings, for example std::vector, std::list, std::deque ]]

[[ClockWise][optional parameter, true for clockwise direction, false for CounterClockWise direction ]]

[[PointAlloc][container-allocator-type ]]

[[RingAlloc][container-allocator-type ]]

]



[heading Remarks]
      
The container collecting the points in the rings can be different from the container collecting the inner rings. They all default to vector. 




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:polygon_3d polygon_3d]

[indexterm1 polygon_3d] 

  typedef polygon< point_3d > polygon_3d;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.polygon.inner_container_type [*inner_container_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.ring_type [*ring_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.polygon.clear [*clear]]]
    [Utility method, clears outer and inner rings. ]
  ]
  
  [
    [[link boost_geometry.reference.polygon.inners [*inners]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.polygon.outer [*outer]]]
    []
  ]
  
]

[heading Typedef Description]
    


[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[PointList][optional container type for points, for example std::vector, std::list, std::deque ]]

[[RingList][optional container type for inner rings, for example std::vector, std::list, std::deque ]]

[[ClockWise][optional parameter, true for clockwise direction, false for CounterClockWise direction ]]

[[PointAlloc][container-allocator-type ]]

[[RingAlloc][container-allocator-type ]]

]



[heading Remarks]
      
The container collecting the points in the rings can be different from the container collecting the inner rings. They all default to vector. 




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:polygon_tag polygon_tag]


OGC Polygon identifying [link boost_geometry.reference.tag `tag`]. 




[heading Synopsis]
  struct polygon_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:radian radian]


Unit of plane angle: Radians. 




[heading Synopsis]
  class radian

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:range_iterator_const_if_c range_iterator_const_if_c]


Meta-function to define a const or non const `boost` range iterator. 




[heading Synopsis]
  template<
      bool ``[link boost_geometry.reference.IsConst IsConst]``,
      typename Range >
  struct range_iterator_const_if_c

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.range_iterator_const_if_c.type [*type]]]
    []
  
  ]

]


[heading Description]

Is used to have one implementation for both const and non const range iterators 

[heading Remarks]
      
This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

Used in for\_each 



[heading Requirements]

[*Header: ][^boost/geometry/util/range_iterator_const_if_c.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type range_iterator_const_if_c::type]

[indexterm2 type..range_iterator_const_if_c] 

  typedef boost::mpl::if_c< IsConst, typename boost::range_const_iterator< Range >::type, typename boost::range_iterator< Range >::type >::type type;



[heading Requirements]

[*Header: ][^boost/geometry/util/range_iterator_const_if_c.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:range_type range_type]


Meta-function defining a type which is a boost-range. 




[heading Synopsis]
  template<
      typename Geometry >
  struct range_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.range_type.type [*type]]]
    []
  
  ]

]


[heading Description]


* For linestrings and rings, it defines the type itself.

* For polygons it defines the ring type.

* For multi-points, it defines the type itself

* For multi-polygons and multi-linestrings, it defines the single-version (so in the end the linestring and ring-type-of-multi-polygon) 



[heading Requirements]

[*Header: ][^boost/geometry/iterators/range_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type range_type::type]

[indexterm2 type..range_type] 

  typedef dispatch::range_type< typename tag< Geometry >::type, Geometry >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their [link boost_geometry.reference.boost__geometry `boost::geometry`] type ([link boost_geometry.reference.point `point`], [link boost_geometry.reference.linestring `linestring`], [link boost_geometry.reference.polygon `polygon`], etc) by implementing a [link boost_geometry.reference.tag `tag`] [link boost_geometry.reference.traits `traits`] class. This meta-function uses that [link boost_geometry.reference.traits `traits`] class to retrieve the [link boost_geometry.reference.tag `tag`]. If the input type is not a [link boost_geometry.reference.boost__geometry `boost::geometry`] at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/iterators/range_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:replace_point_type replace_point_type]





[heading Synopsis]
  template<
      typename Geometry ,
      typename NewPointType >
  struct replace_point_type

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/replace_point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:reverse reverse]

[indexterm1 reverse] 

  template<
      typename Geometry >
  void reverse(
      Geometry & geometry);




[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to make reverse ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/reverse.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:reverse_dispatch reverse_dispatch]





[heading Synopsis]
  template<
      typename Geometry1 ,
      typename Geometry2 >
  struct reverse_dispatch

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/reverse_dispatch.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:ring_2d ring_2d]

[indexterm1 ring_2d] 

  typedef linear_ring< point_2d > ring_2d;


[heading Typedef Description]
    


[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:ring_3d ring_3d]

[indexterm1 ring_3d] 

  typedef linear_ring< point_3d > ring_3d;


[heading Typedef Description]
    


[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:ring_tag ring_tag]


Convenience (linear) ring identifying [link boost_geometry.reference.tag `tag`]. 




[heading Synopsis]
  struct ring_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:ring_type ring_type]


Meta-function which defines ring type of (multi)[link boost_geometry.reference.polygon `polygon`] [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename Geometry >
  struct ring_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.ring_type.type [*type]]]
    []
  
  ]

]


[heading Description]

a [link boost_geometry.reference.polygon `polygon`] contains one exterior ring and zero or more interior rings (holes). This meta function retrieves the type of the rings 

[heading Remarks]
      
Exterior ring and interior rings must have the same ring-type. 



[heading Requirements]

[*Header: ][^boost/geometry/core/ring_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type ring_type::type]

[indexterm2 type..ring_type] 

  typedef core_dispatch::ring_type< typename tag< Geometry >::type, Geometry >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their [link boost_geometry.reference.boost__geometry `boost::geometry`] type ([link boost_geometry.reference.point `point`], [link boost_geometry.reference.linestring `linestring`], [link boost_geometry.reference.polygon `polygon`], etc) by implementing a [link boost_geometry.reference.tag `tag`] [link boost_geometry.reference.traits `traits`] class. This meta-function uses that [link boost_geometry.reference.traits `traits`] class to retrieve the [link boost_geometry.reference.tag `tag`]. If the input type is not a [link boost_geometry.reference.boost__geometry `boost::geometry`] at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/ring_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:section section]


Structure containing [link boost_geometry.reference.section `section`] information. 




[heading Synopsis]
  template<
      typename Box ,
      std::size_t ``[link boost_geometry.reference.DimensionCount DimensionCount]``>
  struct section

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.section.box_type [*box_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.section.section [*section]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.section.begin_index [*begin_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.bounding_box [*bounding_box]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.count [*count]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.directions [*directions]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.duplicate [*duplicate]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.end_index [*end_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.id [*id]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.multi_index [*multi_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.non_duplicate_index [*non_duplicate_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.range_count [*range_count]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.ring_index [*ring_index]]]
    []
  ]

]


[heading Description]

Section information consists of a bounding [link boost_geometry.reference.box `box`], direction information (if it is increasing or decreasing, per [link boost_geometry.reference.dimension `dimension`]), index information (begin-end, ring, multi) and the number of segments in this [link boost_geometry.reference.section `section`]



[variablelist
  
[[Box][box-type ]]

[[DimensionCount][number of dimensions for this [link boost_geometry.reference.section `section`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:begin_index section::begin_index]

[indexterm2 begin_index..section] 

  int begin_index;



[endsect]



[section:bounding_box section::bounding_box]

[indexterm2 bounding_box..section] 

  Box bounding_box;



[endsect]



[section:box_type section::box_type]

[indexterm2 box_type..section] 

  typedef Box box_type;



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:count section::count]

[indexterm2 count..section] 

  std::size_t count;



[endsect]



[section:directions section::directions]

[indexterm2 directions..section] 

  int directions;



[endsect]



[section:duplicate section::duplicate]

[indexterm2 duplicate..section] 

  bool duplicate;



[endsect]



[section:end_index section::end_index]

[indexterm2 end_index..section] 

  int end_index;



[endsect]



[section:id section::id]

[indexterm2 id..section] 

  int id;



[endsect]



[section:multi_index section::multi_index]

[indexterm2 multi_index..section] 

  int multi_index;



[endsect]



[section:non_duplicate_index section::non_duplicate_index]

[indexterm2 non_duplicate_index..section] 

  int non_duplicate_index;



[endsect]



[section:range_count section::range_count]

[indexterm2 range_count..section] 

  std::size_t range_count;



[endsect]



[section:ring_index section::ring_index]

[indexterm2 ring_index..section] 

  int ring_index;



[endsect]



[section:section section::section]

[indexterm2 section..section] 

  section();



[endsect]



[endsect]

[section:section_iterator section_iterator]





[heading Synopsis]
  template<
      typename G ,
      typename S ,
      typename B ,
      size_t ``[link boost_geometry.reference.D D]``>
  struct section_iterator

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.section_iterator.section_iterator [*section_iterator]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/iterators/section_iterators.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:section_iterator section_iterator::section_iterator]

[indexterm2 section_iterator..section_iterator] 

  section_iterator(
      const G & ring,
      const S & sections,
      const B & box);



[endsect]



[endsect]


[section:sectionalize sectionalize]

[indexterm1 sectionalize] 
Split a [link boost_geometry.reference.boost__geometry `boost::geometry`] into monotonic [link boost_geometry.reference.sections `sections`]. 


  template<
      typename Geometry ,
      typename Sections >
  void sectionalize(
      Geometry const & geometry,
      Sections & sections);




[variablelist
  
[[Geometry][type of [link boost_geometry.reference.boost__geometry `boost::geometry`] to check ]]

[[Sections][type of [link boost_geometry.reference.sections `sections`] to create ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to create [link boost_geometry.reference.sections `sections`] from ]]

[[sections][structure with [link boost_geometry.reference.sections `sections`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:sections sections]


Structure containing a collection of [link boost_geometry.reference.sections `sections`]. 




[heading Synopsis]
  template<
      typename Box ,
      std::size_t ``[link boost_geometry.reference.DimensionCount DimensionCount]``>
  struct sections

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.sections.box_type [*box_type]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.sections.value [*value]]]
    []
  ]

]


[heading Description]



[heading Remarks]
      
Derived from a vector, proves to be faster than of deque 

vector might be templated in the future 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:box_type sections::box_type]

[indexterm2 box_type..sections] 

  typedef Box box_type;



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:value sections::value]

[indexterm2 value..sections] 

  static const std::size_t value = DimensionCount;



[endsect]



[endsect]

[section:segment segment]


Class [link boost_geometry.reference.segment `segment`]: small class containing two (templatized) [link boost_geometry.reference.point `point`] references. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.ConstOrNonConstPoint ConstOrNonConstPoint]``>
  class segment

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.segment [*segment]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.first [*first]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment.second [*second]]]
    []
  ]

]


[heading Description]

From Wikipedia: In [link boost_geometry.reference.boost__geometry `boost::geometry`], a line [link boost_geometry.reference.segment `segment`] is a part of a line that is bounded by two distinct end points, and contains every [link boost_geometry.reference.point `point`] on the line between its end points. 

[heading Remarks]
      
The structure is like std::pair, and can often be used interchangeable. Difference is that it refers to points, does not have points. 

Like std::pair, points are public available. 

type is const or non const, so geometry::segment<P> or geometry::segment<const P> 

We cannot derive from std::pair<P&, P&> because of reference assignments. 



[variablelist
  
[[ConstOrNonConstPoint][[link boost_geometry.reference.point `point`] type of the [link boost_geometry.reference.segment `segment`], maybe a [link boost_geometry.reference.point `point`] or a const [link boost_geometry.reference.point `point`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/segment.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:first segment::first]

[indexterm2 first..segment] 

  point_type & first;



[endsect]



[section:second segment::second]

[indexterm2 second..segment] 

  point_type & second;



[endsect]



[section:segment segment::segment]

[indexterm2 segment..segment] 

  segment(
      point_type & p1,
      point_type & p2);



[endsect]



[endsect]


[section:segment_2d segment_2d]

[indexterm1 segment_2d] 

  typedef segment< point_2d > segment_2d;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.segment [*segment]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.first [*first]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment.second [*second]]]
    []
  ]

]

[heading Typedef Description]
    
From Wikipedia: In [link boost_geometry.reference.boost__geometry `boost::geometry`], a line [link boost_geometry.reference.segment `segment`] is a part of a line that is bounded by two distinct end points, and contains every [link boost_geometry.reference.point `point`] on the line between its end points. 

[heading Remarks]
      
The structure is like std::pair, and can often be used interchangeable. Difference is that it refers to points, does not have points. 

Like std::pair, points are public available. 

type is const or non const, so geometry::segment<P> or geometry::segment<const P> 

We cannot derive from std::pair<P&, P&> because of reference assignments. 



[variablelist
  
[[ConstOrNonConstPoint][[link boost_geometry.reference.point `point`] type of the [link boost_geometry.reference.segment `segment`], maybe a [link boost_geometry.reference.point `point`] or a const [link boost_geometry.reference.point `point`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:segment_identifier segment_identifier]





[heading Synopsis]
  struct segment_identifier

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment_identifier.operator_lt_ [*operator<]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.segment_identifier.operator_eq__eq_ [*operator==]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.segment_identifier.segment_identifier [*segment_identifier]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment_identifier.multi_index [*multi_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment_identifier.ring_index [*ring_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment_identifier.segment_index [*segment_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment_identifier.source_index [*source_index]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/segment_identifier.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:multi_index segment_identifier::multi_index]

[indexterm2 multi_index..segment_identifier] 

  int multi_index;



[endsect]



[section:operator_lt_ segment_identifier::operator<]

[indexterm2 operator<..segment_identifier] 

  bool operator<(
      segment_identifier const & other) const;



[endsect]



[section:operator_eq__eq_ segment_identifier::operator==]

[indexterm2 operator==..segment_identifier] 

  bool operator==(
      segment_identifier const & other) const;



[endsect]



[section:ring_index segment_identifier::ring_index]

[indexterm2 ring_index..segment_identifier] 

  int ring_index;



[endsect]


[section:segment_identifier segment_identifier::segment_identifier]

[indexterm2 segment_identifier..segment_identifier] 

  ``[link boost_geometry.reference.segment_identifier.segment_identifier.overload1 segment_identifier]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.segment_identifier.segment_identifier.overload1 more...]]``

  ``[link boost_geometry.reference.segment_identifier.segment_identifier.overload2 segment_identifier]``(
      int src,
      int mul,
      int rin,
      int seg);
  ``  [''''&raquo;''' [link boost_geometry.reference.segment_identifier.segment_identifier.overload2 more...]]``


[section:overload1 segment_identifier::segment_identifier (1 of 2 overloads)]



  segment_identifier();



[endsect]



[section:overload2 segment_identifier::segment_identifier (2 of 2 overloads)]



  segment_identifier(
      int src,
      int mul,
      int rin,
      int seg);



[endsect]


[endsect]


[section:segment_index segment_identifier::segment_index]

[indexterm2 segment_index..segment_identifier] 

  int segment_index;



[endsect]



[section:source_index segment_identifier::source_index]

[indexterm2 source_index..segment_identifier] 

  int source_index;



[endsect]



[endsect]

[section:segment_intersection_points segment_intersection_points]





[heading Synopsis]
  template<
      typename Point >
  struct segment_intersection_points

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.segment_intersection_points.point_type [*point_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment_intersection_points.segment_intersection_points [*segment_intersection_points]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment_intersection_points.count [*count]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment_intersection_points.intersections [*intersections]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/intersection_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:count segment_intersection_points::count]

[indexterm2 count..segment_intersection_points] 

  std::size_t count;



[endsect]



[section:intersections segment_intersection_points::intersections]

[indexterm2 intersections..segment_intersection_points] 

  Point intersections;



[endsect]



[section:point_type segment_intersection_points::point_type]

[indexterm2 point_type..segment_intersection_points] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/intersection_result.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_intersection_points segment_intersection_points::segment_intersection_points]

[indexterm2 segment_intersection_points..segment_intersection_points] 

  segment_intersection_points();



[endsect]



[endsect]

[section:segment_iterator segment_iterator]





[heading Synopsis]
  template<
      typename Base ,
      typename Point >
  struct segment_iterator

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.segment_iterator.base_type [*base_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.segment_iterator.difference_type [*difference_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.segment_iterator.iterator_category [*iterator_category]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.segment_iterator.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.segment_iterator.pointer [*pointer]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.segment_iterator.reference [*reference]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.segment_iterator.segment_type [*segment_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.segment_iterator.value_type [*value_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment_iterator.base [*base]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.segment_iterator.operator* [*operator*]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.segment_iterator.operator_plus__plus_ [*operator++]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.segment_iterator.operator-_gt_ [*operator->]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.segment_iterator.segment_iterator [*segment_iterator]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:base segment_iterator::base]

[indexterm2 base..segment_iterator] 

  Base const & base() const;



[endsect]



[section:base_type segment_iterator::base_type]

[indexterm2 base_type..segment_iterator] 

  typedef Base base_type;



[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:difference_type segment_iterator::difference_type]

[indexterm2 difference_type..segment_iterator] 

  typedef std::iterator_traits< Base >::difference_type difference_type;



[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:iterator_category segment_iterator::iterator_category]

[indexterm2 iterator_category..segment_iterator] 

  typedef std::input_iterator_tag iterator_category;



[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:operator* segment_iterator::operator*]

[indexterm2 operator*..segment_iterator] 

  reference operator*();



[endsect]


[section:operator_plus__plus_ segment_iterator::operator++]

[indexterm2 operator++..segment_iterator] 

  segment_iterator & ``[link boost_geometry.reference.segment_iterator.operator_plus__plus_.overload1 operator++]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.segment_iterator.operator_plus__plus_.overload1 more...]]``

  segment_iterator ``[link boost_geometry.reference.segment_iterator.operator_plus__plus_.overload2 operator++]``(
      int );
  ``  [''''&raquo;''' [link boost_geometry.reference.segment_iterator.operator_plus__plus_.overload2 more...]]``


[section:overload1 segment_iterator::operator++ (1 of 2 overloads)]



  segment_iterator & operator++();



[endsect]



[section:overload2 segment_iterator::operator++ (2 of 2 overloads)]



  segment_iterator operator++(
      int );



[endsect]


[endsect]


[section:operator-_gt_ segment_iterator::operator->]

[indexterm2 operator->..segment_iterator] 

  pointer operator->();



[endsect]



[section:point_type segment_iterator::point_type]

[indexterm2 point_type..segment_iterator] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:pointer segment_iterator::pointer]

[indexterm2 pointer..segment_iterator] 

  typedef segment_type * pointer;



[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:reference segment_iterator::reference]

[indexterm2 reference..segment_iterator] 

  typedef segment_type & reference;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.segment [*segment]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.first [*first]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment.second [*second]]]
    []
  ]

]

[heading Typedef Description]
    
From Wikipedia: In [link boost_geometry.reference.boost__geometry `boost::geometry`], a line [link boost_geometry.reference.segment `segment`] is a part of a line that is bounded by two distinct end points, and contains every [link boost_geometry.reference.point `point`] on the line between its end points. 

[heading Remarks]
      
The structure is like std::pair, and can often be used interchangeable. Difference is that it refers to points, does not have points. 

Like std::pair, points are public available. 

type is const or non const, so geometry::segment<P> or geometry::segment<const P> 

We cannot derive from std::pair<P&, P&> because of reference assignments. 



[variablelist
  
[[ConstOrNonConstPoint][[link boost_geometry.reference.point `point`] type of the [link boost_geometry.reference.segment `segment`], maybe a [link boost_geometry.reference.point `point`] or a const [link boost_geometry.reference.point `point`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:segment_iterator segment_iterator::segment_iterator]

[indexterm2 segment_iterator..segment_iterator] 

  explicit ``[link boost_geometry.reference.segment_iterator.segment_iterator.overload1 segment_iterator]``(
      Base const & end);
  ``  [''''&raquo;''' [link boost_geometry.reference.segment_iterator.segment_iterator.overload1 more...]]``

  ``[link boost_geometry.reference.segment_iterator.segment_iterator.overload2 segment_iterator]``(
      Base const & it,
      Base const & end);
  ``  [''''&raquo;''' [link boost_geometry.reference.segment_iterator.segment_iterator.overload2 more...]]``


[section:overload1 segment_iterator::segment_iterator (1 of 2 overloads)]



  segment_iterator(
      Base const & end);



[endsect]



[section:overload2 segment_iterator::segment_iterator (2 of 2 overloads)]



  segment_iterator(
      Base const & it,
      Base const & end);



[endsect]


[endsect]


[section:segment_type segment_iterator::segment_type]

[indexterm2 segment_type..segment_iterator] 

  typedef geometry::segment< Point > segment_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.segment [*segment]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.first [*first]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment.second [*second]]]
    []
  ]

]

[heading Typedef Description]
    
From Wikipedia: In [link boost_geometry.reference.boost__geometry `boost::geometry`], a line [link boost_geometry.reference.segment `segment`] is a part of a line that is bounded by two distinct end points, and contains every [link boost_geometry.reference.point `point`] on the line between its end points. 

[heading Remarks]
      
The structure is like std::pair, and can often be used interchangeable. Difference is that it refers to points, does not have points. 

Like std::pair, points are public available. 

type is const or non const, so geometry::segment<P> or geometry::segment<const P> 

We cannot derive from std::pair<P&, P&> because of reference assignments. 



[variablelist
  
[[ConstOrNonConstPoint][[link boost_geometry.reference.point `point`] type of the [link boost_geometry.reference.segment `segment`], maybe a [link boost_geometry.reference.point `point`] or a const [link boost_geometry.reference.point `point`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:value_type segment_iterator::value_type]

[indexterm2 value_type..segment_iterator] 

  typedef segment_type value_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.segment [*segment]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.first [*first]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment.second [*second]]]
    []
  ]

]

[heading Typedef Description]
    
From Wikipedia: In [link boost_geometry.reference.boost__geometry `boost::geometry`], a line [link boost_geometry.reference.segment `segment`] is a part of a line that is bounded by two distinct end points, and contains every [link boost_geometry.reference.point `point`] on the line between its end points. 

[heading Remarks]
      
The structure is like std::pair, and can often be used interchangeable. Difference is that it refers to points, does not have points. 

Like std::pair, points are public available. 

type is const or non const, so geometry::segment<P> or geometry::segment<const P> 

We cannot derive from std::pair<P&, P&> because of reference assignments. 



[variablelist
  
[[ConstOrNonConstPoint][[link boost_geometry.reference.point `point`] type of the [link boost_geometry.reference.segment `segment`], maybe a [link boost_geometry.reference.point `point`] or a const [link boost_geometry.reference.point `point`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/iterators/segment_iterator.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:segment_tag segment_tag]


Convenience [link boost_geometry.reference.segment `segment`] (2-points) identifying [link boost_geometry.reference.tag `tag`]. 




[heading Synopsis]
  struct segment_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:select_calculation_type select_calculation_type]


Meta-function selecting the "calculation" type. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.Geometry1 Geometry1]``,
      typename ``[link boost_geometry.reference.Geometry2 Geometry2]``,
      typename ``[link boost_geometry.reference.CalculationType CalculationType]``>
  struct select_calculation_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_calculation_type.type [*type]]]
    []
  
  ]

]


[heading Description]

Based on two input [link boost_geometry.reference.boost__geometry `boost::geometry`] types, and an input calculation type, (which defaults to void in the calling function), this meta-function selects the most appropriate:
* if calculation type is specified, that one is used,

* if it is void, the most precise of the two points is used 



[heading Requirements]

[*Header: ][^boost/geometry/util/select_calculation_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type select_calculation_type::type]

[indexterm2 type..select_calculation_type] 

  typedef boost::mpl::if_c< boost::is_void< CalculationType >::type::value, typename select_coordinate_type< Geometry1, Geometry2 >::type, CalculationType >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/util/select_calculation_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:select_coordinate_type select_coordinate_type]


Meta-function selecting the most precise coordinate type of two geometries. 




[heading Synopsis]
  template<
      typename T1,
      typename ``[link boost_geometry.reference.T2 T2]``>
  struct select_coordinate_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/util/select_coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type select_coordinate_type::type]

[indexterm2 type..select_coordinate_type] 

  typedef select_most_precise< typename coordinate_type< T1 >::type, typename coordinate_type< T2 >::type >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_most_precise.type [*type]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.select_most_precise.both_same [*both_same]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.one_not_fundamental [*one_not_fundamental]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.second_larger [*second_larger]]]
    []
  ]

]

[heading Typedef Description]
    
[link boost_geometry.reference.select_most_precise `select_most_precise`] classes, compares two types on compile time. For example, if an addition must be done with a double and an integer, the result must be a double. If both types are integer, the result can be an integer. 

[heading Remarks]
      
It is different from the "promote" class, already in `boost`. That class promotes e.g. a (one) float to a double. This class selects a type from two types. It takes the most accurate, but does not promote afterwards. 

This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

If the input is a non-fundamental type, it might be a calculation type such as a GMP-value or another high precision value. Therefore, if one is non-fundamental, that one is chosen. 

If both types are non-fundamental, the result is indeterminate and currently the first one is chosen. 




[heading Requirements]

[*Header: ][^boost/geometry/util/select_coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:select_most_precise select_most_precise]


Meta-function to select, of two types, the most accurate type for calculations. 




[heading Synopsis]
  template<
      typename T1,
      typename ``[link boost_geometry.reference.T2 T2]``>
  struct select_most_precise

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_most_precise.type [*type]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.select_most_precise.both_same [*both_same]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.one_not_fundamental [*one_not_fundamental]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.second_larger [*second_larger]]]
    []
  ]

]


[heading Description]

[link boost_geometry.reference.select_most_precise `select_most_precise`] classes, compares two types on compile time. For example, if an addition must be done with a double and an integer, the result must be a double. If both types are integer, the result can be an integer. 

[heading Remarks]
      
It is different from the "promote" class, already in `boost`. That class promotes e.g. a (one) float to a double. This class selects a type from two types. It takes the most accurate, but does not promote afterwards. 

This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

If the input is a non-fundamental type, it might be a calculation type such as a GMP-value or another high precision value. Therefore, if one is non-fundamental, that one is chosen. 

If both types are non-fundamental, the result is indeterminate and currently the first one is chosen. 



[heading Requirements]

[*Header: ][^boost/geometry/util/select_most_precise.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:both_same select_most_precise::both_same]

[indexterm2 both_same..select_most_precise] 

  static const bool both_same =
        boost::is_floating_point<T1>::type::value
        == boost::is_floating_point<T2>::type::value;



[endsect]



[section:one_not_fundamental select_most_precise::one_not_fundamental]

[indexterm2 one_not_fundamental..select_most_precise] 

  static const bool one_not_fundamental = !
        (boost::is_fundamental<T1>::type::value
          && boost::is_fundamental<T2>::type::value);



[endsect]



[section:second_larger select_most_precise::second_larger]

[indexterm2 second_larger..select_most_precise] 

  static const bool second_larger = sizeof(T2) > sizeof(T1);



[endsect]



[section:type select_most_precise::type]

[indexterm2 type..select_most_precise] 

  typedef boost::mpl::if_c< one_not_fundamental, typename detail::select_most_precise::select_non_fundamental< boost::is_fundamental< T1 >::type::value, boost::is_fundamental< T2 >::type::value, T1, T2 >::type, typename boost::mpl::if_c< both_same, typename detail::select_most_precise::select_largest< second_larger, T1, T2 >::type, typename detail::select_most_precise::select_floating_point< boost::is_floating_point< T1 >::type::value, boost::is_floating_point< T2 >::type::value, T1, T2 >::type >::type >::type type;



[heading Requirements]

[*Header: ][^boost/geometry/util/select_most_precise.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:set set]

[indexterm1 set] 
set coordinate value of a Point ( / Sphere) 

    
  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void ``[link boost_geometry.reference.set.overload1 set]``(
      Geometry & geometry,
      typename coordinate_type< Geometry >::type const & value);
  ``  [''''&raquo;''' [link boost_geometry.reference.set.overload1 more...]]``

  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void ``[link boost_geometry.reference.set.overload2 set]``(
      Geometry & geometry,
      typename coordinate_type< Geometry >::type const & value);
  ``  [''''&raquo;''' [link boost_geometry.reference.set.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 set (1 of 2 overloads)]


set coordinate value of a Point ( / Sphere) 


  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void set(
      Geometry & geometry,
      typename coordinate_type< Geometry >::type const & value);




[variablelist
  
[[Dimension][[link boost_geometry.reference.dimension `dimension`] ]]

[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to assign coordinate to ]]

[[value][coordinate value to assign ]]

]




[endsect]



[section:overload2 set (2 of 2 overloads)]


set coordinate value of a Box / Segment 


  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void set(
      Geometry & geometry,
      typename coordinate_type< Geometry >::type const & value);




[variablelist
  
[[Index][for Point: do not specifyfor Box: min\_corner or max\_cornerfor Segment: 0 / 1 
]]

[[Dimension][[link boost_geometry.reference.dimension `dimension`] ]]

[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to assign coordinate to ]]

[[value][coordinate value to assign ]]

]




[endsect]


[endsect]


[section:set_from_radian set_from_radian]

[indexterm1 set_from_radian] 
set coordinate value (in [link boost_geometry.reference.radian `radian`]) to a [link boost_geometry.reference.point `point`] 


  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void set_from_radian(
      Geometry & geometry,
      const typename coordinate_type< Geometry >::type & radians);


Coordinate value will be set correctly, if coordinate system of [link boost_geometry.reference.point `point`] is in Degree, Radian value will be converted to Degree



[variablelist
  
[[Dimension][[link boost_geometry.reference.dimension `dimension`] ]]

[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] to assign coordinate to ]]

[[radians][coordinate value to assign ]]

]



[heading Remarks]
      
Only applicable to coordinate systems templatized by units, e.g. spherical or geographic coordinate systems 



[heading Requirements]

[*Header: ][^boost/geometry/core/radian_access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:side_info side_info]


Class [link boost_geometry.reference.side_info `side_info`]: small class wrapping for sides (-1,0,1). 




[heading Synopsis]
  class side_info

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.side_info.as_collinear [*as_collinear]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.side_info.collinear [*collinear]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.side_info.get [*get]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.side_info.reverse [*reverse]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.side_info.same [*same]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.side_info.set [*set]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.side_info.side_info [*side_info]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/side_info.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:as_collinear side_info::as_collinear]

[indexterm2 as_collinear..side_info] 

  bool as_collinear() const;



[endsect]



[section:collinear side_info::collinear]

[indexterm2 collinear..side_info] 

  bool collinear() const;



[endsect]



[section:get side_info::get]

[indexterm2 get..side_info] 

  template<
      int ``[link boost_geometry.reference.Which Which]``,
      int ``[link boost_geometry.reference.Index Index]``>
  int get() const;



[endsect]



[section:reverse side_info::reverse]

[indexterm2 reverse..side_info] 

  void reverse();



[endsect]



[section:same side_info::same]

[indexterm2 same..side_info] 

  template<
      int ``[link boost_geometry.reference.Which Which]``>
  bool same() const;



[endsect]



[section:set side_info::set]

[indexterm2 set..side_info] 

  template<
      int ``[link boost_geometry.reference.Which Which]``>
  void set(
      int first,
      int second);



[endsect]



[section:side_info side_info::side_info]

[indexterm2 side_info..side_info] 

  side_info(
      int side_a1 = 0,
      int side_a2 = 0,
      int side_b1 = 0,
      int side_b2 = 0);



[endsect]



[endsect]

[section:simplify simplify]

[indexterm1 simplify] 
      
  template<
      typename Geometry ,
      typename Strategy >
  void ``[link boost_geometry.reference.simplify.overload1 simplify]``(
      Geometry const & geometry,
      Geometry & out,
      double max_distance,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.simplify.overload1 more...]]``

  template<
      typename Geometry >
  void ``[link boost_geometry.reference.simplify.overload2 simplify]``(
      Geometry const & geometry,
      Geometry & out,
      double max_distance);
  ``  [''''&raquo;''' [link boost_geometry.reference.simplify.overload2 more...]]``


[heading Source description:]
  

* Wikipedia: given a 'curve' composed of line segments to find a curve not too dissimilar but that has fewer points





[heading Performance]
  

* Performance is measured on simplification of a collection of rings, such that 10% of the points is kept.

* 2776 counties of US are simplified in 0.7 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Simplify1)




[heading Geometries]
  

* linestring: 
 This US Road originally contained 34 points, the simplified version contains 7 points




* polygon: 
 This country (Belgium) originally contained 55 points, the simplified version contains 24 points





[heading Remarks]
      
simplifying a valid simple polygon (which never intersects itself) might result in an invalid polygon, where the simplified rings intersect themselves or one of the other outer or inner rings. Efficient simplification of a ring/polygon is still an "Open Problem" (http://maven.smith.edu/~orourke/TOPP/P24.html#Problem.24)


* multi_linestring 

* multi_polygon 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/simplify.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 simplify (1 of 2 overloads)]


Simplify a [link boost_geometry.reference.boost__geometry `boost::geometry`] using a specified [link boost_geometry.reference.strategy `strategy`]. 


  template<
      typename Geometry ,
      typename Strategy >
  void simplify(
      Geometry const & geometry,
      Geometry & out,
      double max_distance,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry][input [link boost_geometry.reference.boost__geometry `boost::geometry`], to be simplified ]]

[[out][output [link boost_geometry.reference.boost__geometry `boost::geometry`], simplified version of the input [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[max_distance][distance (in units of input coordinates) of a vertex to other segments to be removed ]]

[[strategy][simplify [link boost_geometry.reference.strategy `strategy`] to be used for simplification, might include point-distance [link boost_geometry.reference.strategy `strategy`] ]]

]




[endsect]



[section:overload2 simplify (2 of 2 overloads)]


Simplify a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry >
  void simplify(
      Geometry const & geometry,
      Geometry & out,
      double max_distance);




[heading Remarks]
      
This version of simplify simplifies a [link boost_geometry.reference.boost__geometry `boost::geometry`] using the default [link boost_geometry.reference.strategy `strategy`] (Douglas Peucker), 


[heading Parameters]
    

[variablelist
  
[[geometry][input [link boost_geometry.reference.boost__geometry `boost::geometry`], to be simplified ]]

[[out][output [link boost_geometry.reference.boost__geometry `boost::geometry`], simplified version of the input [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[max_distance][distance (in units of input coordinates) of a vertex to other segments to be removed ]]

]


[heading Example:]
  
The simplify algorithm can be used as following:  








[endsect]


[endsect]

[section:simplify_inserter simplify_inserter]

[indexterm1 simplify_inserter] 
Simplify a [link boost_geometry.reference.boost__geometry `boost::geometry`], using an output iterator and a specified [link boost_geometry.reference.strategy `strategy`]. 

    
  template<
      typename Geometry ,
      typename OutputIterator ,
      typename Strategy >
  void ``[link boost_geometry.reference.simplify_inserter.overload1 simplify_inserter]``(
      Geometry const & geometry,
      OutputIterator out,
      double max_distance,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.simplify_inserter.overload1 more...]]``

  template<
      typename Geometry ,
      typename OutputIterator >
  void ``[link boost_geometry.reference.simplify_inserter.overload2 simplify_inserter]``(
      Geometry const & geometry,
      OutputIterator out,
      double max_distance);
  ``  [''''&raquo;''' [link boost_geometry.reference.simplify_inserter.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/simplify.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 simplify_inserter (1 of 2 overloads)]


Simplify a [link boost_geometry.reference.boost__geometry `boost::geometry`], using an output iterator and a specified [link boost_geometry.reference.strategy `strategy`]. 


  template<
      typename Geometry ,
      typename OutputIterator ,
      typename Strategy >
  void simplify_inserter(
      Geometry const & geometry,
      OutputIterator out,
      double max_distance,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry][input [link boost_geometry.reference.boost__geometry `boost::geometry`], to be simplified ]]

[[out][output iterator, outputs all simplified points ]]

[[max_distance][distance (in units of input coordinates) of a vertex to other segments to be removed ]]

[[strategy][simplify [link boost_geometry.reference.strategy `strategy`] to be used for simplification, might include point-distance [link boost_geometry.reference.strategy `strategy`] ]]

]


[heading Example:]
  
simplify\_inserter with [link boost_geometry.reference.strategy `strategy`] is used as following:  








[endsect]



[section:overload2 simplify_inserter (2 of 2 overloads)]


Simplify a [link boost_geometry.reference.boost__geometry `boost::geometry`], using an output iterator. 


  template<
      typename Geometry ,
      typename OutputIterator >
  void simplify_inserter(
      Geometry const & geometry,
      OutputIterator out,
      double max_distance);



[heading Parameters]
    

[variablelist
  
[[geometry][input [link boost_geometry.reference.boost__geometry `boost::geometry`], to be simplified ]]

[[out][output iterator, outputs all simplified points ]]

[[max_distance][distance (in units of input coordinates) of a vertex to other segments to be removed ]]

]




[endsect]


[endsect]

[section:spherical_tag spherical_tag]


Tag indicating Spherical coordinate system family (spherical,celestial,...). 




[heading Synopsis]
  struct spherical_tag

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy__area__by_triangles strategy::area::by_triangles]


Strategy functor for [link boost_geometry.reference.strategy__area `strategy::area`] calculation on [link boost_geometry.reference.point_xy `point_xy`] points. 




[heading Synopsis]
  template<
      typename PointOfSegment ,
      typename CalculationType  = void>
  class by_triangles

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__area__by_triangles.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__area__by_triangles.segment_point_type [*segment_point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__area__by_triangles.state_type [*state_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__area__by_triangles.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__area__by_triangles.result [*result]]]
    []
  ]
  
]


[heading Description]

Calculates [link boost_geometry.reference.strategy__area `strategy::area`] using well-known triangulation algorithm 

[variablelist
  
[[PointOfSegment][[link boost_geometry.reference.point `point`] type of segments ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/area_by_triangles.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::area::by_triangles::apply]

[indexterm2 apply..strategy::area::by_triangles] 

  static void apply(
      PointOfSegment const & p1,
      PointOfSegment const & p2,
      summation & state);



[endsect]



[section:result strategy::area::by_triangles::result]

[indexterm2 result..strategy::area::by_triangles] 

  static return_type result(
      summation const & state);



[endsect]



[section:return_type strategy::area::by_triangles::return_type]

[indexterm2 return_type..strategy::area::by_triangles] 

  typedef boost::mpl::if_c< boost::is_void< CalculationType >::type::value, typename select_most_precise< typename coordinate_type< PointOfSegment >::type, double >::type, CalculationType >::type return_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_most_precise.type [*type]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.select_most_precise.both_same [*both_same]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.one_not_fundamental [*one_not_fundamental]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.second_larger [*second_larger]]]
    []
  ]

]

[heading Typedef Description]
    
[link boost_geometry.reference.select_most_precise `select_most_precise`] classes, compares two types on compile time. For example, if an addition must be done with a double and an integer, the result must be a double. If both types are integer, the result can be an integer. 

[heading Remarks]
      
It is different from the "promote" class, already in `boost`. That class promotes e.g. a (one) float to a double. This class selects a type from two types. It takes the most accurate, but does not promote afterwards. 

This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

If the input is a non-fundamental type, it might be a calculation type such as a GMP-value or another high precision value. Therefore, if one is non-fundamental, that one is chosen. 

If both types are non-fundamental, the result is indeterminate and currently the first one is chosen. 




[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/area_by_triangles.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_point_type strategy::area::by_triangles::segment_point_type]

[indexterm2 segment_point_type..strategy::area::by_triangles] 

  typedef PointOfSegment segment_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/area_by_triangles.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:state_type strategy::area::by_triangles::state_type]

[indexterm2 state_type..strategy::area::by_triangles] 

  typedef summation state_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__area__by_triangles__summation.area [*area]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__area__by_triangles__summation.summation [*summation]]]
    []
  ]
  
]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/area_by_triangles.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__area__by_triangles__summation strategy::area::by_triangles::summation]





[heading Synopsis]
  class summation

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__area__by_triangles__summation.area [*area]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__area__by_triangles__summation.summation [*summation]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/area_by_triangles.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:area strategy::area::by_triangles::summation::area]

[indexterm2 area..strategy::area::by_triangles::summation] 

  return_type area() const;



[endsect]



[section:summation strategy::area::by_triangles::summation::summation]

[indexterm2 summation..strategy::area::by_triangles::summation] 

  summation();



[endsect]



[endsect]

[section:strategy__area__huiller strategy::area::huiller]


Area calculation by spherical excess / Huiller's formula. 




[heading Synopsis]
  template<
      typename PointOfSegment ,
      typename CalculationType  = void>
  class huiller

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__area__huiller.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__area__huiller.segment_point_type [*segment_point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__area__huiller.state_type [*state_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__area__huiller.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__area__huiller.huiller [*huiller]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__area__huiller.result [*result]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P][type of points of rings/polygons ]]

]


Barend Gehrels. Adapted from:
* http://www.soe.ucsc.edu/~pang/160/f98/Gems/GemsIV/sph_poly.c

* http://williams.best.vwh.net/avform.htm 





[heading Remarks]
      
The version in Gems didn't account for polygons crossing the 180 meridian. 

This version works for convex and non-convex polygons, for 180 meridian crossing polygons and for polygons with holes. However, some cases (especially 180 meridian cases) must still be checked. 

The version which sums angles, which is often seen, doesn't handle non-convex polygons correctly. 

The version which sums longitudes, see http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/1/07-03.pdf, is simple and works well in most cases but not in 180 meridian crossing cases. This probably could be solved. 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/area_huiller.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::area::huiller::apply]

[indexterm2 apply..strategy::area::huiller] 

  void apply(
      PointOfSegment const & p1,
      PointOfSegment const & p2,
      excess_sum & state) const;



[endsect]



[section:huiller strategy::area::huiller::huiller]

[indexterm2 huiller..strategy::area::huiller] 

  huiller(
      double radius = 1.0);



[endsect]



[section:result strategy::area::huiller::result]

[indexterm2 result..strategy::area::huiller] 

  return_type result(
      excess_sum const & state) const;



[endsect]



[section:return_type strategy::area::huiller::return_type]

[indexterm2 return_type..strategy::area::huiller] 

  typedef double return_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/area_huiller.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_point_type strategy::area::huiller::segment_point_type]

[indexterm2 segment_point_type..strategy::area::huiller] 

  typedef PointOfSegment segment_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/area_huiller.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:state_type strategy::area::huiller::state_type]

[indexterm2 state_type..strategy::area::huiller] 

  typedef excess_sum state_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__area__huiller__excess_sum.area [*area]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__area__huiller__excess_sum.excess_sum [*excess_sum]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__area__huiller__excess_sum.distance_over_unit_sphere [*distance_over_unit_sphere]]]
    []
  ]

  [
    [[link boost_geometry.reference.strategy__area__huiller__excess_sum.sum [*sum]]]
    []
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/area_huiller.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__area__huiller__excess_sum strategy::area::huiller::excess_sum]





[heading Synopsis]
  struct excess_sum

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__area__huiller__excess_sum.area [*area]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__area__huiller__excess_sum.excess_sum [*excess_sum]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__area__huiller__excess_sum.distance_over_unit_sphere [*distance_over_unit_sphere]]]
    []
  ]

  [
    [[link boost_geometry.reference.strategy__area__huiller__excess_sum.sum [*sum]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/area_huiller.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:area strategy::area::huiller::excess_sum::area]

[indexterm2 area..strategy::area::huiller::excess_sum] 

  double area(
      double radius) const;



[endsect]



[section:distance_over_unit_sphere strategy::area::huiller::excess_sum::distance_over_unit_sphere]

[indexterm2 distance_over_unit_sphere..strategy::area::huiller::excess_sum] 

  strategy::distance::haversine< PointOfSegment, PointOfSegment > distance_over_unit_sphere;



[endsect]



[section:excess_sum strategy::area::huiller::excess_sum::excess_sum]

[indexterm2 excess_sum..strategy::area::huiller::excess_sum] 

  excess_sum();



[endsect]



[section:sum strategy::area::huiller::excess_sum::sum]

[indexterm2 sum..strategy::area::huiller::excess_sum] 

  double sum;



[endsect]



[endsect]

[section:strategy__buffer__join_bevel strategy::buffer::join_bevel]





[heading Synopsis]
  template<
      typename PointIn ,
      typename PointOut >
  struct join_bevel

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__buffer__join_bevel.apply [*apply]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/buffer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::buffer::join_bevel::apply]

[indexterm2 apply..strategy::buffer::join_bevel] 

  template<
      typename Ring >
  void apply(
      PointIn const & ip,
      PointIn const & vertex,
      PointIn const & perp1,
      PointIn const & perp2,
      double buffer_distance,
      Ring & buffered) const;



[endsect]



[endsect]

[section:strategy__buffer__join_miter strategy::buffer::join_miter]





[heading Synopsis]
  template<
      typename PointIn ,
      typename PointOut >
  struct join_miter

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__buffer__join_miter.coordinate_type [*coordinate_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__buffer__join_miter.side [*side]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__buffer__join_miter.apply [*apply]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/buffer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::buffer::join_miter::apply]

[indexterm2 apply..strategy::buffer::join_miter] 

  template<
      typename Ring >
  void apply(
      PointIn const & ip,
      PointIn const & vertex,
      PointIn const & perp1,
      PointIn const & perp2,
      double buffer_distance,
      Ring & buffered) const;



[endsect]



[section:coordinate_type strategy::buffer::join_miter::coordinate_type]

[indexterm2 coordinate_type..strategy::buffer::join_miter] 

  typedef coordinate_type< PointIn >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.coordinate_type.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/buffer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:side strategy::buffer::join_miter::side]

[indexterm2 side..strategy::buffer::join_miter] 

  typedef strategy_side< typename cs_tag< PointIn >::type >::type side;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_side.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    


[variablelist
  
[[Tag][[link boost_geometry.reference.tag `tag`] of coordinate system of point-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/strategies/buffer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__buffer__join_round strategy::buffer::join_round]





[heading Synopsis]
  template<
      typename PointIn ,
      typename PointOut >
  struct join_round

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__buffer__join_round.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__buffer__join_round.join_round [*join_round]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__buffer__join_round.mid_points [*mid_points]]]
    []
  ]
  
]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__buffer__join_round.m_max_level [*m_max_level]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/buffer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::buffer::join_round::apply]

[indexterm2 apply..strategy::buffer::join_round] 

  template<
      typename Ring >
  void apply(
      PointIn const & ip,
      PointIn const & vertex,
      PointIn const & perp1,
      PointIn const & perp2,
      double buffer_distance,
      Ring & buffered) const;



[endsect]



[section:join_round strategy::buffer::join_round::join_round]

[indexterm2 join_round..strategy::buffer::join_round] 

  join_round(
      int max_level = 4);



[endsect]



[section:m_max_level strategy::buffer::join_round::m_max_level]

[indexterm2 m_max_level..strategy::buffer::join_round] 

  int m_max_level;



[endsect]



[section:mid_points strategy::buffer::join_round::mid_points]

[indexterm2 mid_points..strategy::buffer::join_round] 

  template<
      typename Ring >
  void mid_points(
      PointIn const & vertex,
      PointIn const & p1,
      PointIn const & p2,
      double buffer_distance,
      Ring & buffered,
      int level = 1) const;



[endsect]



[endsect]

[section:strategy__centroid___bashein_detmer strategy::centroid_::bashein_detmer]


Centroid calculation using algorith Bashein / Detmer. 




[heading Synopsis]
  template<
      typename Point ,
      typename PointOfSegment  = Point,
      typename CalculationType  = void>
  class bashein_detmer

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__centroid___bashein_detmer.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__centroid___bashein_detmer.segment_point_type [*segment_point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__centroid___bashein_detmer.state_type [*state_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__centroid___bashein_detmer.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__centroid___bashein_detmer.result [*result]]]
    []
  ]
  
]


[heading Description]

Calculates centroid using triangulation method published by Bashein / Detmer 

[variablelist
  
[[Point][[link boost_geometry.reference.point `point`] type of centroid to calculate ]]

[[PointOfSegment][[link boost_geometry.reference.point `point`] type of segments, defaults to Point ]]

]


[heading Concepts for Point and PointOfSegment:]
  

* specialized point_traits class 




Adapted from "Centroid of a Polygon" by Gerard Bashein and Paul R. Detmer[*, in "Graphics Gems IV", Academic Press, 1994] 


[heading Research notes]
  
The algorithm gives the same results as Oracle and PostGIS but differs from MySQL (tried 5.0.21 / 5.0.45 / 5.0.51a / 5.1.23).

Without holes:
* this: POINT(4.06923363095238 1.65055803571429)

* geolib: POINT(4.07254 1.66819)

* MySQL: POINT(3.6636363636364 1.6272727272727)'

* PostGIS: POINT(4.06923363095238 1.65055803571429)

* Oracle: 4.06923363095238 1.65055803571429

* SQL Server: POINT(4.06923362245959 1.65055804168294)



Statements:
* MySQL/PostGIS: select AsText(Centroid(GeomFromText( 'POLYGON((2 1.3,2.4 1.7,2.8 1.8,3.4 1.2,3.7 1.6,3.4 2,4.1 3,5.3 2.6 ,5.4 1.2,4.9 0.8,2.9 0.7,2 1.3))')))

* Oracle: select sdo_geom.sdo_centroid(sdo_geometry(2003, null, null, sdo_elem_info_array(1, 1003, 1), sdo_ordinate_array( 2,1.3,2.4,1.7,2.8,1.8,3.4,1.2,3.7,1.6,3.4,2,4.1,3,5.3,2.6 ,5.4,1.2,4.9,0.8,2.9,0.7,2,1.3)) , mdsys.sdo_dim_array(mdsys.sdo_dim_element('x',0,10,.00000005) ,mdsys.sdo_dim_element('y',0,10,.00000005))) from dual

* SQL Server 2008: select geometry::STGeomFromText( 'POLYGON((2 1.3,2.4 1.7,2.8 1.8,3.4 1.2,3.7 1.6,3.4 2,4.1 3,5.3 2.6 ,5.4 1.2,4.9 0.8,2.9 0.7,2 1.3))',0) .STCentroid() .STAsText()



With holes:
* this: POINT(4.04663 1.6349)

* geolib: POINT(4.04675 1.65735)

* MySQL: POINT(3.6090580503834 1.607573932092)

* PostGIS: POINT(4.0466265060241 1.63489959839357)

* Oracle: 4.0466265060241 1.63489959839357

* SQL Server: POINT(4.0466264962959677 1.6348996057331333)



Statements:
* MySQL/PostGIS: select AsText(Centroid(GeomFromText( 'POLYGON((2 1.3,2.4 1.7,2.8 1.8,3.4 1.2 ,3.7 1.6,3.4 2,4.1 3,5.3 2.6,5.4 1.2,4.9 0.8,2.9 0.7,2 1.3) ,(4 2,4.2 1.4,4.8 1.9,4.4 2.2,4 2))')));

* Oracle: select sdo_geom.sdo_centroid(sdo_geometry(2003, null, null , sdo_elem_info_array(1, 1003, 1, 25, 2003, 1) , sdo_ordinate_array(2,1.3,2.4,1.7,2.8,1.8,3.4,1.2,3.7,1.6,3.4, 2,4.1,3,5.3,2.6,5.4,1.2,4.9,0.8,2.9,0.7,2,1.3,4,2, 4.2,1.4, 4.8,1.9, 4.4,2.2, 4,2)) , mdsys.sdo_dim_array(mdsys.sdo_dim_element('x',0,10,.00000005) ,mdsys.sdo_dim_element('y',0,10,.00000005))) from dual 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/centroid_bashein_detmer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::centroid_::bashein_detmer::apply]

[indexterm2 apply..strategy::centroid_::bashein_detmer] 

  static void apply(
      PointOfSegment const & p1,
      PointOfSegment const & p2,
      sums & state);



[endsect]



[section:point_type strategy::centroid_::bashein_detmer::point_type]

[indexterm2 point_type..strategy::centroid_::bashein_detmer] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/centroid_bashein_detmer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:result strategy::centroid_::bashein_detmer::result]

[indexterm2 result..strategy::centroid_::bashein_detmer] 

  static bool result(
      sums const & state,
      Point & centroid);



[endsect]



[section:segment_point_type strategy::centroid_::bashein_detmer::segment_point_type]

[indexterm2 segment_point_type..strategy::centroid_::bashein_detmer] 

  typedef PointOfSegment segment_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/centroid_bashein_detmer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:state_type strategy::centroid_::bashein_detmer::state_type]

[indexterm2 state_type..strategy::centroid_::bashein_detmer] 

  typedef sums state_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__centroid___bashein_detmer__sums.sums [*sums]]]
    []
  ]
  
]

[heading Typedef Description]
    
subclass to keep state 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/centroid_bashein_detmer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__centroid___bashein_detmer__sums strategy::centroid_::bashein_detmer::sums]





[heading Synopsis]
  class sums

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__centroid___bashein_detmer__sums.sums [*sums]]]
    []
  ]
  
]


[heading Description]

subclass to keep state 

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/centroid_bashein_detmer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:sums strategy::centroid_::bashein_detmer::sums::sums]

[indexterm2 sums..strategy::centroid_::bashein_detmer::sums] 

  sums();



[endsect]



[endsect]

[section:strategy__compare__circular_comparator strategy::compare::circular_comparator]


Compare (in one direction) [link boost_geometry.reference.strategy `strategy`] for spherical coordinates. 




[heading Synopsis]
  template<
      typename CoordinateType ,
      typename Units ,
      typename Compare >
  struct circular_comparator

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__compare__circular_comparator.operator() [*operator()]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__compare__circular_comparator.put_in_range [*put_in_range]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[Point][point-type ]]

[[Dimension][[link boost_geometry.reference.dimension `dimension`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/compare_circular.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:operator() strategy::compare::circular_comparator::operator()]

[indexterm2 operator()..strategy::compare::circular_comparator] 

  bool operator()(
      CoordinateType const & c1,
      CoordinateType const & c2) const;



[endsect]



[section:put_in_range strategy::compare::circular_comparator::put_in_range]

[indexterm2 put_in_range..strategy::compare::circular_comparator] 

  static CoordinateType put_in_range(
      CoordinateType const & c,
      double min_border,
      double max_border);



[endsect]



[endsect]

[section:strategy__compare__default_strategy strategy::compare::default_strategy]


Default [link boost_geometry.reference.strategy `strategy`], indicates the default [link boost_geometry.reference.strategy `strategy`] for comparisons. 




[heading Synopsis]
  struct default_strategy

[heading Description]

The default [link boost_geometry.reference.strategy `strategy`] for comparisons defer in most cases to std::less (for ascending) and std::greater (for descending). However, if a spherical coordinate system is used, and comparison is done on longitude, it will take another [link boost_geometry.reference.strategy `strategy`] handling circular 

[heading Requirements]

[*Header: ][^boost/geometry/strategies/compare.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy__convex_hull__graham_andrew strategy::convex_hull::graham_andrew]


Graham scan [link boost_geometry.reference.strategy `strategy`] to calculate convex hull. 




[heading Synopsis]
  template<
      typename InputGeometry ,
      typename OutputPoint >
  class graham_andrew

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__convex_hull__graham_andrew.geometry_type [*geometry_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__convex_hull__graham_andrew.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__convex_hull__graham_andrew.state_type [*state_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__convex_hull__graham_andrew.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__convex_hull__graham_andrew.result [*result]]]
    []
  ]
  
]


[heading Description]



[heading Remarks]
      
Completely reworked version inspired on the sources listed below 




[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/hull_graham_andrew.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::convex_hull::graham_andrew::apply]

[indexterm2 apply..strategy::convex_hull::graham_andrew] 

  void apply(
      InputGeometry const & geometry,
      partitions & state) const;



[endsect]



[section:geometry_type strategy::convex_hull::graham_andrew::geometry_type]

[indexterm2 geometry_type..strategy::convex_hull::graham_andrew] 

  typedef InputGeometry geometry_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/hull_graham_andrew.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:point_type strategy::convex_hull::graham_andrew::point_type]

[indexterm2 point_type..strategy::convex_hull::graham_andrew] 

  typedef OutputPoint point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/hull_graham_andrew.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:result strategy::convex_hull::graham_andrew::result]

[indexterm2 result..strategy::convex_hull::graham_andrew] 

  template<
      typename OutputIterator >
  void result(
      partitions const & state,
      OutputIterator out,
      bool clockwise) const;



[endsect]



[section:state_type strategy::convex_hull::graham_andrew::state_type]

[indexterm2 state_type..strategy::convex_hull::graham_andrew] 

  typedef partitions state_type;


[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/hull_graham_andrew.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__convex_hull__graham_andrew__partitions strategy::convex_hull::graham_andrew::partitions]





[heading Synopsis]
  class partitions

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/hull_graham_andrew.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy__distance__cross_track strategy::distance::cross_track]


Strategy functor for [link boost_geometry.reference.strategy__distance `strategy::distance`] [link boost_geometry.reference.point `point`] to [link boost_geometry.reference.segment `segment`] calculation. 




[heading Synopsis]
  template<
      typename Point ,
      typename PointOfSegment >
  class cross_track

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__distance__cross_track.point_strategy_type [*point_strategy_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__cross_track.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__cross_track.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__cross_track.segment_point_type [*segment_point_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__distance__cross_track.BOOST_CONCEPT_ASSERT [*BOOST_CONCEPT_ASSERT]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__distance__cross_track.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__distance__cross_track.cross_track [*cross_track]]]
    []
  ]
  
]


[heading Description]

Class which calculates the [link boost_geometry.reference.strategy__distance `strategy::distance`] of a [link boost_geometry.reference.point `point`] to a [link boost_geometry.reference.segment `segment`], using latlong points 


[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[S][[link boost_geometry.reference.segment `segment`] type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/distance_cross_track.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:BOOST_CONCEPT_ASSERT strategy::distance::cross_track::BOOST_CONCEPT_ASSERT]

[indexterm2 BOOST_CONCEPT_ASSERT..strategy::distance::cross_track] 

  BOOST_CONCEPT_ASSERT(
      (geometry::concept::PointDistanceStrategy< point_strategy_type >) );



[endsect]



[section:apply strategy::distance::cross_track::apply]

[indexterm2 apply..strategy::distance::cross_track] 

  return_type apply(
      Point const & p,
      PointOfSegment const & sp1,
      PointOfSegment const & sp2) const;



[endsect]



[section:cross_track strategy::distance::cross_track::cross_track]

[indexterm2 cross_track..strategy::distance::cross_track] 

  cross_track(
      double r = 1.0);



[endsect]



[section:point_strategy_type strategy::distance::cross_track::point_strategy_type]

[indexterm2 point_strategy_type..strategy::distance::cross_track] 

  typedef strategy_distance< typename geometry::cs_tag< Point >::type, typename geometry::cs_tag< Point >::type, Point, Point >::type point_strategy_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_distance.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    


[variablelist
  
[[T1][[link boost_geometry.reference.tag `tag`] of coordinate system of first [link boost_geometry.reference.point `point`] type ]]

[[T2][[link boost_geometry.reference.tag `tag`] of coordinate system of second [link boost_geometry.reference.point `point`] type ]]

[[P1][first point-type ]]

[[P2][second point-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/distance_cross_track.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:point_type strategy::distance::cross_track::point_type]

[indexterm2 point_type..strategy::distance::cross_track] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/distance_cross_track.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:return_type strategy::distance::cross_track::return_type]

[indexterm2 return_type..strategy::distance::cross_track] 

  typedef double return_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/distance_cross_track.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_point_type strategy::distance::cross_track::segment_point_type]

[indexterm2 segment_point_type..strategy::distance::cross_track] 

  typedef PointOfSegment segment_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/distance_cross_track.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__distance__haversine strategy::distance::haversine]


Distance calculation for spherical coordinates on a perfect sphere using [link boost_geometry.reference.strategy__distance__haversine `strategy::distance::haversine`]. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.Point1 Point1]``,
      typename ``[link boost_geometry.reference.Point2 Point2]`` = Point1>
  class haversine

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__distance__haversine.first_point_type [*first_point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__haversine.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__haversine.second_point_type [*second_point_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__distance__haversine.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__distance__haversine.haversine [*haversine]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][optional second [link boost_geometry.reference.point `point`] type ]]

]


Adapted from: http://williams.best.vwh.net/avform.htm 




[heading Remarks]
      
It says: [*The great circle distance d between two points with coordinates {lat1,lon1} and {lat2,lon2} is given by: d=acos(sin(lat1)*sin(lat2)+cos(lat1)*cos(lat2)*cos(lon1-lon2)) A mathematically equivalent formula, which is less subject to rounding error for short distances is: d=2*asin(sqrt((sin((lat1-lat2)/2))^2 + cos(lat1)*cos(lat2)*(sin((lon1-lon2)/2))^2)) ] 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/distance_haversine.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::distance::haversine::apply]

[indexterm2 apply..strategy::distance::haversine] 

  return_type apply(
      Point1 const & p1,
      Point2 const & p2) const;



[endsect]



[section:first_point_type strategy::distance::haversine::first_point_type]

[indexterm2 first_point_type..strategy::distance::haversine] 

  typedef Point1 first_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/distance_haversine.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:haversine strategy::distance::haversine::haversine]

[indexterm2 haversine..strategy::distance::haversine] 

  haversine(
      double r = 1.0);



[endsect]



[section:return_type strategy::distance::haversine::return_type]

[indexterm2 return_type..strategy::distance::haversine] 

  typedef double return_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/distance_haversine.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:second_point_type strategy::distance::haversine::second_point_type]

[indexterm2 second_point_type..strategy::distance::haversine] 

  typedef Point2 second_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/distance_haversine.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__distance__projected_point strategy::distance::projected_point]


Strategy for [link boost_geometry.reference.strategy__distance `strategy::distance`] [link boost_geometry.reference.point `point`] to [link boost_geometry.reference.segment `segment`]. 




[heading Synopsis]
  template<
      typename Point ,
      typename PointOfSegment ,
      typename Strategy  = pythagoras <            Point,            typename point_type<PointOfSegment>::type        >>
  struct projected_point

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__distance__projected_point.coordinate_type [*coordinate_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__projected_point.point_strategy_type [*point_strategy_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__projected_point.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__projected_point.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__projected_point.segment_point_type [*segment_point_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__distance__projected_point.apply [*apply]]]
    []
  ]
  
]


[heading Description]

Calculates [link boost_geometry.reference.strategy__distance `strategy::distance`] using projected-point method, and (optionally) Pythagoras 
Adapted from: http://geometryalgorithms.com/Archive/algorithm\_0102/algorithm\_0102.htm 



[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

[[PointOfSegment][[link boost_geometry.reference.segment `segment`] type ]]

[[Strategy][[link boost_geometry.reference.strategy `strategy`], optional, defaults to [link boost_geometry.reference.strategy__distance__pythagoras `strategy::distance::pythagoras`] ]]

]


[heading Concepts for Strategy:]
  

* cartesian_distance operator(Point,Point) 





[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_projected_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::distance::projected_point::apply]

[indexterm2 apply..strategy::distance::projected_point] 

  return_type apply(
      Point const & p,
      PointOfSegment const & p1,
      PointOfSegment const & p2) const;



[endsect]



[section:coordinate_type strategy::distance::projected_point::coordinate_type]

[indexterm2 coordinate_type..strategy::distance::projected_point] 

  typedef select_coordinate_type< Point, PointOfSegment >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_projected_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:point_strategy_type strategy::distance::projected_point::point_strategy_type]

[indexterm2 point_strategy_type..strategy::distance::projected_point] 

  typedef Strategy point_strategy_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_projected_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:point_type strategy::distance::projected_point::point_type]

[indexterm2 point_type..strategy::distance::projected_point] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_projected_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:return_type strategy::distance::projected_point::return_type]

[indexterm2 return_type..strategy::distance::projected_point] 

  typedef cartesian_distance< coordinate_type > return_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.cartesian_distance.cartesian_distance [*cartesian_distance]]]
    [Constructor with a value. ]
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_cast_type [*operator cast_type]]]
    [Automatic conversion to double or higher precision, taking squareroot if necessary. ]
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_lt_ [*operator<]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_eq__eq_ [*operator==]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_gt_ [*operator>]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.squared_value [*squared_value]]]
    [The "squared\_value" method returns the internal squared value. ]
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.very_small [*very_small]]]
    []
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.cartesian_distance.operator_lt__lt_ [*operator<<]]]
    [Make streamable to enable std::cout << geometry::distance( ). ]
  ]
  
]

[heading Typedef Description]
    
Distance calculation for xy points or xyz points is done by taking the square root. However, for distance comparison drawing the square root is not necessary. Therefore the distance strategies are allowed to return the squares of the distance. This structure contains the distance, and a boolean to indicate if it is squared. It has an automatic conversion to a double value, which does the square root if necessary. 

[heading Remarks]
      
Thanks to Phil Endecott for his suggestion to change the pair to the double-convertable http://article.gmane.org/gmane.comp.lib.boost.devel/172709/match=greatcircle\_distance 




[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_projected_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_point_type strategy::distance::projected_point::segment_point_type]

[indexterm2 segment_point_type..strategy::distance::projected_point] 

  typedef PointOfSegment segment_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_projected_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__distance__pythagoras strategy::distance::pythagoras]


Strategy for [link boost_geometry.reference.strategy__distance `strategy::distance`] [link boost_geometry.reference.point `point`] to [link boost_geometry.reference.point `point`]: [link boost_geometry.reference.strategy__distance__pythagoras `strategy::distance::pythagoras`]. 




[heading Synopsis]
  template<
      typename Point1 ,
      typename Point2  = Point1,
      typename CalculationType  = void>
  struct pythagoras

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__distance__pythagoras.calculation_type [*calculation_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__pythagoras.first_point_type [*first_point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__pythagoras.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__distance__pythagoras.second_point_type [*second_point_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__distance__pythagoras.apply [*apply]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[Point1][first [link boost_geometry.reference.point `point`] type ]]

[[Point2][optional, second [link boost_geometry.reference.point `point`] type, defaults to first [link boost_geometry.reference.point `point`] type ]]

]


[heading Concepts for Point1 and Point2:]
  

* specialized point_traits class 





[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_pythagoras.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::distance::pythagoras::apply]

[indexterm2 apply..strategy::distance::pythagoras] 

  return_type apply(
      Point1 const & p1,
      Point2 const & p2) const;



[endsect]



[section:calculation_type strategy::distance::pythagoras::calculation_type]

[indexterm2 calculation_type..strategy::distance::pythagoras] 

  typedef select_calculation_type< Point1, Point2, CalculationType >::type calculation_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_calculation_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
Based on two input [link boost_geometry.reference.boost__geometry `boost::geometry`] types, and an input calculation type, (which defaults to void in the calling function), this meta-function selects the most appropriate:
* if calculation type is specified, that one is used,

* if it is void, the most precise of the two points is used 




[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_pythagoras.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:first_point_type strategy::distance::pythagoras::first_point_type]

[indexterm2 first_point_type..strategy::distance::pythagoras] 

  typedef Point1 first_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_pythagoras.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:return_type strategy::distance::pythagoras::return_type]

[indexterm2 return_type..strategy::distance::pythagoras] 

  typedef cartesian_distance< calculation_type > return_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.cartesian_distance.cartesian_distance [*cartesian_distance]]]
    [Constructor with a value. ]
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_cast_type [*operator cast_type]]]
    [Automatic conversion to double or higher precision, taking squareroot if necessary. ]
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_lt_ [*operator<]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_eq__eq_ [*operator==]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.operator_gt_ [*operator>]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.squared_value [*squared_value]]]
    [The "squared\_value" method returns the internal squared value. ]
  ]
  
  [
    [[link boost_geometry.reference.cartesian_distance.very_small [*very_small]]]
    []
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.cartesian_distance.operator_lt__lt_ [*operator<<]]]
    [Make streamable to enable std::cout << geometry::distance( ). ]
  ]
  
]

[heading Typedef Description]
    
Distance calculation for xy points or xyz points is done by taking the square root. However, for distance comparison drawing the square root is not necessary. Therefore the distance strategies are allowed to return the squares of the distance. This structure contains the distance, and a boolean to indicate if it is squared. It has an automatic conversion to a double value, which does the square root if necessary. 

[heading Remarks]
      
Thanks to Phil Endecott for his suggestion to change the pair to the double-convertable http://article.gmane.org/gmane.comp.lib.boost.devel/172709/match=greatcircle\_distance 




[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_pythagoras.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:second_point_type strategy::distance::pythagoras::second_point_type]

[indexterm2 second_point_type..strategy::distance::pythagoras] 

  typedef Point2 second_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_pythagoras.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__intersection__liang_barsky strategy::intersection::liang_barsky]


Strategy: line clipping algorithm after Liang Barsky. 




[heading Synopsis]
  template<
      typename Box ,
      typename Point >
  class liang_barsky

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__intersection__liang_barsky.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__intersection__liang_barsky.clip_segment [*clip_segment]]]
    []
  ]
  
]


[heading Description]

The Liang-Barsky line clipping algorithm clips a line with a clipping [link boost_geometry.reference.box `box`]. It is slightly adapted in the sense that it returns which points are clipped 

[variablelist
  
[[B][input [link boost_geometry.reference.box `box`] type of clipping [link boost_geometry.reference.box `box`] ]]

[[P][input/output point-type of segments to be clipped ]]

]



[heading Remarks]
      
The algorithm is currently only implemented for 2D Cartesian points 

Though it is implemented in namespace [link boost_geometry.reference.strategy `strategy`], and theoretically another [link boost_geometry.reference.strategy `strategy`] could be used, it is not (yet) updated to the general [link boost_geometry.reference.strategy `strategy`] concepts, and not (yet) splitted into a file in folder strategies 


Barend Gehrels, and the following recourses
* A tutorial: http://www.skytopia.com/project/articles/compsci/clipping.html

* a German applet (link broken): http://ls7-www.cs.uni-dortmund.de/students/projectgroups/acit/lineclip.shtml 





[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/clip_linestring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::intersection::liang_barsky::apply]

[indexterm2 apply..strategy::intersection::liang_barsky] 

  template<
      typename Linestring ,
      typename OutputIterator >
  void apply(
      Linestring & line_out,
      OutputIterator out) const;



[endsect]



[section:clip_segment strategy::intersection::liang_barsky::clip_segment]

[indexterm2 clip_segment..strategy::intersection::liang_barsky] 

  bool clip_segment(
      Box const & b,
      segment_type & s,
      bool & sp1_clipped,
      bool & sp2_clipped) const;



[endsect]



[endsect]

[section:strategy__intersection__relate_cartesian_segments strategy::intersection::relate_cartesian_segments]





[heading Synopsis]
  template<
      typename Policy ,
      typename CalculationType  = void>
  struct relate_cartesian_segments

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.coordinate_type [*coordinate_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.segment_type1 [*segment_type1]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.segment_type2 [*segment_type2]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.BOOST_CONCEPT_ASSERT [*BOOST_CONCEPT_ASSERT]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.apply [*apply]]]
    [Relate segments a and b. 

     ]
  ]
  
]


[heading Description]




[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/cart_intersect.hpp]

[*Convenience header: ][^boost/geometry.hpp]

[section:BOOST_CONCEPT_ASSERT strategy::intersection::relate_cartesian_segments::BOOST_CONCEPT_ASSERT]

[indexterm2 BOOST_CONCEPT_ASSERT..strategy::intersection::relate_cartesian_segments] 

  ``[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.BOOST_CONCEPT_ASSERT.overload1 BOOST_CONCEPT_ASSERT]``(
      (concept::ConstSegment< segment_type1 >) );
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.BOOST_CONCEPT_ASSERT.overload1 more...]]``

  ``[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.BOOST_CONCEPT_ASSERT.overload2 BOOST_CONCEPT_ASSERT]``(
      (concept::ConstSegment< segment_type2 >) );
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.BOOST_CONCEPT_ASSERT.overload2 more...]]``


[section:overload1 strategy::intersection::relate_cartesian_segments::BOOST_CONCEPT_ASSERT (1 of 2 overloads)]



  BOOST_CONCEPT_ASSERT(
      (concept::ConstSegment< segment_type1 >) );



[endsect]



[section:overload2 strategy::intersection::relate_cartesian_segments::BOOST_CONCEPT_ASSERT (2 of 2 overloads)]



  BOOST_CONCEPT_ASSERT(
      (concept::ConstSegment< segment_type2 >) );



[endsect]


[endsect]

[section:apply strategy::intersection::relate_cartesian_segments::apply]

[indexterm2 apply..strategy::intersection::relate_cartesian_segments] 
Relate segments a and b. 


  static return_type ``[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.apply.overload1 apply]``(
      segment_type1 const & a,
      segment_type2 const & b);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.apply.overload1 more...]]``



  static return_type ``[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.apply.overload2 apply]``(
      segment_type1 const & a,
      segment_type2 const & b,
      coordinate_type const & dx_a,
      coordinate_type const & dy_a,
      coordinate_type const & dx_b,
      coordinate_type const & dy_b);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.apply.overload2 more...]]``


[section:overload1 strategy::intersection::relate_cartesian_segments::apply (1 of 2 overloads)]


Relate segments a and b. 


  static return_type apply(
      segment_type1 const & a,
      segment_type2 const & b);



[endsect]



[section:overload2 strategy::intersection::relate_cartesian_segments::apply (2 of 2 overloads)]



  static return_type apply(
      segment_type1 const & a,
      segment_type2 const & b,
      coordinate_type const & dx_a,
      coordinate_type const & dy_a,
      coordinate_type const & dx_b,
      coordinate_type const & dy_b);



[endsect]


[endsect]


[section:coordinate_type strategy::intersection::relate_cartesian_segments::coordinate_type]

[indexterm2 coordinate_type..strategy::intersection::relate_cartesian_segments] 

  typedef select_calculation_type< segment_type1, segment_type2, CalculationType >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_calculation_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
Based on two input [link boost_geometry.reference.boost__geometry `boost::geometry`] types, and an input calculation type, (which defaults to void in the calling function), this meta-function selects the most appropriate:
* if calculation type is specified, that one is used,

* if it is void, the most precise of the two points is used 




[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/cart_intersect.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:return_type strategy::intersection::relate_cartesian_segments::return_type]

[indexterm2 return_type..strategy::intersection::relate_cartesian_segments] 

  typedef Policy::return_type return_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/cart_intersect.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_type1 strategy::intersection::relate_cartesian_segments::segment_type1]

[indexterm2 segment_type1..strategy::intersection::relate_cartesian_segments] 

  typedef Policy::segment_type1 segment_type1;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/cart_intersect.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:segment_type2 strategy::intersection::relate_cartesian_segments::segment_type2]

[indexterm2 segment_type2..strategy::intersection::relate_cartesian_segments] 

  typedef Policy::segment_type2 segment_type2;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/cart_intersect.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__not_implemented strategy::not_implemented]


Indicate compiler/library user that [link boost_geometry.reference.strategy `strategy`] is not implemented. 




[heading Synopsis]
  struct not_implemented

[heading Description]

Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 

[heading Requirements]

[*Header: ][^boost/geometry/strategies/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:strategy__side__course strategy::side::course]

[indexterm1 strategy::side::course] 
Calculate course (bearing) between two points. Might be moved to a "course formula" ... 


  template<
      typename Point >
  static double course(
      Point const & p1,
      Point const & p2);


[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/side_by_cross_track.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:strategy__side__side_by_cross_track strategy::side::side_by_cross_track]





[heading Synopsis]
  template<
      typename CalculationType >
  struct side_by_cross_track

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__side__side_by_cross_track.apply [*apply]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/spherical/side_by_cross_track.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::side::side_by_cross_track::apply]

[indexterm2 apply..strategy::side::side_by_cross_track] 

  template<
      typename P1 ,
      typename P2 ,
      typename P >
  static int apply(
      P1 const & p1,
      P2 const & p2,
      P const & p);



[endsect]



[endsect]

[section:strategy__side__side_by_triangle strategy::side::side_by_triangle]





[heading Synopsis]
  template<
      typename CalculationType >
  struct side_by_triangle

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__side__side_by_triangle.apply [*apply]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/side_by_triangle.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::side::side_by_triangle::apply]

[indexterm2 apply..strategy::side::side_by_triangle] 

  template<
      typename P1 ,
      typename P2 ,
      typename P >
  static int apply(
      P1 const & p1,
      P2 const & p2,
      P const & p);



[endsect]



[endsect]

[section:strategy__simplify__douglas_peucker strategy::simplify::douglas_peucker]


Implements the [link boost_geometry.reference.strategy__simplify `strategy::simplify`] algorithm. 




[heading Synopsis]
  template<
      typename Point ,
      typename PointDistanceStrategy >
  class douglas_peucker

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__simplify__douglas_peucker.distance_strategy_type [*distance_strategy_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__simplify__douglas_peucker.apply [*apply]]]
    []
  ]
  
]


[heading Description]

The [link boost_geometry.reference.strategy__simplify__douglas_peucker `strategy::simplify::douglas_peucker`] [link boost_geometry.reference.strategy `strategy`] simplifies a [link boost_geometry.reference.linestring `linestring`], ring or vector of points using the well-known Douglas-Peucker algorithm. For the algorithm, see for example: 


[variablelist
  
[[Point][the [link boost_geometry.reference.point `point`] type ]]

[[PointDistanceStrategy][point-segment [link boost_geometry.reference.strategy__distance `strategy::distance`] [link boost_geometry.reference.strategy `strategy`] to be used ]]

]



[heading Remarks]
      
This [link boost_geometry.reference.strategy `strategy`] uses itself a point-segment-distance [link boost_geometry.reference.strategy `strategy`] which can be specified 


Barend and Maarten, 1995/1996 

Barend, revised for Generic Geometry Library, 2008 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/simplify_douglas_peucker.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::simplify::douglas_peucker::apply]

[indexterm2 apply..strategy::simplify::douglas_peucker] 

  template<
      typename Range ,
      typename OutputIterator >
  static OutputIterator apply(
      Range const & range,
      OutputIterator out,
      double max_distance);



[endsect]



[section:distance_strategy_type strategy::simplify::douglas_peucker::distance_strategy_type]

[indexterm2 distance_strategy_type..strategy::simplify::douglas_peucker] 

  typedef PointDistanceStrategy distance_strategy_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/simplify_douglas_peucker.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__transform__copy_direct strategy::transform::copy_direct]


Transformation [link boost_geometry.reference.strategy `strategy`] to copy one [link boost_geometry.reference.point `point`] to another using assignment operator. 




[heading Synopsis]
  template<
      typename P >
  struct copy_direct

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__copy_direct.apply [*apply]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P][[link boost_geometry.reference.point `point`] type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/strategy_transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::copy_direct::apply]

[indexterm2 apply..strategy::transform::copy_direct] 

  bool apply(
      P const & p1,
      P & p2) const;



[endsect]



[endsect]

[section:strategy__transform__copy_per_coordinate strategy::transform::copy_per_coordinate]


Transformation [link boost_geometry.reference.strategy `strategy`] to do copy a [link boost_geometry.reference.point `point`], copying per coordinate. 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct copy_per_coordinate

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__copy_per_coordinate.apply [*apply]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/strategy_transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::copy_per_coordinate::apply]

[indexterm2 apply..strategy::transform::copy_per_coordinate] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[endsect]

[section:strategy__transform__degree_radian_vv strategy::transform::degree_radian_vv]


Transformation [link boost_geometry.reference.strategy `strategy`] to go from [link boost_geometry.reference.degree `degree`] to [link boost_geometry.reference.radian `radian`] and back. 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 ,
      template< typename > class ``[link boost_geometry.reference.F F]``>
  struct degree_radian_vv

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__degree_radian_vv.apply [*apply]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

[[F][additional functor to divide or multiply with d2r ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/strategy_transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::degree_radian_vv::apply]

[indexterm2 apply..strategy::transform::degree_radian_vv] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[endsect]

[section:strategy__transform__degree_radian_vv_3 strategy::transform::degree_radian_vv_3]





[heading Synopsis]
  template<
      typename P1 ,
      typename P2 ,
      template< typename > class ``[link boost_geometry.reference.F F]``>
  struct degree_radian_vv_3

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__degree_radian_vv_3.apply [*apply]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/strategy_transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::degree_radian_vv_3::apply]

[indexterm2 apply..strategy::transform::degree_radian_vv_3] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[endsect]

[section:strategy__transform__from_cartesian_3_to_spherical_2 strategy::transform::from_cartesian_3_to_spherical_2]


Transformation [link boost_geometry.reference.strategy `strategy`] for 3D cartesian (x,y,z) to 2D spherical (phi,theta). 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct from_cartesian_3_to_spherical_2

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__from_cartesian_3_to_spherical_2.apply [*apply]]]
    []
  ]
  
]


[heading Description]

on Unit sphere



[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

]



[heading Remarks]
      
If x,y,z [link boost_geometry.reference.point `point`] is not lying on unit sphere, transformation will return false 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/strategy_transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::from_cartesian_3_to_spherical_2::apply]

[indexterm2 apply..strategy::transform::from_cartesian_3_to_spherical_2] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[endsect]

[section:strategy__transform__from_cartesian_3_to_spherical_3 strategy::transform::from_cartesian_3_to_spherical_3]


Transformation [link boost_geometry.reference.strategy `strategy`] for 3D cartesian (x,y,z) to 3D spherical (phi,theta,r). 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct from_cartesian_3_to_spherical_3

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__from_cartesian_3_to_spherical_3.apply [*apply]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/strategy_transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::from_cartesian_3_to_spherical_3::apply]

[indexterm2 apply..strategy::transform::from_cartesian_3_to_spherical_3] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[endsect]

[section:strategy__transform__from_spherical_2_to_cartesian_3 strategy::transform::from_spherical_2_to_cartesian_3]


Transformation [link boost_geometry.reference.strategy `strategy`] for 2D spherical (phi,theta) to 3D cartesian (x,y,z). 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct from_spherical_2_to_cartesian_3

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__from_spherical_2_to_cartesian_3.apply [*apply]]]
    []
  ]
  
]


[heading Description]

on Unit sphere



[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/strategy_transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::from_spherical_2_to_cartesian_3::apply]

[indexterm2 apply..strategy::transform::from_spherical_2_to_cartesian_3] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[endsect]

[section:strategy__transform__from_spherical_3_to_cartesian_3 strategy::transform::from_spherical_3_to_cartesian_3]


Transformation [link boost_geometry.reference.strategy `strategy`] for 3D spherical (phi,theta,r) to 3D cartesian (x,y,z). 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct from_spherical_3_to_cartesian_3

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__from_spherical_3_to_cartesian_3.apply [*apply]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/strategy_transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::from_spherical_3_to_cartesian_3::apply]

[indexterm2 apply..strategy::transform::from_spherical_3_to_cartesian_3] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[endsect]

[section:strategy__transform__inverse_transformer strategy::transform::inverse_transformer]


Transformation [link boost_geometry.reference.strategy `strategy`] to do an inverse ransformation in Cartesian system. 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct inverse_transformer :    public strategy::transform::ublas_transformer< P1, P2, dimension< P1 >::type::value, dimension< P2 >::type::value >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__transform__inverse_transformer.T [*T]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__inverse_transformer.inverse_transformer [*inverse_transformer]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/inverse_transformer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:T strategy::transform::inverse_transformer::T]

[indexterm2 T..strategy::transform::inverse_transformer] 

  typedef select_coordinate_type< P1, P2 >::type T;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/inverse_transformer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:inverse_transformer strategy::transform::inverse_transformer::inverse_transformer]

[indexterm2 inverse_transformer..strategy::transform::inverse_transformer] 

  template<
      typename MatrixType >
  inverse_transformer(
      const MatrixType & input);



[endsect]



[endsect]

[section:strategy__transform__map_transformer strategy::transform::map_transformer]


Transformation [link boost_geometry.reference.strategy `strategy`] to do map from one to another Cartesian system. 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 ,
      bool ``[link boost_geometry.reference.Mirror Mirror]``,
      bool ``[link boost_geometry.reference.SameScale SameScale]`` = true,
      std::size_t ``[link boost_geometry.reference.Dimension1 Dimension1]`` = dimension<P1>::type::value,
      std::size_t ``[link boost_geometry.reference.Dimension2 Dimension2]`` = dimension<P2>::type::value>
  struct map_transformer :    public strategy::transform::ublas_transformer< P1, P2, Dimension1, Dimension2 >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__transform__map_transformer.M [*M]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__transform__map_transformer.T [*T]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__map_transformer.map_transformer [*map_transformer]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

[[Mirror][if true map is mirrored upside-down (in most cases pixels are from top to bottom, while map is from bottom to top) ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/map_transformer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:M strategy::transform::map_transformer::M]

[indexterm2 M..strategy::transform::map_transformer] 

  typedef boost::numeric::ublas::matrix< T > M;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/map_transformer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:T strategy::transform::map_transformer::T]

[indexterm2 T..strategy::transform::map_transformer] 

  typedef select_coordinate_type< P1, P2 >::type T;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/map_transformer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:map_transformer strategy::transform::map_transformer::map_transformer]

[indexterm2 map_transformer..strategy::transform::map_transformer] 

  template<
      typename B ,
      typename D >
  explicit ``[link boost_geometry.reference.strategy__transform__map_transformer.map_transformer.overload1 map_transformer]``(
      B const & box,
      D const & width,
      D const & height);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__map_transformer.map_transformer.overload1 more...]]``

  template<
      typename W ,
      typename D >
  explicit ``[link boost_geometry.reference.strategy__transform__map_transformer.map_transformer.overload2 map_transformer]``(
      W const & wx1,
      W const & wy1,
      W const & wx2,
      W const & wy2,
      D const & width,
      D const & height);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__map_transformer.map_transformer.overload2 more...]]``


[section:overload1 strategy::transform::map_transformer::map_transformer (1 of 2 overloads)]



  template<
      typename B ,
      typename D >
  map_transformer(
      B const & box,
      D const & width,
      D const & height);



[endsect]



[section:overload2 strategy::transform::map_transformer::map_transformer (2 of 2 overloads)]



  template<
      typename W ,
      typename D >
  map_transformer(
      W const & wx1,
      W const & wy1,
      W const & wx2,
      W const & wy2,
      D const & width,
      D const & height);



[endsect]


[endsect]


[endsect]

[section:strategy__transform__rotate_transformer strategy::transform::rotate_transformer]


Strategy of rotate transformation in Cartesian system. 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 ,
      typename DegreeOrRadian >
  struct rotate_transformer

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__transform__rotate_transformer.angle_type [*angle_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__rotate_transformer.rotate_transformer [*rotate_transformer]]]
    []
  ]
  
]


[heading Description]

Rotate rotates a [link boost_geometry.reference.boost__geometry `boost::geometry`] of specified angle about a fixed [link boost_geometry.reference.point `point`] (e.g. origin). 


[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

[[DegreeOrRadian][degree/or/radian, type of rotation angle specification ]]

]



[heading Remarks]
      
A single angle is needed to specify a rotation in 2D. Not yet in 3D, the 3D version requires special things to allow for rotation around X, Y, Z or arbitrary axis. 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:angle_type strategy::transform::rotate_transformer::angle_type]

[indexterm2 angle_type..strategy::transform::rotate_transformer] 

  typedef select_most_precise< typename select_coordinate_type< P1, P2 >::type, double >::type angle_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_most_precise.type [*type]]]
    []
  
  ]

]


[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.select_most_precise.both_same [*both_same]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.one_not_fundamental [*one_not_fundamental]]]
    []
  ]

  [
    [[link boost_geometry.reference.select_most_precise.second_larger [*second_larger]]]
    []
  ]

]

[heading Typedef Description]
    
[link boost_geometry.reference.select_most_precise `select_most_precise`] classes, compares two types on compile time. For example, if an addition must be done with a double and an integer, the result must be a double. If both types are integer, the result can be an integer. 

[heading Remarks]
      
It is different from the "promote" class, already in `boost`. That class promotes e.g. a (one) float to a double. This class selects a type from two types. It takes the most accurate, but does not promote afterwards. 

This [link boost_geometry.reference.traits `traits`] class is completely independant from GGL and might be a separate addition to Boost 

If the input is a non-fundamental type, it might be a calculation type such as a GMP-value or another high precision value. Therefore, if one is non-fundamental, that one is chosen. 

If both types are non-fundamental, the result is indeterminate and currently the first one is chosen. 




[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:rotate_transformer strategy::transform::rotate_transformer::rotate_transformer]

[indexterm2 rotate_transformer..strategy::transform::rotate_transformer] 

  rotate_transformer(
      angle_type const & angle);



[endsect]



[endsect]

[section:strategy__transform__scale_transformer strategy::transform::scale_transformer]


Strategy of scale transformation in Cartesian system. 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2  = P1,
      std::size_t ``[link boost_geometry.reference.Dimension1 Dimension1]`` = geometry::dimension<P1>::type::value,
      std::size_t ``[link boost_geometry.reference.Dimension2 Dimension2]`` = geometry::dimension<P2>::type::value>
  struct scale_transformer

[heading Description]

Scale scales a [link boost_geometry.reference.boost__geometry `boost::geometry`] up or down in all its dimensions. 


[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

[[Dimension1][number of dimensions to [link boost_geometry.reference.strategy__transform `strategy::transform`] from first [link boost_geometry.reference.point `point`], optional ]]

[[Dimension1][number of dimensions to [link boost_geometry.reference.strategy__transform `strategy::transform`] to second [link boost_geometry.reference.point `point`], optional ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_ strategy::transform::scale_transformer< P1, P2, 2, 2 >]





[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct scale_transformer< P1, P2, 2, 2 > :    public strategy::transform::ublas_transformer< P1, P2, 2, 2 >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_.coordinate_type [*coordinate_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_.matrix [*matrix]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_.scale_transformer [*scale_transformer]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_.m_matrix [*m_matrix]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::scale_transformer< P1, P2, 2, 2 >::apply]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 apply..strategy::transform::scale_transformer< P1, P2, 2, 2 >] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[section:coordinate_type strategy::transform::scale_transformer< P1, P2, 2, 2 >::coordinate_type]

[indexterm2 coordinate_type..strategy::transform::scale_transformer< P1, P2, 2, 2 >] 

  typedef select_coordinate_type< P1, P2 >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:m_matrix strategy::transform::scale_transformer< P1, P2, 2, 2 >::m_matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 m_matrix..strategy::transform::scale_transformer< P1, P2, 2, 2 >] 

  matrix_type m_matrix;



[endsect]



[section:matrix strategy::transform::scale_transformer< P1, P2, 2, 2 >::matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 matrix..strategy::transform::scale_transformer< P1, P2, 2, 2 >] 

  matrix_type const & matrix() const;



[endsect]


[section:scale_transformer strategy::transform::scale_transformer< P1, P2, 2, 2 >::scale_transformer]

[indexterm2 scale_transformer..strategy::transform::scale_transformer< P1, P2, 2, 2 >] 

  ``[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_.scale_transformer.overload1 scale_transformer]``(
      coordinate_type const & scale_x,
      coordinate_type const & scale_y,
      coordinate_type const & dummy = 0);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_.scale_transformer.overload1 more...]]``

  ``[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_.scale_transformer.overload2 scale_transformer]``(
      coordinate_type const & scale);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_2,_2__gt_.scale_transformer.overload2 more...]]``


[section:overload1 strategy::transform::scale_transformer< P1, P2, 2, 2 >::scale_transformer (1 of 2 overloads)]



  scale_transformer(
      coordinate_type const & scale_x,
      coordinate_type const & scale_y,
      coordinate_type const & dummy = 0);



[endsect]



[section:overload2 strategy::transform::scale_transformer< P1, P2, 2, 2 >::scale_transformer (2 of 2 overloads)]



  scale_transformer(
      coordinate_type const & scale);



[endsect]


[endsect]


[endsect]

[section:strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_ strategy::transform::scale_transformer< P1, P2, 3, 3 >]





[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct scale_transformer< P1, P2, 3, 3 > :    public strategy::transform::ublas_transformer< P1, P2, 3, 3 >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_.coordinate_type [*coordinate_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_.matrix [*matrix]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_.scale_transformer [*scale_transformer]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_.m_matrix [*m_matrix]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::scale_transformer< P1, P2, 3, 3 >::apply]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 apply..strategy::transform::scale_transformer< P1, P2, 3, 3 >] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[section:coordinate_type strategy::transform::scale_transformer< P1, P2, 3, 3 >::coordinate_type]

[indexterm2 coordinate_type..strategy::transform::scale_transformer< P1, P2, 3, 3 >] 

  typedef select_coordinate_type< P1, P2 >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:m_matrix strategy::transform::scale_transformer< P1, P2, 3, 3 >::m_matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 m_matrix..strategy::transform::scale_transformer< P1, P2, 3, 3 >] 

  matrix_type m_matrix;



[endsect]



[section:matrix strategy::transform::scale_transformer< P1, P2, 3, 3 >::matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 matrix..strategy::transform::scale_transformer< P1, P2, 3, 3 >] 

  matrix_type const & matrix() const;



[endsect]


[section:scale_transformer strategy::transform::scale_transformer< P1, P2, 3, 3 >::scale_transformer]

[indexterm2 scale_transformer..strategy::transform::scale_transformer< P1, P2, 3, 3 >] 

  ``[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_.scale_transformer.overload1 scale_transformer]``(
      coordinate_type const & scale_x,
      coordinate_type const & scale_y,
      coordinate_type const & scale_z);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_.scale_transformer.overload1 more...]]``

  ``[link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_.scale_transformer.overload2 scale_transformer]``(
      coordinate_type const & scale);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__scale_transformer_lt__P1,_P2,_3,_3__gt_.scale_transformer.overload2 more...]]``


[section:overload1 strategy::transform::scale_transformer< P1, P2, 3, 3 >::scale_transformer (1 of 2 overloads)]



  scale_transformer(
      coordinate_type const & scale_x,
      coordinate_type const & scale_y,
      coordinate_type const & scale_z);



[endsect]



[section:overload2 strategy::transform::scale_transformer< P1, P2, 3, 3 >::scale_transformer (2 of 2 overloads)]



  scale_transformer(
      coordinate_type const & scale);



[endsect]


[endsect]


[endsect]

[section:strategy__transform__translate_transformer strategy::transform::translate_transformer]


Strategy of translate transformation in Cartesian system. 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 ,
      std::size_t ``[link boost_geometry.reference.Dimension1 Dimension1]`` = geometry::dimension<P1>::type::value,
      std::size_t ``[link boost_geometry.reference.Dimension2 Dimension2]`` = geometry::dimension<P2>::type::value>
  struct translate_transformer

[heading Description]

Translate moves a [link boost_geometry.reference.boost__geometry `boost::geometry`] a fixed [link boost_geometry.reference.strategy__distance `strategy::distance`] in 2 or 3 dimensions. 


[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type ]]

[[P2][second [link boost_geometry.reference.point `point`] type ]]

[[Dimension1][number of dimensions to [link boost_geometry.reference.strategy__transform `strategy::transform`] from first [link boost_geometry.reference.point `point`], optional ]]

[[Dimension1][number of dimensions to [link boost_geometry.reference.strategy__transform `strategy::transform`] to second [link boost_geometry.reference.point `point`], optional ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy__transform__translate_transformer_lt__P1,_P2,_2,_2__gt_ strategy::transform::translate_transformer< P1, P2, 2, 2 >]





[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct translate_transformer< P1, P2, 2, 2 > :    public strategy::transform::ublas_transformer< P1, P2, 2, 2 >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_2,_2__gt_.coordinate_type [*coordinate_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_2,_2__gt_.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_2,_2__gt_.matrix [*matrix]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_2,_2__gt_.translate_transformer [*translate_transformer]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_2,_2__gt_.m_matrix [*m_matrix]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::translate_transformer< P1, P2, 2, 2 >::apply]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 apply..strategy::transform::translate_transformer< P1, P2, 2, 2 >] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[section:coordinate_type strategy::transform::translate_transformer< P1, P2, 2, 2 >::coordinate_type]

[indexterm2 coordinate_type..strategy::transform::translate_transformer< P1, P2, 2, 2 >] 

  typedef select_coordinate_type< P1, P2 >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:m_matrix strategy::transform::translate_transformer< P1, P2, 2, 2 >::m_matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 m_matrix..strategy::transform::translate_transformer< P1, P2, 2, 2 >] 

  matrix_type m_matrix;



[endsect]



[section:matrix strategy::transform::translate_transformer< P1, P2, 2, 2 >::matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 matrix..strategy::transform::translate_transformer< P1, P2, 2, 2 >] 

  matrix_type const & matrix() const;



[endsect]



[section:translate_transformer strategy::transform::translate_transformer< P1, P2, 2, 2 >::translate_transformer]

[indexterm2 translate_transformer..strategy::transform::translate_transformer< P1, P2, 2, 2 >] 

  translate_transformer(
      coordinate_type const & translate_x,
      coordinate_type const & translate_y,
      coordinate_type const & dummy = 0);



[endsect]



[endsect]

[section:strategy__transform__translate_transformer_lt__P1,_P2,_3,_3__gt_ strategy::transform::translate_transformer< P1, P2, 3, 3 >]





[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct translate_transformer< P1, P2, 3, 3 > :    public strategy::transform::ublas_transformer< P1, P2, 3, 3 >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_3,_3__gt_.coordinate_type [*coordinate_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_3,_3__gt_.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_3,_3__gt_.matrix [*matrix]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_3,_3__gt_.translate_transformer [*translate_transformer]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__translate_transformer_lt__P1,_P2,_3,_3__gt_.m_matrix [*m_matrix]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::translate_transformer< P1, P2, 3, 3 >::apply]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 apply..strategy::transform::translate_transformer< P1, P2, 3, 3 >] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[section:coordinate_type strategy::transform::translate_transformer< P1, P2, 3, 3 >::coordinate_type]

[indexterm2 coordinate_type..strategy::transform::translate_transformer< P1, P2, 3, 3 >] 

  typedef select_coordinate_type< P1, P2 >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:m_matrix strategy::transform::translate_transformer< P1, P2, 3, 3 >::m_matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 m_matrix..strategy::transform::translate_transformer< P1, P2, 3, 3 >] 

  matrix_type m_matrix;



[endsect]



[section:matrix strategy::transform::translate_transformer< P1, P2, 3, 3 >::matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 matrix..strategy::transform::translate_transformer< P1, P2, 3, 3 >] 

  matrix_type const & matrix() const;



[endsect]



[section:translate_transformer strategy::transform::translate_transformer< P1, P2, 3, 3 >::translate_transformer]

[indexterm2 translate_transformer..strategy::transform::translate_transformer< P1, P2, 3, 3 >] 

  translate_transformer(
      coordinate_type const & translate_x,
      coordinate_type const & translate_y,
      coordinate_type const & translate_z);



[endsect]



[endsect]

[section:strategy__transform__ublas_transformer strategy::transform::ublas_transformer]


Affine transformation [link boost_geometry.reference.strategy `strategy`] in Cartesian system. 




[heading Synopsis]
  template<
      typename P1 ,
      typename P2 ,
      std::size_t ``[link boost_geometry.reference.Dimension1 Dimension1]``,
      std::size_t ``[link boost_geometry.reference.Dimension2 Dimension2]``>
  class ublas_transformer

[heading Description]

The [link boost_geometry.reference.strategy `strategy`] serves as a generic definition of affine transformation matrix and procedure of application it to given [link boost_geometry.reference.point `point`]. 


[variablelist
  
[[P1][first [link boost_geometry.reference.point `point`] type (source) ]]

[[P2][second [link boost_geometry.reference.point `point`] type (target) ]]

[[Dimension1][number of dimensions to [link boost_geometry.reference.strategy__transform `strategy::transform`] from first [link boost_geometry.reference.point `point`], optional ]]

[[Dimension1][number of dimensions to [link boost_geometry.reference.strategy__transform `strategy::transform`] to second [link boost_geometry.reference.point `point`], optional ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_ strategy::transform::ublas_transformer< P1, P2, 2, 2 >]





[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  class ublas_transformer< P1, P2, 2, 2 >

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.matrix [*matrix]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.ublas_transformer [*ublas_transformer]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.m_matrix [*m_matrix]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::ublas_transformer< P1, P2, 2, 2 >::apply]

[indexterm2 apply..strategy::transform::ublas_transformer< P1, P2, 2, 2 >] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[section:m_matrix strategy::transform::ublas_transformer< P1, P2, 2, 2 >::m_matrix]

[indexterm2 m_matrix..strategy::transform::ublas_transformer< P1, P2, 2, 2 >] 

  matrix_type m_matrix;



[endsect]



[section:matrix strategy::transform::ublas_transformer< P1, P2, 2, 2 >::matrix]

[indexterm2 matrix..strategy::transform::ublas_transformer< P1, P2, 2, 2 >] 

  matrix_type const & matrix() const;



[endsect]


[section:ublas_transformer strategy::transform::ublas_transformer< P1, P2, 2, 2 >::ublas_transformer]

[indexterm2 ublas_transformer..strategy::transform::ublas_transformer< P1, P2, 2, 2 >] 

  ``[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.ublas_transformer.overload1 ublas_transformer]``(
      ct const & m_0_0,
      ct const & m_0_1,
      ct const & m_0_2,
      ct const & m_1_0,
      ct const & m_1_1,
      ct const & m_1_2,
      ct const & m_2_0,
      ct const & m_2_1,
      ct const & m_2_2);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.ublas_transformer.overload1 more...]]``

  ``[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.ublas_transformer.overload2 ublas_transformer]``(
      matrix_type const & matrix);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.ublas_transformer.overload2 more...]]``

  ``[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.ublas_transformer.overload3 ublas_transformer]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_2,_2__gt_.ublas_transformer.overload3 more...]]``


[section:overload1 strategy::transform::ublas_transformer< P1, P2, 2, 2 >::ublas_transformer (1 of 3 overloads)]



  ublas_transformer(
      ct const & m_0_0,
      ct const & m_0_1,
      ct const & m_0_2,
      ct const & m_1_0,
      ct const & m_1_1,
      ct const & m_1_2,
      ct const & m_2_0,
      ct const & m_2_1,
      ct const & m_2_2);



[endsect]



[section:overload2 strategy::transform::ublas_transformer< P1, P2, 2, 2 >::ublas_transformer (2 of 3 overloads)]



  ublas_transformer(
      matrix_type const & matrix);



[endsect]



[section:overload3 strategy::transform::ublas_transformer< P1, P2, 2, 2 >::ublas_transformer (3 of 3 overloads)]



  ublas_transformer();



[endsect]


[endsect]


[endsect]

[section:strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_ strategy::transform::ublas_transformer< P1, P2, 3, 2 >]





[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  struct ublas_transformer< P1, P2, 3, 2 > :    public strategy::transform::ublas_transformer< P1, P2, 2, 2 >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.coordinate_type [*coordinate_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.ct [*ct]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.matrix [*matrix]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.ublas_transformer [*ublas_transformer]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.m_matrix [*m_matrix]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::ublas_transformer< P1, P2, 3, 2 >::apply]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 apply..strategy::transform::ublas_transformer< P1, P2, 3, 2 >] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[section:coordinate_type strategy::transform::ublas_transformer< P1, P2, 3, 2 >::coordinate_type]

[indexterm2 coordinate_type..strategy::transform::ublas_transformer< P1, P2, 3, 2 >] 

  typedef select_coordinate_type< P1, P2 >::type coordinate_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.select_coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:ct strategy::transform::ublas_transformer< P1, P2, 3, 2 >::ct]

[indexterm2 ct..strategy::transform::ublas_transformer< P1, P2, 3, 2 >] 

  typedef coordinate_type ct;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.coordinate_type.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:m_matrix strategy::transform::ublas_transformer< P1, P2, 3, 2 >::m_matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 m_matrix..strategy::transform::ublas_transformer< P1, P2, 3, 2 >] 

  matrix_type m_matrix;



[endsect]



[section:matrix strategy::transform::ublas_transformer< P1, P2, 3, 2 >::matrix]


['Inherited from strategy::transform::ublas_transformer.]

[indexterm2 matrix..strategy::transform::ublas_transformer< P1, P2, 3, 2 >] 

  matrix_type const & matrix() const;



[endsect]


[section:ublas_transformer strategy::transform::ublas_transformer< P1, P2, 3, 2 >::ublas_transformer]

[indexterm2 ublas_transformer..strategy::transform::ublas_transformer< P1, P2, 3, 2 >] 

  ``[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.ublas_transformer.overload1 ublas_transformer]``(
      ct const & m_0_0,
      ct const & m_0_1,
      ct const & m_0_2,
      ct const & m_1_0,
      ct const & m_1_1,
      ct const & m_1_2,
      ct const & m_2_0,
      ct const & m_2_1,
      ct const & m_2_2);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.ublas_transformer.overload1 more...]]``

  ``[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.ublas_transformer.overload2 ublas_transformer]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_2__gt_.ublas_transformer.overload2 more...]]``


[section:overload1 strategy::transform::ublas_transformer< P1, P2, 3, 2 >::ublas_transformer (1 of 2 overloads)]



  ublas_transformer(
      ct const & m_0_0,
      ct const & m_0_1,
      ct const & m_0_2,
      ct const & m_1_0,
      ct const & m_1_1,
      ct const & m_1_2,
      ct const & m_2_0,
      ct const & m_2_1,
      ct const & m_2_2);



[endsect]



[section:overload2 strategy::transform::ublas_transformer< P1, P2, 3, 2 >::ublas_transformer (2 of 2 overloads)]



  ublas_transformer();



[endsect]


[endsect]


[endsect]

[section:strategy__transform__ublas_transformer_lt__P1,_P2,_3,_3__gt_ strategy::transform::ublas_transformer< P1, P2, 3, 3 >]





[heading Synopsis]
  template<
      typename P1 ,
      typename P2 >
  class ublas_transformer< P1, P2, 3, 3 >

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_3__gt_.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_3__gt_.matrix [*matrix]]]
    []
  ]
  
]


[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_3__gt_.ublas_transformer [*ublas_transformer]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_3__gt_.m_matrix [*m_matrix]]]
    []
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform/matrix_transformers.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::transform::ublas_transformer< P1, P2, 3, 3 >::apply]

[indexterm2 apply..strategy::transform::ublas_transformer< P1, P2, 3, 3 >] 

  bool apply(
      P1 const & p1,
      P2 & p2) const;



[endsect]



[section:m_matrix strategy::transform::ublas_transformer< P1, P2, 3, 3 >::m_matrix]

[indexterm2 m_matrix..strategy::transform::ublas_transformer< P1, P2, 3, 3 >] 

  matrix_type m_matrix;



[endsect]



[section:matrix strategy::transform::ublas_transformer< P1, P2, 3, 3 >::matrix]

[indexterm2 matrix..strategy::transform::ublas_transformer< P1, P2, 3, 3 >] 

  matrix_type const & matrix() const;



[endsect]


[section:ublas_transformer strategy::transform::ublas_transformer< P1, P2, 3, 3 >::ublas_transformer]

[indexterm2 ublas_transformer..strategy::transform::ublas_transformer< P1, P2, 3, 3 >] 

  ``[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_3__gt_.ublas_transformer.overload1 ublas_transformer]``(
      ct const & m_0_0,
      ct const & m_0_1,
      ct const & m_0_2,
      ct const & m_0_3,
      ct const & m_1_0,
      ct const & m_1_1,
      ct const & m_1_2,
      ct const & m_1_3,
      ct const & m_2_0,
      ct const & m_2_1,
      ct const & m_2_2,
      ct const & m_2_3,
      ct const & m_3_0,
      ct const & m_3_1,
      ct const & m_3_2,
      ct const & m_3_3);
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_3__gt_.ublas_transformer.overload1 more...]]``

  ``[link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_3__gt_.ublas_transformer.overload2 ublas_transformer]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.strategy__transform__ublas_transformer_lt__P1,_P2,_3,_3__gt_.ublas_transformer.overload2 more...]]``


[section:overload1 strategy::transform::ublas_transformer< P1, P2, 3, 3 >::ublas_transformer (1 of 2 overloads)]



  ublas_transformer(
      ct const & m_0_0,
      ct const & m_0_1,
      ct const & m_0_2,
      ct const & m_0_3,
      ct const & m_1_0,
      ct const & m_1_1,
      ct const & m_1_2,
      ct const & m_1_3,
      ct const & m_2_0,
      ct const & m_2_1,
      ct const & m_2_2,
      ct const & m_2_3,
      ct const & m_3_0,
      ct const & m_3_1,
      ct const & m_3_2,
      ct const & m_3_3);



[endsect]



[section:overload2 strategy::transform::ublas_transformer< P1, P2, 3, 3 >::ublas_transformer (2 of 2 overloads)]



  ublas_transformer();



[endsect]


[endsect]


[endsect]

[section:strategy__within__crossings_multiply strategy::within::crossings_multiply]


Within detection using cross counting,. 




[heading Synopsis]
  template<
      typename Point ,
      typename PointOfSegment  = Point,
      typename CalculationType  = void>
  class crossings_multiply

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__within__crossings_multiply.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__within__crossings_multiply.segment_point_type [*segment_point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__within__crossings_multiply.state_type [*state_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__within__crossings_multiply.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__within__crossings_multiply.result [*result]]]
    []
  ]
  
]


[heading Description]




[heading Remarks]
      
Does NOT work correctly for [link boost_geometry.reference.point `point`] ON border 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_crossings_multiply.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::within::crossings_multiply::apply]

[indexterm2 apply..strategy::within::crossings_multiply] 

  static bool apply(
      Point const & point,
      PointOfSegment const & seg1,
      PointOfSegment const & seg2,
      flags & state);



[endsect]



[section:point_type strategy::within::crossings_multiply::point_type]

[indexterm2 point_type..strategy::within::crossings_multiply] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_crossings_multiply.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:result strategy::within::crossings_multiply::result]

[indexterm2 result..strategy::within::crossings_multiply] 

  static bool result(
      flags const & state);



[endsect]



[section:segment_point_type strategy::within::crossings_multiply::segment_point_type]

[indexterm2 segment_point_type..strategy::within::crossings_multiply] 

  typedef PointOfSegment segment_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_crossings_multiply.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:state_type strategy::within::crossings_multiply::state_type]

[indexterm2 state_type..strategy::within::crossings_multiply] 

  typedef flags state_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__within__crossings_multiply__flags.flags [*flags]]]
    []
  ]
  
]

[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_crossings_multiply.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__within__crossings_multiply__flags strategy::within::crossings_multiply::flags]





[heading Synopsis]
  class flags

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__within__crossings_multiply__flags.flags [*flags]]]
    []
  ]
  
]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_crossings_multiply.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:flags strategy::within::crossings_multiply::flags::flags]

[indexterm2 flags..strategy::within::crossings_multiply::flags] 

  flags();



[endsect]



[endsect]

[section:strategy__within__franklin strategy::within::franklin]


Within detection using cross counting. 




[heading Synopsis]
  template<
      typename Point ,
      typename PointOfSegment  = Point,
      typename CalculationType  = void>
  class franklin

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__within__franklin.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__within__franklin.segment_point_type [*segment_point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__within__franklin.state_type [*state_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__within__franklin.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__within__franklin.result [*result]]]
    []
  ]
  
]


[heading Description]


adapted from Randolph Franklin algorithm 

Barend and Maarten, 1995 

Revised for templatized library, Barend Gehrels, 2007 



[heading Return Value]
      
true if [link boost_geometry.reference.point `point`] is in ring, works for closed rings in both directions 



[heading Remarks]
      
Does NOT work correctly for [link boost_geometry.reference.point `point`] ON border 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_franklin.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::within::franklin::apply]

[indexterm2 apply..strategy::within::franklin] 

  static bool apply(
      Point const & point,
      PointOfSegment const & seg1,
      PointOfSegment const & seg2,
      crossings & state);



[endsect]



[section:point_type strategy::within::franklin::point_type]

[indexterm2 point_type..strategy::within::franklin] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_franklin.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:result strategy::within::franklin::result]

[indexterm2 result..strategy::within::franklin] 

  static bool result(
      crossings const & state);



[endsect]



[section:segment_point_type strategy::within::franklin::segment_point_type]

[indexterm2 segment_point_type..strategy::within::franklin] 

  typedef PointOfSegment segment_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_franklin.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:state_type strategy::within::franklin::state_type]

[indexterm2 state_type..strategy::within::franklin] 

  typedef crossings state_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__within__franklin__crossings.crossings [*crossings]]]
    []
  ]
  
]

[heading Typedef Description]
    
subclass to keep state 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_franklin.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__within__franklin__crossings strategy::within::franklin::crossings]





[heading Synopsis]
  class crossings

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__within__franklin__crossings.crossings [*crossings]]]
    []
  ]
  
]


[heading Description]

subclass to keep state 

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/point_in_poly_franklin.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:crossings strategy::within::franklin::crossings::crossings]

[indexterm2 crossings..strategy::within::franklin::crossings] 

  crossings();



[endsect]



[endsect]

[section:strategy__within__winding strategy::within::winding]


Within detection using [link boost_geometry.reference.strategy__within__winding `strategy::within::winding`] rule. 




[heading Synopsis]
  template<
      typename Point ,
      typename PointOfSegment  = Point,
      typename CalculationType  = void>
  class winding

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__within__winding.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__within__winding.segment_point_type [*segment_point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__within__winding.state_type [*state_type]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__within__winding.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__within__winding.result [*result]]]
    []
  ]
  
]


[heading Description]



[variablelist
  
[[Point][[link boost_geometry.reference.point `point`] type of [link boost_geometry.reference.point `point`] to examine ]]

[[PointOfSegment][[link boost_geometry.reference.point `point`] type of segments, defaults to Point ]]

]


Barend Gehrels 



[heading Remarks]
      
The implementation is inspired by terralib http://www.terralib.org (LGPL) 

but totally revised afterwards, especially for cases on segments 

Only dependant on "side", -> agnostic, suitable for spherical/latlong 



[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/point_in_poly_winding.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::within::winding::apply]

[indexterm2 apply..strategy::within::winding] 

  static bool apply(
      Point const & point,
      PointOfSegment const & s1,
      PointOfSegment const & s2,
      counter & state);



[endsect]



[section:point_type strategy::within::winding::point_type]

[indexterm2 point_type..strategy::within::winding] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/point_in_poly_winding.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:result strategy::within::winding::result]

[indexterm2 result..strategy::within::winding] 

  static bool result(
      counter const & state);



[endsect]



[section:segment_point_type strategy::within::winding::segment_point_type]

[indexterm2 segment_point_type..strategy::within::winding] 

  typedef PointOfSegment segment_point_type;



[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/point_in_poly_winding.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:state_type strategy::within::winding::state_type]

[indexterm2 state_type..strategy::within::winding] 

  typedef counter state_type;



[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__within__winding__counter.counter [*counter]]]
    []
  ]
  
]

[heading Typedef Description]
    
subclass to keep state 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/point_in_poly_winding.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy__within__winding__counter strategy::within::winding::counter]





[heading Synopsis]
  class counter

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__within__winding__counter.counter [*counter]]]
    []
  ]
  
]


[heading Description]

subclass to keep state 

[heading Requirements]

[*Header: ][^boost/geometry/strategies/agnostic/point_in_poly_winding.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:counter strategy::within::winding::counter::counter]

[indexterm2 counter..strategy::within::winding::counter] 

  counter();



[endsect]



[endsect]

[section:strategy_area strategy_area]


Traits class binding an area [link boost_geometry.reference.strategy `strategy`] to a coordinate system. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.Tag Tag]``,
      typename ``[link boost_geometry.reference.PointOfSegment PointOfSegment]``>
  struct strategy_area

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_area.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[Tag][[link boost_geometry.reference.tag `tag`] of coordinate system ]]

[[PointOfSegment][point-type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/area.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_area::type]

[indexterm2 type..strategy_area] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/area.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_centroid strategy_centroid]


Traits class binding a centroid calculation [link boost_geometry.reference.strategy `strategy`] to a coordinate system. 




[heading Synopsis]
  template<
      typename CsTag ,
      typename GeometryTag ,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Point ,
      typename Geometry >
  struct strategy_centroid

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_centroid.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[CsTag][[link boost_geometry.reference.tag `tag`] of coordinate system, for specialization ]]

[[GeometryTag][[link boost_geometry.reference.tag `tag`] of [link boost_geometry.reference.boost__geometry `boost::geometry`], for specialization ]]

[[Dimension][[link boost_geometry.reference.dimension `dimension`] of [link boost_geometry.reference.boost__geometry `boost::geometry`], for specialization ]]

[[Point][point-type ]]

[[Geometry][]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/centroid.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_centroid::type]

[indexterm2 type..strategy_centroid] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/centroid.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_compare strategy_compare]


Traits class binding a comparing [link boost_geometry.reference.strategy `strategy`] to a coordinate system. 




[heading Synopsis]
  template<
      typename Tag ,
      int ``[link boost_geometry.reference.Direction Direction]``,
      typename Point ,
      typename CoordinateSystem ,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``>
  struct strategy_compare

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_compare.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[Tag][[link boost_geometry.reference.tag `tag`] of coordinate system of point-type ]]

[[Direction][direction to compare on: 1 for less (-> ascending order) and -1 for greater (-> descending order) ]]

[[Point][point-type ]]

[[CoordinateSystem][coordinate sytem of [link boost_geometry.reference.point `point`] ]]

[[Dimension:][the [link boost_geometry.reference.dimension `dimension`] to compare on ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/compare.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_compare::type]

[indexterm2 type..strategy_compare] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/compare.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_convex_hull strategy_convex_hull]


Traits class binding a convex hull calculation [link boost_geometry.reference.strategy `strategy`] to a coordinate system. 




[heading Synopsis]
  template<
      typename Tag ,
      typename Geometry ,
      typename Point >
  struct strategy_convex_hull

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_convex_hull.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[Tag][[link boost_geometry.reference.tag `tag`] of coordinate system ]]

[[Geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] type (hull operates internally per hull over [link boost_geometry.reference.boost__geometry `boost::geometry`]) ]]

[[Point][point-type of output points ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/convex_hull.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_convex_hull::type]

[indexterm2 type..strategy_convex_hull] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/convex_hull.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_distance strategy_distance]


Traits class binding a distance [link boost_geometry.reference.strategy `strategy`] to a (possibly two) coordinate system(s). 




[heading Synopsis]
  template<
      typename T1,
      typename ``[link boost_geometry.reference.T2 T2]``,
      typename ``[link boost_geometry.reference.P1 P1]``,
      typename ``[link boost_geometry.reference.P2 P2]``>
  struct strategy_distance

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_distance.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[T1][[link boost_geometry.reference.tag `tag`] of coordinate system of first [link boost_geometry.reference.point `point`] type ]]

[[T2][[link boost_geometry.reference.tag `tag`] of coordinate system of second [link boost_geometry.reference.point `point`] type ]]

[[P1][first point-type ]]

[[P2][second point-type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_distance::type]

[indexterm2 type..strategy_distance] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_distance_segment strategy_distance_segment]


Traits class binding a distance-to-segment [link boost_geometry.reference.strategy `strategy`] to a (possibly two) coordinate system(s). 




[heading Synopsis]
  template<
      typename CsTag1 ,
      typename CsTag2 ,
      typename Point ,
      typename Segment >
  struct strategy_distance_segment

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_distance_segment.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[CsTag1][[link boost_geometry.reference.tag `tag`] of coordinate system of [link boost_geometry.reference.point `point`] type ]]

[[CsTag2][[link boost_geometry.reference.tag `tag`] of coordinate system of [link boost_geometry.reference.segment `segment`] type, usually same as CsTag1 ]]

[[Point][point-type ]]

[[Segment][segment-type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_distance_segment::type]

[indexterm2 type..strategy_distance_segment] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/distance.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_intersection strategy_intersection]





[heading Synopsis]
  template<
      typename Tag ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename IntersectionPoint ,
      typename CalculationType  = void>
  struct strategy_intersection

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_intersection.segment_intersection_strategy_type [*segment_intersection_strategy_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy_intersection.side_strategy_type [*side_strategy_type]]]
    []
  
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/intersection.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:segment_intersection_strategy_type strategy_intersection::segment_intersection_strategy_type]

[indexterm2 segment_intersection_strategy_type..strategy_intersection] 

  typedef strategy::intersection::relate_cartesian_segments< policies::relate::segments_tupled< policies::relate::segments_intersection_points< segment1_type, segment2_type, ip_type, CalculationType >, policies::relate::segments_direction< segment1_type, segment2_type, CalculationType >, CalculationType >, CalculationType > segment_intersection_strategy_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.coordinate_type [*coordinate_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.return_type [*return_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.segment_type1 [*segment_type1]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.segment_type2 [*segment_type2]]]
    []
  
  ]

]


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.BOOST_CONCEPT_ASSERT [*BOOST_CONCEPT_ASSERT]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__intersection__relate_cartesian_segments.apply [*apply]]]
    [Relate segments a and b. 

     ]
  ]
  
]

[heading Typedef Description]
    




[heading Requirements]

[*Header: ][^boost/geometry/strategies/intersection.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:side_strategy_type strategy_intersection::side_strategy_type]

[indexterm2 side_strategy_type..strategy_intersection] 

  typedef strategy_side< Tag, CalculationType >::type side_strategy_type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_side.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    


[variablelist
  
[[Tag][[link boost_geometry.reference.tag `tag`] of coordinate system of point-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/strategies/intersection.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_parse strategy_parse]


Tagraits class binding a parsing [link boost_geometry.reference.strategy `strategy`] to a coordinate system. 




[heading Synopsis]
  template<
      typename Tag ,
      typename CoordinateSystem >
  struct strategy_parse

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_parse.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[Tag][[link boost_geometry.reference.tag `tag`] of coordinate system of point-type ]]

[[CoordinateSystem][coordinate system ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/parse.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_parse::type]

[indexterm2 type..strategy_parse] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/parse.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_side strategy_side]


Traits class binding a side determination [link boost_geometry.reference.strategy `strategy`] to a coordinate system. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.Tag Tag]``,
      typename ``[link boost_geometry.reference.CalculationType CalculationType]`` = void>
  struct strategy_side

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_side.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[Tag][[link boost_geometry.reference.tag `tag`] of coordinate system of point-type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/side.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_side::type]

[indexterm2 type..strategy_side] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/side.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_tag strategy_tag]





[heading Synopsis]
  template<
      typename T >
  struct strategy_tag

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_tag.type [*type]]]
    []
  
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_tag::type]

[indexterm2 type..strategy_tag] 

  typedef strategy_tag_unknown type;


[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_tag_lt__strategy__distance__projected_point_lt__Point,_PointOfSegment,_PPStrategy__gt___gt_ strategy_tag< strategy::distance::projected_point< Point, PointOfSegment, PPStrategy > >]





[heading Synopsis]
  template<
      typename Point ,
      typename PointOfSegment ,
      typename PPStrategy >
  struct strategy_tag< strategy::distance::projected_point< Point, PointOfSegment, PPStrategy > >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_tag_lt__strategy__distance__projected_point_lt__Point,_PointOfSegment,_PPStrategy__gt___gt_.type [*type]]]
    []
  
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_projected_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_tag< strategy::distance::projected_point< Point, PointOfSegment, PPStrategy > >::type]

[indexterm2 type..strategy_tag< strategy::distance::projected_point< Point, PointOfSegment, PPStrategy > >] 

  typedef strategy_tag_distance_point_segment type;


[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_projected_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_tag_lt__strategy__distance__pythagoras_lt__Point1,_Point2__gt___gt_ strategy_tag< strategy::distance::pythagoras< Point1, Point2 > >]





[heading Synopsis]
  template<
      typename Point1 ,
      typename Point2 >
  struct strategy_tag< strategy::distance::pythagoras< Point1, Point2 > >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_tag_lt__strategy__distance__pythagoras_lt__Point1,_Point2__gt___gt_.type [*type]]]
    []
  
  ]

]


[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_pythagoras.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_tag< strategy::distance::pythagoras< Point1, Point2 > >::type]

[indexterm2 type..strategy_tag< strategy::distance::pythagoras< Point1, Point2 > >] 

  typedef strategy_tag_distance_point_point type;


[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/strategies/cartesian/distance_pythagoras.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_tag_distance_point_point strategy_tag_distance_point_point]





[heading Synopsis]
  struct strategy_tag_distance_point_point

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy_tag_distance_point_segment strategy_tag_distance_point_segment]





[heading Synopsis]
  struct strategy_tag_distance_point_segment

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy_tag_unknown strategy_tag_unknown]





[heading Synopsis]
  struct strategy_tag_unknown

[heading Description]

[heading Requirements]

[*Header: ][^boost/geometry/strategies/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy_transform strategy_transform]


Traits class binding a transformation [link boost_geometry.reference.strategy `strategy`] to a coordinate system. 




[heading Synopsis]
  template<
      typename CoordinateSystemTag1 ,
      typename CoordinateSystemTag2 ,
      typename CoordinateSystem1 ,
      typename CoordinateSystem2 ,
      std::size_t ``[link boost_geometry.reference.Dimension1 Dimension1]``,
      std::size_t ``[link boost_geometry.reference.Dimension2 Dimension2]``,
      typename Point1 ,
      typename Point2 >
  struct strategy_transform

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_transform.type [*type]]]
    []
  
  ]

]


[heading Description]

Can be specialized
* per coordinate system family (tag)

* per coordinate system (or groups of them)

* per dimension

* per point type CoordinateSystemTag1,2 coordinate system tags CoordinateSystem1,2 coordinate system D1, 2 dimension Point1, 2 point type 




[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_transform::type]

[indexterm2 type..strategy_transform] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:strategy_within strategy_within]


Traits class binding a within determination [link boost_geometry.reference.strategy `strategy`] to a coordinate system. 




[heading Synopsis]
  template<
      typename TagPoint ,
      typename TagSegment ,
      typename Point ,
      typename PointOfSegment >
  struct strategy_within

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.strategy_within.type [*type]]]
    []
  
  ]

]


[heading Description]



[variablelist
  
[[TagPoint][[link boost_geometry.reference.tag `tag`] of coordinate system of point-type ]]

[[TagSegment][[link boost_geometry.reference.tag `tag`] of coordinate system of segment-type ]]

[[Point][point-type of input points ]]

[[PointOfSegment][point-type of input segment-points ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/strategies/point_in_poly.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type strategy_within::type]

[indexterm2 type..strategy_within] 

  typedef strategy::not_implemented type;


[heading Typedef Description]
    
Strategies are defined for [link boost_geometry.reference.point `point`] types or for [link boost_geometry.reference.point `point`] type combinations. If there is no implementation for that specific [link boost_geometry.reference.point `point`] type, or [link boost_geometry.reference.point `point`] type combination, the calculation cannot be done. To indicate this, this [link boost_geometry.reference.strategy__not_implemented `strategy::not_implemented`] class is used as a typedef stub. 


[heading Requirements]

[*Header: ][^boost/geometry/strategies/point_in_poly.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]


[section:subtract_point subtract_point]

[indexterm1 subtract_point] 
Subtracts a [link boost_geometry.reference.point `point`] to another. 


  template<
      typename Point1 ,
      typename Point2 >
  void subtract_point(
      Point1 & p1,
      Point2 const & p2);


The coordinates of the second [link boost_geometry.reference.point `point`] will be subtracted to those of the first [link boost_geometry.reference.point `point`]. The second [link boost_geometry.reference.point `point`] is not modified. 
[heading Parameters]
    

[variablelist
  
[[p1][first [link boost_geometry.reference.point `point`] ]]

[[p2][second [link boost_geometry.reference.point `point`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:subtract_value subtract_value]

[indexterm1 subtract_value] 
Subtracts a value to each coordinate of a [link boost_geometry.reference.point `point`]. 


  template<
      typename Point >
  void subtract_value(
      Point & p,
      typename detail::param< Point >::type value);



[heading Parameters]
    

[variablelist
  
[[p][[link boost_geometry.reference.point `point`] ]]

[[value][value to subtract ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:sym_difference sym_difference]

[indexterm1 sym_difference] 

  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Collection >
  void sym_difference(
      Geometry1 geometry1,
      Geometry2 geometry2,
      Collection & output_collection);




[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to make symmetric difference ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sym_difference.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:tag tag]


Meta-function to get the [link boost_geometry.reference.tag `tag`] of any [link boost_geometry.reference.boost__geometry `boost::geometry`] type. 




[heading Synopsis]
  template<
      typename Geometry >
  struct tag

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]


[heading Description]

All geometries tell their [link boost_geometry.reference.boost__geometry `boost::geometry`] type ([link boost_geometry.reference.point `point`], [link boost_geometry.reference.linestring `linestring`], [link boost_geometry.reference.polygon `polygon`], etc) by implementing a [link boost_geometry.reference.tag `tag`] [link boost_geometry.reference.traits `traits`] class. This meta-function uses that [link boost_geometry.reference.traits `traits`] class to retrieve the [link boost_geometry.reference.tag `tag`]. If the input type is not a [link boost_geometry.reference.boost__geometry `boost::geometry`] at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/tag.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type tag::type]

[indexterm2 type..tag] 

  typedef traits::tag< typename boost::remove_const< Geometry >::type >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.traits__tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries should implement a `traits::tag<G>::type` metafunction to indicate their own [link boost_geometry.reference.boost__geometry `boost::geometry`] type.


[heading Geometries:]
  

* all geometries 




[heading Specializations should provide:]
  

* typedef XXX_tag type; (point_tag, box_tag, ...) 





[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/tag.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:topological_dimension topological_dimension]


Meta-function returning the topological [link boost_geometry.reference.dimension `dimension`] of a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename Geometry >
  struct topological_dimension

[heading Description]

The topological [link boost_geometry.reference.dimension `dimension`] defines a [link boost_geometry.reference.point `point`] as 0-dimensional, a [link boost_geometry.reference.linestring `linestring`] as 1-dimensional, and a ring or [link boost_geometry.reference.polygon `polygon`] as 2-dimensional. 


[heading Requirements]

[*Header: ][^boost/geometry/core/topological_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__access traits::access]


Traits class which gives [link boost_geometry.reference.traits__access `traits::access`] (get,set) to points. 




[heading Synopsis]
  template<
      typename Geometry ,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``>
  struct access

[heading Description]


[heading Geometries:]
  

* point 




[heading Specializations should provide, per Dimension]
  

* static inline T get(const G&) 

* static inline void set(G&, T const&) 





[variablelist
  
[[Geometry][geometry-type ]]

[[Dimension][[link boost_geometry.reference.traits__dimension `traits::dimension`] to [link boost_geometry.reference.traits__access `traits::access`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__append_point traits::append_point]


Traits class, optional, might be implemented to append a [link boost_geometry.reference.point `point`]. 




[heading Synopsis]
  template<
      typename Geometry ,
      typename Point >
  struct append_point

[heading Description]

If a [link boost_geometry.reference.boost__geometry `boost::geometry`] type should not use the std "push\_back" then it can specialize the "use\_std" [link boost_geometry.reference.traits `traits`] class to false, it should then implement (a.o.) [link boost_geometry.reference.traits__append_point `traits::append_point`]


[heading Geometries:]
  

* linestring

* linear_ring 




[heading Specializations should provide:]
  

* apply 





[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__clear traits::clear]


Traits class, optional, might be implemented to [link boost_geometry.reference.traits__clear `traits::clear`] a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename Geometry >
  struct clear

[heading Description]

If a [link boost_geometry.reference.boost__geometry `boost::geometry`] type should not use the std ".clear()" then it can specialize the "use\_std" [link boost_geometry.reference.traits `traits`] class to false, it should then implement (a.o.) [link boost_geometry.reference.traits__clear `traits::clear`]


[heading Geometries:]
  

* linestring

* linear_ring 




[heading Specializations should provide:]
  

* apply 





[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__coordinate_system traits::coordinate_system]


Traits class defining the coordinate system of a [link boost_geometry.reference.point `point`], important for [link boost_geometry.reference.strategy `strategy`] selection. 




[heading Synopsis]
  template<
      typename P >
  struct coordinate_system

[heading Description]


[heading Geometries:]
  

* point 




[heading Specializations should provide:]
  

* typedef CS type; (cs::cartesian, cs::spherical, etc) 





[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_system.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__coordinate_type traits::coordinate_type]


Traits class which indicate the coordinate type (double,float,...) of a [link boost_geometry.reference.point `point`]. 




[heading Synopsis]
  template<
      typename P >
  struct coordinate_type

[heading Description]


[heading Geometries:]
  

* point 




[heading Specializations should provide:]
  

* typedef T type; (double,float,int,etc) 





[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__cs_tag traits::cs_tag]


Traits class defining coordinate system [link boost_geometry.reference.traits__tag `traits::tag`], bound to coordinate system. 




[heading Synopsis]
  template<
      typename CoordinateSystem >
  struct cs_tag

[heading Description]



[variablelist
  
[[CoordinateSystem][coordinate system ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__dimension traits::dimension]


Traits class indicating the number of dimensions of a [link boost_geometry.reference.point `point`]. 




[heading Synopsis]
  template<
      typename P >
  struct dimension

[heading Description]


[heading Geometries:]
  

* point 




[heading Specializations should provide:]
  

* value (should be derived from boost::mpl::int_<D> 





[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__exterior_ring traits::exterior_ring]


Traits class defining [link boost_geometry.reference.traits__access `traits::access`] to [link boost_geometry.reference.traits__exterior_ring `traits::exterior_ring`] of a [link boost_geometry.reference.polygon `polygon`]. 




[heading Synopsis]
  template<
      typename Polygon >
  struct exterior_ring

[heading Description]

Should define const and non const [link boost_geometry.reference.traits__access `traits::access`]



[variablelist
  
[[Polygon][the [link boost_geometry.reference.polygon `polygon`] type ]]

]


[heading Geometries:]
  

* polygon 




[heading Specializations should provide:]
  

* static inline RING& get(POLY& )

* static inline const RING& get(const POLY& ) 





[heading Requirements]

[*Header: ][^boost/geometry/core/exterior_ring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__indexed_access traits::indexed_access]


Traits class defining "get" and "set" to get and set [link boost_geometry.reference.point `point`] coordinate values. 




[heading Synopsis]
  template<
      typename Geometry ,
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``>
  struct indexed_access

[heading Description]



[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ([link boost_geometry.reference.box `box`], [link boost_geometry.reference.segment `segment`]) ]]

[[Index][index (min\_corner/max\_corner for [link boost_geometry.reference.box `box`], 0/1 for [link boost_geometry.reference.segment `segment`]) ]]

[[Dimension][[link boost_geometry.reference.traits__dimension `traits::dimension`] ]]

]


[heading Geometries:]
  

* box

* segment 




[heading Specializations should provide:]
  

* static inline T get(const G&)

* static inline void set(G&, T const&) 





[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__interior_rings traits::interior_rings]


Traits class defining [link boost_geometry.reference.traits__access `traits::access`] to [link boost_geometry.reference.traits__interior_rings `traits::interior_rings`] of a [link boost_geometry.reference.polygon `polygon`]. 




[heading Synopsis]
  template<
      typename Geometry >
  struct interior_rings

[heading Description]

defines [link boost_geometry.reference.traits__access `traits::access`] (const and non const) to interior ring


[heading Geometries:]
  

* polygon 




[heading Specializations should provide:]
  

* static inline INTERIOR& get(POLY&)

* static inline const INTERIOR& get(const POLY&) 





[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__interior_type traits::interior_type]


Traits class indicating interior container type of a [link boost_geometry.reference.polygon `polygon`]. 




[heading Synopsis]
  template<
      typename Geometry >
  struct interior_type

[heading Description]

defines inner container type, so the container containing the interior rings


[heading Geometries:]
  

* polygon 




[heading Specializations should provide:]
  

* typedef X type ( e.g. std::vector<myring<P>> ) 





[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__point_order traits::point_order]


Traits class indicating the order of contained points within a ring or (multi)[link boost_geometry.reference.polygon `polygon`], clockwise, counter clockwise or not known. 




[heading Synopsis]
  template<
      typename G >
  struct point_order

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.traits__point_order.value [*value]]]
    []
  ]

]


[heading Description]


[heading Geometries:]
  

* ring

* polygon

* multi polygon 




[heading Specializations should provide:]
  

* typedef P type (where P should fulfil the Point concept) 





[variablelist
  
[[G][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/point_order.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:value traits::point_order::value]

[indexterm2 value..traits::point_order] 

  static const order_selector value = clockwise;



[endsect]



[endsect]

[section:traits__point_type traits::point_type]


Traits class indicating the type of contained points. 




[heading Synopsis]
  template<
      typename G >
  struct point_type

[heading Description]


[heading Geometries:]
  

* all geometries except point 




[heading Specializations should provide:]
  

* typedef P type (where P should fulfil the Point concept) 





[variablelist
  
[[G][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__ring_type traits::ring_type]


Traits class to indicate ring-type of a polygon's exterior ring/interior rings. 




[heading Synopsis]
  template<
      typename Geometry >
  struct ring_type

[heading Description]


[heading Geometries:]
  

* polygon 




[heading Specializations should provide:]
  

* typedef XXX type ( e.g. linear_ring



) 

[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/ring_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__tag traits::tag]


Traits class to attach a [link boost_geometry.reference.traits__tag `traits::tag`] to a [link boost_geometry.reference.boost__geometry `boost::geometry`]. 




[heading Synopsis]
  template<
      typename ``[link boost_geometry.reference.Geometry Geometry]``>
  struct tag

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.traits__tag.type [*type]]]
    []
  
  ]

]


[heading Description]

All geometries should implement a `traits::tag<G>::type` metafunction to indicate their own [link boost_geometry.reference.boost__geometry `boost::geometry`] type.


[heading Geometries:]
  

* all geometries 




[heading Specializations should provide:]
  

* typedef XXX_tag type; (point_tag, box_tag, ...) 





[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/tag.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type traits::tag::type]

[indexterm2 type..traits::tag] 

  typedef geometry_not_recognized_tag type;


[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/core/tag.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:traits__use_std traits::use_std]


Traits class, optional, indicating that the std-library should be used. 




[heading Synopsis]
  template<
      typename Geometry >
  struct use_std

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.traits__use_std.value [*value]]]
    []
  ]

]


[heading Description]

The default [link boost_geometry.reference.boost__geometry `boost::geometry`] ([link boost_geometry.reference.linestring `linestring`], ring, multi*) follow std:: for its modifying operations (push\_back, [link boost_geometry.reference.traits__clear `traits::clear`], size, resize, reserve, etc) If they NOT follow the std:: library they should specialize this [link boost_geometry.reference.traits `traits`] class


[heading Geometries:]
  

* linestring

* linear_ring 




[heading Specializations should provide:]
  

* value (defaults to true) 





[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:value traits::use_std::value]

[indexterm2 value..traits::use_std] 

  static const bool value = true;



[endsect]



[endsect]

[section:transform transform]

[indexterm1 transform] 
Transforms from one geometry to another geometry, optionally using a strategy. 

      
  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  bool ``[link boost_geometry.reference.transform.overload1 transform]``(
      Geometry1 const & geometry1,
      Geometry2 & geometry2,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.transform.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool ``[link boost_geometry.reference.transform.overload2 transform]``(
      Geometry1 const & geometry1,
      Geometry2 & geometry2);
  ``  [''''&raquo;''' [link boost_geometry.reference.transform.overload2 more...]]``

The transform algorithm automatically transforms from one coordinate system to another coordinate system. If the coordinate system of both geometries are the same, the geometry is copied. All point(s of the geometry) are transformed.

There is a version without a strategy, transforming automatically, and there is a version with a strategy.

This function has a lot of appliances, for example
* transform from spherical coordinates to cartesian coordinates, and back

* transform from geographic coordinates to cartesian coordinates (projections) and back

* transform from degree to radian, and back

* transform from and to cartesian coordinates (mapping, translations, etc)



The automatic transformations look to the coordinate system family, and dimensions, of the point type and by this apply the strategy (internally bounded by traits classes).


[heading Examples:]
  
The example below shows automatic transformations to go from one coordinate system to another one:  





The next example takes another approach and transforms from Cartesian to Cartesian: 







[heading Remarks]
      
Not every possibility is yet worked out, e.g. polar coordinate system is ignored until now 

This "transform" is broader then geodetic datum transformations, those are currently not worked out 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 transform (1 of 2 overloads)]


Transforms from one [link boost_geometry.reference.boost__geometry `boost::geometry`] to another [link boost_geometry.reference.boost__geometry `boost::geometry`] using a [link boost_geometry.reference.strategy `strategy`]. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  bool transform(
      Geometry1 const & geometry1,
      Geometry2 & geometry2,
      Strategy const & strategy);




[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Strategy][[link boost_geometry.reference.strategy `strategy`] ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[strategy][the [link boost_geometry.reference.strategy `strategy`] to be used for transformation ]]

]




[endsect]



[section:overload2 transform (2 of 2 overloads)]


Transforms from one [link boost_geometry.reference.boost__geometry `boost::geometry`] to another [link boost_geometry.reference.boost__geometry `boost::geometry`] using a [link boost_geometry.reference.strategy `strategy`]. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool transform(
      Geometry1 const & geometry1,
      Geometry2 & geometry2);




[variablelist
  
[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
true if the transformation could be done 




[endsect]


[endsect]


[section:traverse traverse]

[indexterm1 traverse] 
Traverses through intersection points / geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Turns ,
      typename Rings >
  void traverse(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      detail::overlay::operation_type operation,
      Turns & turns,
      Rings & rings);


[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/traverse.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:union_inserter union_inserter]

[indexterm1 union_inserter] 
Combines two geometries which each other. 

    
  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator ``[link boost_geometry.reference.union_inserter.overload1 union_inserter]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.union_inserter.overload1 more...]]``

  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator >
  OutputIterator ``[link boost_geometry.reference.union_inserter.overload2 union_inserter]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out);
  ``  [''''&raquo;''' [link boost_geometry.reference.union_inserter.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/union.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 union_inserter (1 of 2 overloads)]


Combines two geometries which each other. 


  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator union_inserter(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out,
      Strategy const & strategy);




[variablelist
  
[[GeometryOut][output [link boost_geometry.reference.boost__geometry `boost::geometry`] type, must be specified ]]

[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[OutputIterator][output iterator ]]

[[Strategy][compound [link boost_geometry.reference.strategy `strategy`] for intersection ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[out][the output iterator, outputting polygons ]]

[[strategy][the [link boost_geometry.reference.strategy `strategy`] ]]

]



[heading Return Value]
      
the output iterator 




[endsect]



[section:overload2 union_inserter (2 of 2 overloads)]


Combines two geometries which each other. 


  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator >
  OutputIterator union_inserter(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out);




[variablelist
  
[[GeometryOut][output [link boost_geometry.reference.boost__geometry `boost::geometry`] type, must be specified ]]

[[Geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[Geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

[[OutputIterator][output iterator ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[out][the output iterator, outputting polygons ]]

]



[heading Return Value]
      
the output iterator 




[endsect]


[endsect]


[section:unique unique]

[indexterm1 unique] 

  template<
      typename Geometry >
  void unique(
      Geometry & geometry);




[variablelist
  
[[Geometry][[link boost_geometry.reference.boost__geometry `boost::geometry`] type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the [link boost_geometry.reference.boost__geometry `boost::geometry`] to make unique ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/unique.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:within within]

[indexterm1 within] 
      
  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool ``[link boost_geometry.reference.within.overload1 within]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);
  ``  [''''&raquo;''' [link boost_geometry.reference.within.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  bool ``[link boost_geometry.reference.within.overload2 within]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.within.overload2 more...]]``


[heading Source descriptions:]
  

* OGC: Returns 1 (TRUE) if this geometric object is "spatially within" another Geometry.




[heading Performance]
  

* 2776 within determinations using bounding box and polygon are done in 0.05 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Within1)

* note that using another strategy the performance can be increased:winding : 0.093 sfranklin : 0.062 sCrossings-multiply : 0.047 s


* but note also that the last two do not detect point-on-border cases




[heading Geometries:]
  

* point + polygon: The well-known point-in-polygon, returning true if a point falls within a polygon (and not within one of its holes) 


* point + ring: returns true if point is completely within a ring 


* point + box 

* box + box 




[heading Example:]
  
The within algorithm is used as following:  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/within.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 within (1 of 2 overloads)]


Within, examine if a [link boost_geometry.reference.boost__geometry `boost::geometry`] is within another [link boost_geometry.reference.boost__geometry `boost::geometry`]. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool within(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);



[heading Parameters]
    

[variablelist
  
[[geometry1][[link boost_geometry.reference.boost__geometry `boost::geometry`] which might be within the second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][[link boost_geometry.reference.boost__geometry `boost::geometry`] which might contain the first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

]



[heading Return Value]
      
true if geometry1 is completely contained within geometry2, else false 



[heading Remarks]
      
The default [link boost_geometry.reference.strategy `strategy`] is used for within detection 




[endsect]



[section:overload2 within (2 of 2 overloads)]


Within, examine if a [link boost_geometry.reference.boost__geometry `boost::geometry`] is within another [link boost_geometry.reference.boost__geometry `boost::geometry`], using a specified [link boost_geometry.reference.strategy `strategy`]. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  bool within(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry1][[link boost_geometry.reference.boost__geometry `boost::geometry`] which might be within the second [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[geometry2][[link boost_geometry.reference.boost__geometry `boost::geometry`] which might contain the first [link boost_geometry.reference.boost__geometry `boost::geometry`] ]]

[[strategy][[link boost_geometry.reference.strategy `strategy`] to be used ]]

]



[heading Return Value]
      
true if geometry1 is completely contained within geometry2, else false 




[endsect]


[endsect]

[endsect]