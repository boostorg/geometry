[/
 / Copyright (c) 2010 Mateusz Loskot (mateusz at loskot dot net
 / Copyright (c) 2003-2010 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:reference Reference]

[xinclude quickref.xml]

[include geometry_concepts.qbk]



[section:add_point add_point]

[indexterm1 add_point] 
Adds a point to another. 


  template<
      typename Point1 ,
      typename Point2 >
  void add_point(
      Point1 & p1,
      Point2 const & p2);


The coordinates of the second point will be added to those of the first point. The second point is not modified. 
[heading Parameters]
    

[variablelist
  
[[p1][first point ]]

[[p2][second point ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:add_value add_value]

[indexterm1 add_value] 
Adds a value to each coordinate of a point. 


  template<
      typename Point >
  void add_value(
      Point & p,
      typename detail::param< Point >::type value);



[heading Parameters]
    

[variablelist
  
[[p][point ]]

[[value][value to add ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:append append]

[indexterm1 append] 
Appends one or more points to a linestring, ring, polygon, multi. 


  template<
      typename Geometry ,
      typename RoP >
  void append(
      Geometry & geometry,
      RoP const & range_or_point,
      int ring_index = -1,
      int multi_index = 0);



[heading Parameters]
    

[variablelist
  
[[geometry][a geometry ]]

[[range_or_point][the point or range to add ]]

[[ring_index][the index of the ring in case of a polygon: exterior ring (-1, the default) or interior ring index ]]

[[multi_index][reserved for multi polygons ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/append.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:area area]

[indexterm1 area] 
      
  template<
      typename Geometry >
  area_result< Geometry >::type ``[link boost_geometry.reference.area.overload1 area]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.area.overload1 more...]]``

  template<
      typename Geometry ,
      typename Strategy >
  Strategy::return_type ``[link boost_geometry.reference.area.overload2 area]``(
      Geometry const & geometry,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.area.overload2 more...]]``


[heading Performance]
  
2776 * 1000 area calculations are done in 0.11 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Area1)


[heading Coordinate systems and strategies]
  
Area calculation can be done in Cartesian and in spherical/geographic coordinate systems.


[heading Geometries]
  
The area algorithm calculates the surface area of all geometries having a surface: box, polygon, multi\_polygon. The units are the square of the units used for the points defining the surface. If the polygon is defined in meters, the area is in square meters.


[heading Example:]
  
Example showing area calculation of polygons built  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/area.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 area (1 of 2 overloads)]


Calculate area of a geometry. 


  template<
      typename Geometry >
  area_result< Geometry >::type area(
      Geometry const & geometry);


The function area returns the area of a polygon, ring, box using the default area-calculation strategy. Strategies are provided for cartesian and spherical coordinate systems The geometries should correct, polygons should be closed and according to the specified orientation (clockwise/counter clockwise) 
[heading Parameters]
    

[variablelist
  
[[geometry][a geometry ]]

]


[heading Return Value]
      
the area 




[endsect]



[section:overload2 area (2 of 2 overloads)]


Calculate area of a geometry using a specified strategy. 


  template<
      typename Geometry ,
      typename Strategy >
  Strategy::return_type area(
      Geometry const & geometry,
      Strategy const & strategy);


This version of area calculation takes a strategy 
[heading Parameters]
    

[variablelist
  
[[geometry][a geometry ]]

[[strategy][the strategy to calculate area. Especially for spherical areas there are some approaches. ]]

]


[heading Return Value]
      
the area 




[endsect]


[endsect]


[section:assert_dimension assert_dimension]

[indexterm1 assert_dimension] 
assert\_dimension, enables compile-time checking if coordinate dimensions are as expected 


  template<
      typename G ,
      int ``[link boost_geometry.reference.D D]``>
  void assert_dimension();


[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assert_dimension_equal assert_dimension_equal]

[indexterm1 assert_dimension_equal] 
assert\_dimension\_equal, enables compile-time checking if coordinate dimensions of two geometries are equal 


  template<
      typename G1 ,
      typename G2 >
  void assert_dimension_equal();


[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assert_dimension_greater_equal assert_dimension_greater_equal]

[indexterm1 assert_dimension_greater_equal] 

  template<
      typename G ,
      int ``[link boost_geometry.reference.D D]``>
  void assert_dimension_greater_equal();


[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assert_dimension_less_equal assert_dimension_less_equal]

[indexterm1 assert_dimension_less_equal] 
assert\_dimension, enables compile-time checking if coordinate dimensions are as expected 


  template<
      typename G ,
      int ``[link boost_geometry.reference.D D]``>
  void assert_dimension_less_equal();


[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:assign assign]

[indexterm1 assign] 
assign two values to a 2D point 

    
  template<
      typename Geometry ,
      typename Type >
  void ``[link boost_geometry.reference.assign.overload1 assign]``(
      Geometry & geometry,
      Type const & c1,
      Type const & c2);
  ``  [''''&raquo;''' [link boost_geometry.reference.assign.overload1 more...]]``

  template<
      typename Geometry ,
      typename Type >
  void ``[link boost_geometry.reference.assign.overload2 assign]``(
      Geometry & geometry,
      Type const & c1,
      Type const & c2,
      Type const & c3);
  ``  [''''&raquo;''' [link boost_geometry.reference.assign.overload2 more...]]``

  template<
      typename Geometry ,
      typename Type >
  void ``[link boost_geometry.reference.assign.overload3 assign]``(
      Geometry & geometry,
      Type const & c1,
      Type const & c2,
      Type const & c3,
      Type const & c4);
  ``  [''''&raquo;''' [link boost_geometry.reference.assign.overload3 more...]]``

  template<
      typename Geometry ,
      typename Range >
  void ``[link boost_geometry.reference.assign.overload4 assign]``(
      Geometry & geometry,
      Range const & range);
  ``  [''''&raquo;''' [link boost_geometry.reference.assign.overload4 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 assign (1 of 4 overloads)]


assign two values to a 2D point 


  template<
      typename Geometry ,
      typename Type >
  void assign(
      Geometry & geometry,
      Type const & c1,
      Type const & c2);



[endsect]



[section:overload2 assign (2 of 4 overloads)]


assign three values to a 3D point [or the center + radius to a circle] 


  template<
      typename Geometry ,
      typename Type >
  void assign(
      Geometry & geometry,
      Type const & c1,
      Type const & c2,
      Type const & c3);



[endsect]



[section:overload3 assign (3 of 4 overloads)]


assign center + radius to a sphere [for extension] 


  template<
      typename Geometry ,
      typename Type >
  void assign(
      Geometry & geometry,
      Type const & c1,
      Type const & c2,
      Type const & c3,
      Type const & c4);



[endsect]



[section:overload4 assign (4 of 4 overloads)]


assign a range of points to a linestring, ring or polygon 


  template<
      typename Geometry ,
      typename Range >
  void assign(
      Geometry & geometry,
      Range const & range);



[heading Remarks]
      
The point-type of the range might be different from the point-type of the geometry 




[endsect]


[endsect]


[section:assign_box_corners assign_box_corners]

[indexterm1 assign_box_corners] 
Assign the 4 points of a 2D box. 


  template<
      typename Box ,
      typename Point >
  void assign_box_corners(
      Box const & box,
      Point & lower_left,
      Point & lower_right,
      Point & upper_left,
      Point & upper_right);



[heading Remarks]
      
The order is crucial. Most logical is LOWER, UPPER and sub-order LEFT, RIGHT so this is how it is implemented. 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assign_inverse assign_inverse]

[indexterm1 assign_inverse] 
assign to a box inverse infinite 


  template<
      typename Geometry >
  void assign_inverse(
      Geometry & geometry);


The assign\_inverse function initialize a 2D or 3D box with large coordinates, the min corner is very large, the max corner is very small. This is a convenient starting point to collect the minimum bounding box of a geometry. 

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assign_point_from_index assign_point_from_index]

[indexterm1 assign_point_from_index] 
Assign a point with a point of a box or segment. 


  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      typename Point ,
      typename Geometry >
  void assign_point_from_index(
      Geometry const & geometry,
      Point & point);




[variablelist
  
[[Index][indicates which box-corner, min\_corner (0) or max\_corner (1) or which point of segment (0/1) ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assign_point_to_index assign_point_to_index]

[indexterm1 assign_point_to_index] 
Assign a box or segment with the value of a point. 


  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      typename Geometry ,
      typename Point >
  void assign_point_to_index(
      Point const & point,
      Geometry & geometry);




[variablelist
  
[[Index][indicates which box-corner, min\_corner (0) or max\_corner (1) or which point of segment (0/1) ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:assign_zero assign_zero]

[indexterm1 assign_zero] 
assign zero values to a box, point 


  template<
      typename Geometry >
  void assign_zero(
      Geometry & geometry);


The assign\_zero function initializes a 2D or 3D point or box with coordinates of zero 

[variablelist
  
[[Geometry][the geometry type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/assign.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:box box]


Class box: defines a box made of two describing points. 


  template<
      typename Point >
  class box
[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.box.box [*box]]]
    [

     Constructor taking the minimum corner point and the maximum corner point. ]
  ]
  
  [
    [[link boost_geometry.reference.box.max_corner [*max_corner]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.box.min_corner [*min_corner]]]
    []
  ]
  
]

Box is always described by a `min_corner()` and a `max_corner()` point. If another rectangle is used, use [link boost_geometry.reference.linear_ring `linear_ring`] or polygon. 
[heading Remarks]
      
Boxes are for selections and for calculating the envelope of geometries. Not all algorithms are implemented for box. Boxes are also used in Spatial Indexes. 



[variablelist
  
[[Point][point type. The box takes a point type as template parameter. The point type can be any point type. It can be 2D but can also be 3D or more dimensional. The box can also take a latlong point type as template parameter. ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/box.hpp]

[*Convenience header: ][^boost/geometry.hpp]

[section:box box::box]

[indexterm2 box..box] 

  ``[link boost_geometry.reference.box.box.overload1 box]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.box.box.overload1 more...]]``


Constructor taking the minimum corner point and the maximum corner point. 


  ``[link boost_geometry.reference.box.box.overload2 box]``(
      Point const & min_corner,
      Point const & max_corner);
  ``  [''''&raquo;''' [link boost_geometry.reference.box.box.overload2 more...]]``


[section:overload1 box::box (1 of 2 overloads)]



  box();



[endsect]



[section:overload2 box::box (2 of 2 overloads)]


Constructor taking the minimum corner point and the maximum corner point. 


  box(
      Point const & min_corner,
      Point const & max_corner);



[endsect]


[endsect]

[section:max_corner box::max_corner]

[indexterm2 max_corner..box] 

  Point const & ``[link boost_geometry.reference.box.max_corner.overload1 max_corner]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.box.max_corner.overload1 more...]]``

  Point & ``[link boost_geometry.reference.box.max_corner.overload2 max_corner]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.box.max_corner.overload2 more...]]``


[section:overload1 box::max_corner (1 of 2 overloads)]



  Point const & max_corner() const;



[endsect]



[section:overload2 box::max_corner (2 of 2 overloads)]



  Point & max_corner();



[endsect]


[endsect]

[section:min_corner box::min_corner]

[indexterm2 min_corner..box] 

  Point const & ``[link boost_geometry.reference.box.min_corner.overload1 min_corner]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.box.min_corner.overload1 more...]]``

  Point & ``[link boost_geometry.reference.box.min_corner.overload2 min_corner]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.box.min_corner.overload2 more...]]``


[section:overload1 box::min_corner (1 of 2 overloads)]



  Point const & min_corner() const;



[endsect]



[section:overload2 box::min_corner (2 of 2 overloads)]



  Point & min_corner();



[endsect]


[endsect]


[endsect]


[section:box_2d box_2d]

[indexterm1 box_2d] 

  typedef box< point_2d > box_2d;


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.box.box [*box]]]
    [

     Constructor taking the minimum corner point and the maximum corner point. ]
  ]
  
  [
    [[link boost_geometry.reference.box.max_corner [*max_corner]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.box.min_corner [*min_corner]]]
    []
  ]
  
]

[heading Typedef Description]
    
Box is always described by a `min_corner()` and a `max_corner()` point. If another rectangle is used, use [link boost_geometry.reference.linear_ring `linear_ring`] or polygon. 
[heading Remarks]
      
Boxes are for selections and for calculating the envelope of geometries. Not all algorithms are implemented for box. Boxes are also used in Spatial Indexes. 



[variablelist
  
[[Point][point type. The box takes a point type as template parameter. The point type can be any point type. It can be 2D but can also be 3D or more dimensional. The box can also take a latlong point type as template parameter. ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:box_3d box_3d]

[indexterm1 box_3d] 

  typedef box< point_3d > box_3d;


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.box.box [*box]]]
    [

     Constructor taking the minimum corner point and the maximum corner point. ]
  ]
  
  [
    [[link boost_geometry.reference.box.max_corner [*max_corner]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.box.min_corner [*min_corner]]]
    []
  ]
  
]

[heading Typedef Description]
    
Box is always described by a `min_corner()` and a `max_corner()` point. If another rectangle is used, use [link boost_geometry.reference.linear_ring `linear_ring`] or polygon. 
[heading Remarks]
      
Boxes are for selections and for calculating the envelope of geometries. Not all algorithms are implemented for box. Boxes are also used in Spatial Indexes. 



[variablelist
  
[[Point][point type. The box takes a point type as template parameter. The point type can be any point type. It can be 2D but can also be 3D or more dimensional. The box can also take a latlong point type as template parameter. ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:box_tag box_tag]


Convenience 2D or 3D box (mbr) identifying tag. 


  struct box_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:buffer buffer]

[indexterm1 buffer] 
Calculate buffer (= new geometry) around specified distance of geometry. 


  template<
      typename Input ,
      typename Output ,
      typename T >
  void buffer(
      Input const & geometry_in,
      Output & geometry_out,
      T const & distance,
      T const & chord_length = -1);



[heading Parameters]
    

[variablelist
  
[[geometry_in][input geometry ]]

[[distance][the distance used in buffer ]]

[[chord_length][length of the chord's in the generated arcs around points or bends ]]

[[geometry_out][buffered geometry ]]

]


[heading Remarks]
      
Currently only implemented for box, the trivial case, but still useful 


[heading Use case:]
  
BOX + distance -> BOX: it is allowed that "geometry\_out" the same object as "geometry\_in" 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/buffer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:cartesian_tag cartesian_tag]


Tag indicating Cartesian coordinate system family (cartesian,epsg). 


  struct cartesian_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:centroid centroid]

[indexterm1 centroid] 
      
  template<
      typename Geometry ,
      typename Point ,
      typename Strategy >
  void ``[link boost_geometry.reference.centroid.overload1 centroid]``(
      Geometry const & geometry,
      Point & c,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.centroid.overload1 more...]]``

  template<
      typename Geometry ,
      typename Point >
  void ``[link boost_geometry.reference.centroid.overload2 centroid]``(
      Geometry const & geometry,
      Point & c);
  ``  [''''&raquo;''' [link boost_geometry.reference.centroid.overload2 more...]]``


[heading Source descriptions:]
  

* OGC description: The mathematical centroid for this Surface as a Point. The result is not guaranteed to be on this Surface.

* From Wikipedia: Informally, it is the "average" of all points 





[heading Remarks]
      
Polygon should be closed, and can be orientated either way 

The "centroid" functions are taking a non const reference to the centroid. The "make\_centroid" functions return the centroid, the type has to be specified. 

Both of them have an overloaded version where a centroid calculation strategy can be specified 


[heading Exceptions]
    

[variablelist
  
[[centroid_exception][if calculation is not successful, e.g. because polygon didn't contain points]]

]


[heading Example:]
  
Example showing centroid calculation  






[heading Performance]
  
2776 * 1000 centroid calculations are done in 0.16 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Centroid1)


[heading Geometries:]
  

* RING: 


* BOX: the centroid of a 2D or 3D box is the center of the box

* POLYGON 


* POINT: the point is the centroid

* LINESTRING: the average of the centers of its segments

* MULTIPOINT: the average of the points 





[heading Requirements]

[*Header: ][^boost/geometry/algorithms/centroid.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 centroid (1 of 2 overloads)]


Calculate centroid using a specified strategy. 


  template<
      typename Geometry ,
      typename Point ,
      typename Strategy >
  void centroid(
      Geometry const & geometry,
      Point & c,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to calculate centroid from ]]

[[c][reference to point which will contain the centroid ]]

[[strategy][Calculation strategy for centroid ]]

]




[endsect]



[section:overload2 centroid (2 of 2 overloads)]


Calculate centroid. 


  template<
      typename Geometry ,
      typename Point >
  void centroid(
      Geometry const & geometry,
      Point & c);



[heading Parameters]
    

[variablelist
  
[[geometry][a geometry (e.g. closed ring or polygon) ]]

[[c][reference to point which will contain the centroid ]]

]




[endsect]


[endsect]

[section:centroid_exception centroid_exception]



  class centroid_exception :    public exception
[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.centroid_exception.centroid_exception [*centroid_exception]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.centroid_exception.what [*what]]]
    []
  ]
  
]

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/centroid.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:centroid_exception centroid_exception::centroid_exception]

[indexterm2 centroid_exception..centroid_exception] 

  centroid_exception();



[endsect]



[section:what centroid_exception::what]

[indexterm2 what..centroid_exception] 

  char const * what() const;



[endsect]



[endsect]


[section:clear clear]

[indexterm1 clear] 
Clears a linestring, linear ring or polygon (exterior+interiors) or multi*. 


  template<
      typename Geometry >
  void clear(
      Geometry & geometry);


Generic function to clear a geometry


[heading Remarks]
      
points and boxes cannot be cleared, instead they can be set to zero by "assign\_zero" 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/clear.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:combine combine]

[indexterm1 combine] 
Combines a box with another geometry (box, point). 


  template<
      typename Box ,
      typename Geometry >
  void combine(
      Box & box,
      Geometry const & geometry);




[variablelist
  
[[Box][type of the box ]]

[[Geometry][of second geometry, to be combined with the box ]]

]


[heading Parameters]
    

[variablelist
  
[[box][box to combine another geometry with, might be changed ]]

[[geometry][other geometry ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/combine.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:concept__Box concept::Box]


[link boost_geometry.reference.concept__Box `concept::Box`] concept. 


  template<
      typename Geometry >
  class Box

[heading Formal definition:]
  
The box concept is defined as following:
* there must be a specialization of traits::tag defining box_tag as type

* there must be a specialization of traits::point_type to define the underlying point type (even if it does not consist of points, it should define this type, to indicate the points it can work with)

* there must be a specialization of traits::indexed_access, per index (min_corner, max_corner) and per dimension, with two functions:get to get a coordinate valueset to set a coordinate value (this one is not checked for ConstBox) 






[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/box_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstBox concept::ConstBox]


[link boost_geometry.reference.concept__Box `concept::Box`] concept (const version). 


  template<
      typename Geometry >
  class ConstBox
The [link boost_geometry.reference.concept__ConstBox `concept::ConstBox`] concept apply the same as the [link boost_geometry.reference.concept__Box `concept::Box`] concept, but does not apply write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/box_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstLinestring concept::ConstLinestring]


[link boost_geometry.reference.concept__Linestring `concept::Linestring`] concept (const version). 


  template<
      typename Geometry >
  class ConstLinestring
The [link boost_geometry.reference.concept__ConstLinestring `concept::ConstLinestring`] concept check the same as the [link boost_geometry.reference.concept__Linestring `concept::Linestring`] concept, but does not check write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/linestring_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstPoint concept::ConstPoint]


point concept (const version) 


  template<
      typename Geometry >
  class ConstPoint
The [link boost_geometry.reference.concept__ConstPoint `concept::ConstPoint`] concept apply the same as the [link boost_geometry.reference.concept__Point `concept::Point`] concept, but does not apply write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/point_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstPolygon concept::ConstPolygon]


[link boost_geometry.reference.concept__Polygon `concept::Polygon`] concept (const version). 


  template<
      typename Geometry >
  class ConstPolygon
The [link boost_geometry.reference.concept__ConstPolygon `concept::ConstPolygon`] concept check the same as the [link boost_geometry.reference.concept__Polygon `concept::Polygon`] concept, but does not check write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/polygon_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstRing concept::ConstRing]


(linear) ring concept (const version) 


  template<
      typename Geometry >
  class ConstRing
The ConstLinearRing concept check the same as the Geometry concept, but does not check write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/ring_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__ConstSegment concept::ConstSegment]


[link boost_geometry.reference.concept__Segment `concept::Segment`] concept (const version). 


  template<
      typename Geometry >
  class ConstSegment
The [link boost_geometry.reference.concept__ConstSegment `concept::ConstSegment`] concept verifies the same as the [link boost_geometry.reference.concept__Segment `concept::Segment`] concept, but does not verify write access. 

[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/segment_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Linestring concept::Linestring]


[link boost_geometry.reference.concept__Linestring `concept::Linestring`] concept. 


  template<
      typename Geometry >
  class Linestring

[heading Formal definition:]
  
The linestring concept is defined as following:
* there must be a specialization of traits::tag defining linestring_tag as type

* it must behave like a Boost.Range

* either it can behave like the std library, having push_back and clear

* or it can implement a mechanism for clearing and adding points:there can be a specialization of traits::use_std class indicating that it does not use the standard library (for modifications)there should then be a specialization of traits::clear to make a linestring emptythere should then be a specialization of traits::append_point to add a point to a linestring





[heading Remarks]
      
to fulfil the concepts, no traits class has to be specialized to define the point type. The point type is taken using boost::range\_value<X>::type


[heading Example:]
  


A custom linestring, defining the necessary specializations to fulfil to the concept.

Suppose that the following linestring is defined:  





It can then be adapted to the concept as following:  






[heading Remarks]
      

* There is also the registration macro BOOST_GEOMETRY_REGISTER_LINESTRING

* For registration of std::vector<P> (and deque, and list) it is enough to include the header-file geometries/adapted/std_as_linestring.hpp. That registers a vector as a linestring (so it cannot be registered as a linear ring then, in the same source code). 





[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/linestring_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Point concept::Point]


[link boost_geometry.reference.concept__Point `concept::Point`] concept. 


  template<
      typename Geometry >
  class Point

[heading Formal definition:]
  
The point concept is defined as following:
* there must be a specialization of traits::tag defining point_tag as type

* there must be a specialization of traits::coordinate_type defining the type of its coordinates

* there must be a specialization of traits::coordinate_system defining its coordinate system (cartesian, spherical, etc)

* there must be a specialization of traits::dimension defining its number of dimensions (2, 3, ...) (derive it conveniently from boost::mpl::int_<X> for X-D)

* there must be a specialization of traits::access, per dimension, with two functions:get to get a coordinate valueset to set a coordinate value (this one is not checked for ConstPoint)





[heading Example:]
  


A legacy point, defining the necessary specializations to fulfil to the concept.

Suppose that the following point is defined:  





It can then be adapted to the concept as following:  





Note that it is done like above to show the system. Users will normally use the registration macro.


[heading Example:]
  


A read-only legacy point, using a macro to fulfil to the [link boost_geometry.reference.concept__ConstPoint `concept::ConstPoint`] concept. It cannot be modified by the library but can be used in all algorithms where points are not modified.

The point looks like the following:

 





It uses the macro as following:  





[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/point_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Polygon concept::Polygon]


[link boost_geometry.reference.concept__Polygon `concept::Polygon`] concept. 


  template<
      typename Geometry >
  class Polygon

[heading Formal definition:]
  
The polygon concept is defined as following:
* there must be a specialization of traits::tag defining polygon_tag as type

* there must be a specialization of traits::ring_type defining the type of its exterior ring and interior rings as type

* there must be a specialization of traits::interior_type defining the type of the collection of its interior rings as type

* there must be a specialization of traits::exterior_ring with two functions named "get", returning the exterior ring, a const version and a mutable version

* there must be a specialization of traits::interior_rings with two functions named "get", returning the interior rings, a const version and a mutable version




[heading Remarks]
      
to fulfil the concepts, no traits class has to be specialized to define the point type. The point type is automatically defined as typename range\_value<typename `ring_type<P>::type`>type 



[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/polygon_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Ring concept::Ring]


ring concept 


  template<
      typename Geometry >
  class Ring

[heading Formal definition:]
  
The ring concept is defined as following:
* there must be a specialization of traits::tag defining ring_tag as type

* it must behave like a Boost.Range

* there can optionally be a specialization of traits::point_order defining the order or orientation of its points, clockwise or counterclockwise.

* either it can behave like the std library, having pushback

* or it can implement a mechanism for clearing and adding points. This is the same as the for the concept Linestring, and described there.




[heading Remarks]
      
to fulfil the concepts, no traits class has to be specialized to define the point type. The point type is taken using boost::range\_value<X>::type 



[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/ring_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:concept__Segment concept::Segment]


segment concept 


  template<
      typename Geometry >
  class Segment

[heading Formal definition:]
  
The segment concept is defined as following:
* there must be a specialization of traits::tag defining segment_tag as type

* there must be a specialization of traits::point_type to define the underlying point type (even if it does not consist of points, it should define this type, to indicate the points it can work with)

* there must be a specialization of traits::indexed_access, per index and per dimension, with two functions:get to get a coordinate valueset to set a coordinate value (this one is not checked for ConstSegment)





[heading Remarks]
      
The segment concept is similar to the box concept, defining another tag. However, the box concept assumes the index as min\_corner, max\_corner, while for the segment concept there is no assumption. 



[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/segment_concept.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:concept__check concept::check]

[indexterm1 concept::check] 
Checks, in compile-time, the concept of any geometry. 


  template<
      typename Geometry >
  void check();


[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/check.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:concept__check_concepts_and_equal_dimensions concept::check_concepts_and_equal_dimensions]

[indexterm1 concept::check_concepts_and_equal_dimensions] 
Checks, in compile-time, the concept of two geometries, and if they have equal dimensions. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  void check_concepts_and_equal_dimensions();


[heading Requirements]

[*Header: ][^boost/geometry/geometries/concepts/check.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:convert convert]

[indexterm1 convert] 
Converts one geometry to another geometry. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  void convert(
      Geometry1 const & geometry1,
      Geometry2 & geometry2);


The convert algorithm converts one geometry, e.g. a BOX, to another geometry, e.g. a RING. This only if it is possible and applicable.



[variablelist
  
[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry (source) ]]

[[geometry2][second geometry (target) ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/convert.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:convex_hull convex_hull]

[indexterm1 convex_hull] 
      
  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  void ``[link boost_geometry.reference.convex_hull.overload1 convex_hull]``(
      Geometry1 const & geometry,
      Geometry2 & out,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.convex_hull.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 >
  void ``[link boost_geometry.reference.convex_hull.overload2 convex_hull]``(
      Geometry1 const & geometry,
      Geometry2 & out);
  ``  [''''&raquo;''' [link boost_geometry.reference.convex_hull.overload2 more...]]``


[heading Source descriptions:]
  

* OGC description: Returns a geometric object that represents the convex hull of this geometric object. Convex hulls, being dependent on straight lines, can be accurately represented in linear interpolations for any geometry restricted to linear interpolations. 





[heading Performance]
  
2776 counties of US are "hulled" in 0.9 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Convexhull1)


[heading Remarks]
      
The convex hull is always a ring, holes are not possible. Therefore it is can also be used in combination with an output iterator.


[heading Geometries supported:]
  
In the images below the convex hull is painted in red.


* point: will not compile




* linestring: 




* polygon: will deliver a polygon without holes 





* multi_point: 





* multi_linestring: 




* multi_polygon: 




[heading Output geometries supported:]
  



* polygon 




* ring 




* inserter version (with output iterator) can output to any array supporting points of same type as the input geometry type 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/convex_hull.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 convex_hull (1 of 2 overloads)]



  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  void convex_hull(
      Geometry1 const & geometry,
      Geometry2 & out,
      Strategy const & strategy);



[endsect]



[section:overload2 convex_hull (2 of 2 overloads)]


Calculate the convex hull of a geometry. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  void convex_hull(
      Geometry1 const & geometry,
      Geometry2 & out);




[variablelist
  
[[Geometry1][the input geometry type ]]

[[Geometry2:][the output geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to calculate convex hull from ]]

[[out][a geometry receiving points of the convex hull ]]

]




[endsect]


[endsect]

[section:convex_hull_inserter convex_hull_inserter]

[indexterm1 convex_hull_inserter] 
    
  template<
      typename Geometry ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator ``[link boost_geometry.reference.convex_hull_inserter.overload1 convex_hull_inserter]``(
      Geometry const & geometry,
      OutputIterator out,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.convex_hull_inserter.overload1 more...]]``

  template<
      typename Geometry ,
      typename OutputIterator >
  OutputIterator ``[link boost_geometry.reference.convex_hull_inserter.overload2 convex_hull_inserter]``(
      Geometry const & geometry,
      OutputIterator out);
  ``  [''''&raquo;''' [link boost_geometry.reference.convex_hull_inserter.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/convex_hull.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 convex_hull_inserter (1 of 2 overloads)]



  template<
      typename Geometry ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator convex_hull_inserter(
      Geometry const & geometry,
      OutputIterator out,
      Strategy const & strategy);



[endsect]



[section:overload2 convex_hull_inserter (2 of 2 overloads)]


Calculate the convex hull of a geometry, output-iterator version. 


  template<
      typename Geometry ,
      typename OutputIterator >
  OutputIterator convex_hull_inserter(
      Geometry const & geometry,
      OutputIterator out);




[variablelist
  
[[Geometry][the input geometry type ]]

[[OutputIterator:][an output-iterator ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to calculate convex hull from ]]

[[out][an output iterator outputing points of the convex hull ]]

]


[heading Remarks]
      
This overloaded version outputs to an output iterator. In this case, nothing is known about its point-type or about its clockwise order. Therefore, the input point-type and order are copied 




[endsect]


[endsect]

[section:coordinate_system coordinate_system]


Meta-function which defines coordinate system for any geometry. 


  template<
      typename G >
  struct coordinate_system

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.coordinate_system.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.coordinate_system.type [*type]]]
    []
  
  ]

]

[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_system.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:ncg coordinate_system::ncg]

[indexterm2 ncg..coordinate_system] 

  typedef boost::remove_const< G >::type ncg;



[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_system.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:type coordinate_system::type]

[indexterm2 type..coordinate_system] 

  typedef core_dispatch::coordinate_system< typename tag< G >::type, ncg >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their geometry type (point, linestring, polygon, etc) by implementing a tag traits class. This meta-function uses that traits class to retrieve the tag. If the input type is not a geometry at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][geometry ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_system.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:coordinate_type coordinate_type]


Meta-function which defines coordinate type (int, float, double, etc) of any geometry. 


  template<
      typename ``[link boost_geometry.reference.G G]``>
  struct coordinate_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.coordinate_type.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.coordinate_type.type [*type]]]
    []
  
  ]

]

[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:ncg coordinate_type::ncg]

[indexterm2 ncg..coordinate_type] 

  typedef boost::remove_const< G >::type ncg;



[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:type coordinate_type::type]

[indexterm2 type..coordinate_type] 

  typedef core_dispatch::coordinate_type< typename tag< G >::type, ncg >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their geometry type (point, linestring, polygon, etc) by implementing a tag traits class. This meta-function uses that traits class to retrieve the tag. If the input type is not a geometry at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][geometry ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:copy_segment_point copy_segment_point]

[indexterm1 copy_segment_point] 
Helper function, copies a point from a segment. 

    
  template<
      typename Geometry ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool ``[link boost_geometry.reference.copy_segment_point.overload1 copy_segment_point]``(
      Geometry const & geometry,
      SegmentIdentifier const & seg_id,
      bool second,
      PointOut & point_out);
  ``  [''''&raquo;''' [link boost_geometry.reference.copy_segment_point.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool ``[link boost_geometry.reference.copy_segment_point.overload2 copy_segment_point]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      SegmentIdentifier const & seg_id,
      bool second,
      PointOut & point_out);
  ``  [''''&raquo;''' [link boost_geometry.reference.copy_segment_point.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/copy_segment_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 copy_segment_point (1 of 2 overloads)]


Helper function, copies a point from a segment. 


  template<
      typename Geometry ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool copy_segment_point(
      Geometry const & geometry,
      SegmentIdentifier const & seg_id,
      bool second,
      PointOut & point_out);



[endsect]



[section:overload2 copy_segment_point (2 of 2 overloads)]


Helper function, to avoid the same construct several times, copies a point, based on a source-index and two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool copy_segment_point(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      SegmentIdentifier const & seg_id,
      bool second,
      PointOut & point_out);



[endsect]


[endsect]


[section:copy_segment_points copy_segment_points]

[indexterm1 copy_segment_points] 
Helper function, to avoid the same construct several times, copies a point, based on a source-index and two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename SegmentIdentifier ,
      typename PointOut >
  bool copy_segment_points(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      SegmentIdentifier const & seg_id,
      PointOut & point1,
      PointOut & point2);


[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/copy_segment_point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:copy_segments copy_segments]

[indexterm1 copy_segments] 
Traverses through intersection points / geometries. 


  template<
      typename Geometry ,
      typename SegmentIdentifier ,
      typename RangeOut >
  void copy_segments(
      Geometry const & geometry,
      SegmentIdentifier const & seg_id,
      int to_index,
      RangeOut & range_out);


[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/copy_segments.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:correct correct]

[indexterm1 correct] 

  template<
      typename Geometry >
  void correct(
      Geometry & geometry);


[heading Requirements]

[*Header: ][^boost/geometry/algorithms/correct.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:cross_product cross_product]

[indexterm1 cross_product] 
Computes the cross product of two vector. 


  template<
      typename P1 ,
      typename P2 >
  P1 cross_product(
      P1 const & p1,
      P2 const & p2);


Both vectors shall be of the same type. This type also determines type of result vector.


[heading Parameters]
    

[variablelist
  
[[p1][first vector ]]

[[p2][second vector ]]

]


[heading Return Value]
      
the cross product vector 



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/cross_product.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:cs__cartesian cs::cartesian]


Cartesian coordinate system. 


  struct cartesian
Defines the Cartesian or rectangular coordinate system where points are defined in 2 or 3 (or more) dimensions and usually (but not always) known as x,y,z 


[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:cs__geographic cs::geographic]


Geographic coordinate system, in degree or in radian. 


  template<
      typename DegreeOrRadian >
  struct geographic

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.cs__geographic.units [*units]]]
    []
  
  ]

]

Defines the geographic coordinate system where points are defined in two angles and usually known as lat,long or lo,la or phi,lambda 

[heading Remarks]
      
might be moved to extensions/gis/geographic 



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:units cs::geographic::units]

[indexterm2 units..cs::geographic] 

  typedef DegreeOrRadian units;



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:cs__polar cs::polar]


Polar coordinate system. 


  template<
      typename DegreeOrRadian >
  struct polar

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.cs__polar.units [*units]]]
    []
  
  ]

]

Defines the polar coordinate system "in which each point
        on a plane is determined by an angle and a distance" 


[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:units cs::polar::units]

[indexterm2 units..cs::polar] 

  typedef DegreeOrRadian units;



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:cs__spherical cs::spherical]


Spherical coordinate system, in degree or in radian. 


  template<
      typename DegreeOrRadian >
  struct spherical

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.cs__spherical.units [*units]]]
    []
  
  ]

]

Defines the spherical coordinate system where points are defined in two angles and an optional radius usually known as r, theta, phi 
[heading Coordinates:]
  

* coordinate 0: 0 <= phi < 2pi is the angle between the positive x-axis and the line from the origin to the P projected onto the xy-plane.

* coordinate 1: 0 <= theta <= pi is the angle between the positive z-axis and the line formed between the origin and P.

* coordinate 2 (if specified): r >= 0 is the distance from the origin to a given point P.






[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:units cs::spherical::units]

[indexterm2 units..cs::spherical] 

  typedef DegreeOrRadian units;



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:cs_tag cs_tag]


Meta-function returning coordinate system tag (cs family) of any geometry. 


  template<
      typename G >
  struct cs_tag

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.cs_tag.type [*type]]]
    []
  
  ]

]

[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type cs_tag::type]

[indexterm2 type..cs_tag] 

  typedef traits::cs_tag< typename geometry::coordinate_system< G >::type >::type type;


[heading Typedef Description]
    


[variablelist
  
[[CoordinateSystem][coordinate system ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:degree degree]


Unit of plane angle: Degrees. 


  class degree
[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:difference difference]

[indexterm1 difference] 

  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Collection >
  void difference(
      Geometry1 const & geometry1,
      Geometry2 geometry2,
      Collection & output_collection);




[variablelist
  
[[Geometry][geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to make difference ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/difference.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:dimension dimension]


Meta-function which defines coordinate dimensions, i.e. the number of axes of any geometry. 


  template<
      typename G >
  struct dimension
[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:disjoint disjoint]

[indexterm1 disjoint] 
Calculate if two geometries are disjoint. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool disjoint(
      const Geometry1 & geometry1,
      const Geometry2 & geometry2);




[variablelist
  
[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

]


[heading Return Value]
      
true if disjoint, else false 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/disjoint.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:dissolve dissolve]

[indexterm1 dissolve] 
Removes self intersections from a geometry. 


  template<
      typename Geometry ,
      typename OutputIterator >
  OutputIterator dissolve(
      Geometry const & geometry,
      OutputIterator output);




[variablelist
  
[[Geometry][geometry type ]]

[[OutputIterator][type of intersection container (e.g. vector of "intersection/turn point"'s) ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][first geometry ]]

[[output][container which will contain intersection points ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/dissolve.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:distance distance]

[indexterm1 distance] 
      
  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  Strategy::return_type ``[link boost_geometry.reference.distance.overload1 distance]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.distance.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 >
  distance_result< Geometry1, Geometry2 >::type ``[link boost_geometry.reference.distance.overload2 distance]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);
  ``  [''''&raquo;''' [link boost_geometry.reference.distance.overload2 more...]]``

The distance algorithm returns the distance between two geometries. 
[heading Coordinate systems and strategies:]
  
With help of strategies the distance function returns the appropriate distance. If the input is in cartesian coordinates, the Euclidian distance (Pythagoras) is calculated. If the input is in spherical coordinates (either degree or radian), the distance over the sphere is returned. If the input is in geographic coordinates, distance is calculated over the globe and returned in meters.


[heading Distance result:]
  
Depending on calculation type the distance result is either a structure, convertable to a double, or a double value. In case of Pythagoras it makes sense to not draw the square root in the strategy itself. Taking a square root is relative expensive and is not necessary when comparing distances.


[heading Geometries:]
  
Currently implemented, for both cartesian and spherical/geographic:
* POINT - POINT

* POINT - SEGMENT and v.v.

* POINT - LINESTRING and v.v.



Not yet implemented:
* POINT - RING etc, note that it will return a zero if the point is anywhere within the ring




[heading Example:]
  
Example showing distance calculation of two points, in xy and in latlong coordinates  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/distance.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 distance (1 of 2 overloads)]


Calculate distance between two geometries with a specified strategy. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  Strategy::return_type distance(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);




[variablelist
  
[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

[[S][point-point-distance strategy type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

[[strategy][strategy to calculate distance between two points ]]

]


[heading Return Value]
      
the distance (either a double or a distance\_result, (convertable to double)) 


[heading Remarks]
      
The strategy can be a point-point strategy. In case of distance point-line/point-polygon it may also be a point-segment strategy. 


[heading Example:]
  
Example showing distance calculation of two lat long points, using the accurate Vincenty approximation  








[endsect]



[section:overload2 distance (2 of 2 overloads)]


Calculate distance between two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  distance_result< Geometry1, Geometry2 >::type distance(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);


The default strategy is used, belonging to the corresponding coordinate system of the geometries 

[variablelist
  
[[G1][first geometry type ]]

[[G2][second geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

]


[heading Return Value]
      
the distance (either a double or a distance result, convertable to double) 




[endsect]


[endsect]


[section:divide_point divide_point]

[indexterm1 divide_point] 
Divides a point by another. 


  template<
      typename Point1 ,
      typename Point2 >
  void divide_point(
      Point1 & p1,
      Point2 const & p2);


The coordinates of the second point will be divided by those of the first point. The second point is not modified. 
[heading Parameters]
    

[variablelist
  
[[p1][first point ]]

[[p2][second point ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:divide_value divide_value]

[indexterm1 divide_value] 
Divides each coordinate of a point by a value. 


  template<
      typename Point >
  void divide_value(
      Point & p,
      typename detail::param< Point >::type value);



[heading Parameters]
    

[variablelist
  
[[p][point ]]

[[value][value to divide by ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:dot_product dot_product]

[indexterm1 dot_product] 
Computes the dot product (or scalar product) of 2 vectors (points). 


  template<
      typename P1 ,
      typename P2 >
  select_coordinate_type< P1, P2 >::type dot_product(
      P1 const & p1,
      P2 const & p2);



[heading Parameters]
    

[variablelist
  
[[p1][first point ]]

[[p2][second point ]]

]


[heading Return Value]
      
the dot product 



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/dot_product.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:enrich_intersection_points enrich_intersection_points]

[indexterm1 enrich_intersection_points] 
All intersection points are enriched with successor information. 


  template<
      typename TurnPoints ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  void enrich_intersection_points(
      TurnPoints & turn_points,
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);




[variablelist
  
[[TurnPoints][type of intersection container (e.g. vector of "intersection/turn point"'s) ]]

]


[heading Parameters]
    

[variablelist
  
[[turn_points][container containing intersectionpoints ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/enrich_intersection_points.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:envelope envelope]

[indexterm1 envelope] 
Calculate envelope of a geometry. 


  template<
      typename Geometry ,
      typename Box >
  void envelope(
      Geometry const & geometry,
      Box & mbr);



[heading Parameters]
    

[variablelist
  
[[geometry][the geometry ]]

[[mbr][the box receiving the envelope ]]

]


[heading Example:]
  
Example showing envelope calculation, using point\_ll latlong points  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/envelope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:equals equals]

[indexterm1 equals] 
Detect if two geometries are spatially equal. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool equals(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);




[variablelist
  
[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

]


[heading Return Value]
      
true if geometries are spatially equal, else false 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/equals.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:exception exception]


Base exception class for GGL. 


  struct exception
[heading Requirements]

[*Header: ][^boost/geometry/core/exception.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:exterior_ring exterior_ring]

[indexterm1 exterior_ring] 
Function to get the exterior\_ring ring of a polygon. 

    
  template<
      typename Polygon >
  ring_type< Polygon >::type & ``[link boost_geometry.reference.exterior_ring.overload1 exterior_ring]``(
      Polygon & polygon);
  ``  [''''&raquo;''' [link boost_geometry.reference.exterior_ring.overload1 more...]]``

  template<
      typename Polygon >
  const ring_type< Polygon >::type & ``[link boost_geometry.reference.exterior_ring.overload2 exterior_ring]``(
      Polygon const & polygon);
  ``  [''''&raquo;''' [link boost_geometry.reference.exterior_ring.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/core/exterior_ring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 exterior_ring (1 of 2 overloads)]


Function to get the exterior\_ring ring of a polygon. 


  template<
      typename Polygon >
  ring_type< Polygon >::type & exterior_ring(
      Polygon & polygon);



[heading Remarks]
      
OGC compliance: instead of ExteriorRing 



[variablelist
  
[[P][polygon type ]]

]


[heading Parameters]
    

[variablelist
  
[[polygon][the polygon to get the exterior ring from ]]

]


[heading Return Value]
      
a reference to the exterior ring 




[endsect]



[section:overload2 exterior_ring (2 of 2 overloads)]


Function to get the exterior ring of a polygon (const version). 


  template<
      typename Polygon >
  const ring_type< Polygon >::type & exterior_ring(
      Polygon const & polygon);



[heading Remarks]
      
OGC compliance: instead of ExteriorRing 



[variablelist
  
[[Polygon][polygon type ]]

]


[heading Parameters]
    

[variablelist
  
[[polygon][the polygon to get the exterior ring from ]]

]


[heading Return Value]
      
a const reference to the exterior ring 




[endsect]


[endsect]

[section:for_each_point for_each_point]

[indexterm1 for_each_point] 
Calls functor for geometry. 

    
  template<
      typename Geometry ,
      typename Functor >
  Functor ``[link boost_geometry.reference.for_each_point.overload1 for_each_point]``(
      Geometry const & geometry,
      Functor f);
  ``  [''''&raquo;''' [link boost_geometry.reference.for_each_point.overload1 more...]]``

  template<
      typename Geometry ,
      typename Functor >
  Functor ``[link boost_geometry.reference.for_each_point.overload2 for_each_point]``(
      Geometry & geometry,
      Functor f);
  ``  [''''&raquo;''' [link boost_geometry.reference.for_each_point.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/for_each.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 for_each_point (1 of 2 overloads)]


Calls functor for geometry. 


  template<
      typename Geometry ,
      typename Functor >
  Functor for_each_point(
      Geometry const & geometry,
      Functor f);



[heading Parameters]
    

[variablelist
  
[[geometry][geometry to loop through ]]

[[f][functor to use]]

]

Calls the functor the specified const geometry 


[endsect]



[section:overload2 for_each_point (2 of 2 overloads)]


Calls functor for geometry. 


  template<
      typename Geometry ,
      typename Functor >
  Functor for_each_point(
      Geometry & geometry,
      Functor f);



[heading Parameters]
    

[variablelist
  
[[geometry][geometry to loop through ]]

[[f][functor to use]]

]

Calls the functor for the specified geometry 


[endsect]


[endsect]

[section:for_each_segment for_each_segment]

[indexterm1 for_each_segment] 
Calls functor for segments on linestrings, rings, polygons, ... 

    
  template<
      typename Geometry ,
      typename Functor >
  Functor ``[link boost_geometry.reference.for_each_segment.overload1 for_each_segment]``(
      Geometry const & geometry,
      Functor f);
  ``  [''''&raquo;''' [link boost_geometry.reference.for_each_segment.overload1 more...]]``

  template<
      typename Geometry ,
      typename Functor >
  Functor ``[link boost_geometry.reference.for_each_segment.overload2 for_each_segment]``(
      Geometry & geometry,
      Functor f);
  ``  [''''&raquo;''' [link boost_geometry.reference.for_each_segment.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/for_each.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 for_each_segment (1 of 2 overloads)]


Calls functor for segments on linestrings, rings, polygons, ... 


  template<
      typename Geometry ,
      typename Functor >
  Functor for_each_segment(
      Geometry const & geometry,
      Functor f);



[heading Parameters]
    

[variablelist
  
[[geometry][geometry to loop through ]]

[[f][functor to use]]

]

Calls the functor all const segments of the specified const geometry 


[endsect]



[section:overload2 for_each_segment (2 of 2 overloads)]


Calls functor for segments on linestrings, rings, polygons, ... 


  template<
      typename Geometry ,
      typename Functor >
  Functor for_each_segment(
      Geometry & geometry,
      Functor f);



[heading Parameters]
    

[variablelist
  
[[geometry][geometry to loop through ]]

[[f][functor to use]]

]

Calls the functor all segments of the specified geometry 


[endsect]


[endsect]

[section:geographic_tag geographic_tag]


Tag indicating Geographic coordinate system family (geographic). 


  struct geographic_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:geometry_id geometry_id]


Meta-function the id for a geometry type. 


  template<
      typename Geometry >
  struct geometry_id

[heading Remarks]
      
Used for e.g. reverse meta-function 



[heading Requirements]

[*Header: ][^boost/geometry/core/geometry_id.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:geometry_not_recognized_tag geometry_not_recognized_tag]


"default" tag 


  struct geometry_not_recognized_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:get get]

[indexterm1 get] 
get coordinate value of a Point ( / Sphere) 

    
  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type ``[link boost_geometry.reference.get.overload1 get]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.get.overload1 more...]]``

  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type ``[link boost_geometry.reference.get.overload2 get]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.get.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 get (1 of 2 overloads)]


get coordinate value of a Point ( / Sphere) 


  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type get(
      Geometry const & geometry);




[variablelist
  
[[Dimension][dimension ]]

[[Geometry][geometry ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry to query coordinate value from ]]

]


[heading Return Value]
      
coordinate value 




[endsect]



[section:overload2 get (2 of 2 overloads)]


get coordinate value of a Box / Segment 


  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type get(
      Geometry const & geometry);




[variablelist
  
[[Index][for Point: do not specifyfor Box: min\_corner or max\_cornerfor Segment: 0 / 1 
]]

[[Dimension][dimension ]]

[[Geometry][geometry ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry to query coordinate value from ]]

]


[heading Return Value]
      
coordinate value 




[endsect]


[endsect]


[section:get_as_radian get_as_radian]

[indexterm1 get_as_radian] 
get coordinate value of a point, result is in Radian 


  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  coordinate_type< Geometry >::type get_as_radian(
      const Geometry & geometry);


Result is in Radian, even if source coordinate system is in Degrees 
[heading Return Value]
      
coordinate value



[variablelist
  
[[Dimension][dimension ]]

[[Geometry][geometry ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry to get coordinate value from ]]

]


[heading Remarks]
      
Only applicable to coordinate systems templatized by units, e.g. spherical or geographic coordinate systems 



[heading Requirements]

[*Header: ][^boost/geometry/core/radian_access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:get_section get_section]

[indexterm1 get_section] 
Get iterators for a specified section. 


  template<
      typename Geometry ,
      typename Section >
  void get_section(
      Geometry const & geometry,
      Section const & section,
      typename boost::range_const_iterator< typename geometry::range_type< Geometry >::type >::type & begin,
      typename boost::range_const_iterator< typename geometry::range_type< Geometry >::type >::type & end);




[variablelist
  
[[Geometry][type ]]

[[Section][type of section to get from ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry which might be located in the neighborhood ]]

[[section][structure with section ]]

[[begin][begin-iterator (const iterator over points of section) ]]

[[end][end-iterator (const iterator over points of section) ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/get_section.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:get_turns get_turns]

[indexterm1 get_turns] 
Calculate intersection points of two geometries. 

    
  template<
      typename AssignPolicy ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename Turns ,
      typename InterruptPolicy >
  void ``[link boost_geometry.reference.get_turns.overload1 get_turns]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Turns & turns,
      InterruptPolicy & interrupt_policy);
  ``  [''''&raquo;''' [link boost_geometry.reference.get_turns.overload1 more...]]``

  template<
      typename AssignPolicy ,
      typename Geometry ,
      typename Turns ,
      typename InterruptPolicy >
  void ``[link boost_geometry.reference.get_turns.overload2 get_turns]``(
      Geometry const & geometry,
      Turns & turns,
      InterruptPolicy & interrupt_policy);
  ``  [''''&raquo;''' [link boost_geometry.reference.get_turns.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/get_turns.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 get_turns (1 of 2 overloads)]


Calculate intersection points of two geometries. 


  template<
      typename AssignPolicy ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename Turns ,
      typename InterruptPolicy >
  void get_turns(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Turns & turns,
      InterruptPolicy & interrupt_policy);




[variablelist
  
[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

[[Turns][type of turn-container (e.g. vector of "intersection/turn point"'s) ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

[[turns][container which will contain intersection points ]]

]




[endsect]



[section:overload2 get_turns (2 of 2 overloads)]


Calculate self intersections of a geometry. 


  template<
      typename AssignPolicy ,
      typename Geometry ,
      typename Turns ,
      typename InterruptPolicy >
  void get_turns(
      Geometry const & geometry,
      Turns & turns,
      InterruptPolicy & interrupt_policy);




[variablelist
  
[[Geometry][geometry type ]]

[[Turns][type of intersection container (e.g. vector of "intersection/turn point"'s) ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry ]]

[[turns][container which will contain intersection points ]]

]




[endsect]


[endsect]

[section:interior_rings interior_rings]

[indexterm1 interior_rings] 
Function to get the interior rings of a polygon (non const version). 

    
  template<
      typename Polygon >
  interior_type< Polygon >::type & ``[link boost_geometry.reference.interior_rings.overload1 interior_rings]``(
      Polygon & polygon);
  ``  [''''&raquo;''' [link boost_geometry.reference.interior_rings.overload1 more...]]``

  template<
      typename Polygon >
  const interior_type< Polygon >::type & ``[link boost_geometry.reference.interior_rings.overload2 interior_rings]``(
      Polygon const & polygon);
  ``  [''''&raquo;''' [link boost_geometry.reference.interior_rings.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 interior_rings (1 of 2 overloads)]


Function to get the interior rings of a polygon (non const version). 


  template<
      typename Polygon >
  interior_type< Polygon >::type & interior_rings(
      Polygon & polygon);



[heading Remarks]
      
OGC compliance: instead of InteriorRingN 



[variablelist
  
[[P][polygon type ]]

]


[heading Parameters]
    

[variablelist
  
[[polygon][the polygon to get the interior rings from ]]

]


[heading Return Value]
      
a reference to the interior rings 




[endsect]



[section:overload2 interior_rings (2 of 2 overloads)]


Function to get the interior rings of a polygon (const version). 


  template<
      typename Polygon >
  const interior_type< Polygon >::type & interior_rings(
      Polygon const & polygon);



[heading Remarks]
      
OGC compliance: instead of InteriorRingN 



[variablelist
  
[[P][polygon type ]]

]


[heading Parameters]
    

[variablelist
  
[[polygon][the polygon to get the interior rings from ]]

]


[heading Return Value]
      
a const reference to the interior rings 




[endsect]


[endsect]

[section:interior_type interior_type]


Meta-function defining container type of inner rings of (multi)polygon geometriy. 


  template<
      typename Geometry >
  struct interior_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.interior_type.type [*type]]]
    []
  
  ]

]

the interior rings should be organized as a container (std::vector, std::deque, boost::array) with boost range support. This meta function defines the type of that container. 

[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type interior_type::type]

[indexterm2 type..interior_type] 

  typedef core_dispatch::interior_type< typename tag< Geometry >::type, Geometry >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their geometry type (point, linestring, polygon, etc) by implementing a tag traits class. This meta-function uses that traits class to retrieve the tag. If the input type is not a geometry at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][geometry ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]


[section:intersection intersection]

[indexterm1 intersection] 
Intersects two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Collection >
  void intersection(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Collection & output_collection);


The two input geometries are intersected and the resulting linestring(s), ring(s) or polygon(s) are added to the specified collection. 

[variablelist
  
[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

[[Collection][collection of rings, polygons (e.g. a vector<polygon> or a multi\_polygon) ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

[[output_collection][the collection ]]

]


[heading Return Value]
      
true if successful 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/intersection.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:intersection_inserter intersection_inserter]

[indexterm1 intersection_inserter] 
Intersects two geometries. 

    
  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator ``[link boost_geometry.reference.intersection_inserter.overload1 intersection_inserter]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.intersection_inserter.overload1 more...]]``

  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator >
  OutputIterator ``[link boost_geometry.reference.intersection_inserter.overload2 intersection_inserter]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out);
  ``  [''''&raquo;''' [link boost_geometry.reference.intersection_inserter.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/intersection.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 intersection_inserter (1 of 2 overloads)]


Intersects two geometries. 


  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator intersection_inserter(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out,
      Strategy const & strategy);


The two input geometries are intersected and the resulting linestring(s), ring(s) or polygon(s) are sent to the specified output operator. 

[variablelist
  
[[GeometryOut][output geometry type, must be specified ]]

[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

[[OutputIterator][output iterator ]]

[[Strategy][compound strategy for intersection ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

[[out][the output iterator, outputting linestrings or polygons ]]

[[strategy][the strategy ]]

]


[heading Return Value]
      
the output iterator 




[endsect]



[section:overload2 intersection_inserter (2 of 2 overloads)]


Intersects two geometries. 


  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator >
  OutputIterator intersection_inserter(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out);


The two input geometries are intersected and the resulting linestring(s), ring(s) or polygon(s) are sent to the specified output operator. 

[variablelist
  
[[GeometryOut][output geometry type, must be specified ]]

[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

[[OutputIterator][output iterator ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

[[out][the output iterator, outputting linestrings or polygons ]]

]


[heading Return Value]
      
the output iterator 




[endsect]


[endsect]

[section:intersects intersects]

[indexterm1 intersects] 
      
  template<
      typename Geometry >
  bool ``[link boost_geometry.reference.intersects.overload1 intersects]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.intersects.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool ``[link boost_geometry.reference.intersects.overload2 intersects]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);
  ``  [''''&raquo;''' [link boost_geometry.reference.intersects.overload2 more...]]``


[heading Source descriptions:]
  

* OGC description: Returns 1 (TRUE) if this geometric object spatially intersects anotherGeometry.

* OGC: a.Intersects(b) <=> ! a.Disjoint(b) 




[heading Remarks]
      
There are two overloaded versions:
* with one geometry, detecting self-intersections

* with two geometries, deferring to disjoint, returning !disjoint




[heading Geometries:]
  

* ring 

* polygon 

* for two geometries: same is disjoint




[heading Remarks]
      
if one geometry is completely within another geometry, it "intersects" 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/intersects.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 intersects (1 of 2 overloads)]


Determine if there is at least one intersection (crossing or self-tangency). 


  template<
      typename Geometry >
  bool intersects(
      Geometry const & geometry);



[heading Remarks]
      
This function can be called for one geometry (self-intersection) and also for two geometries (intersection)



[variablelist
  
[[Geometry][geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry ]]

]


[heading Return Value]
      
true if there are intersections, else false 




[endsect]



[section:overload2 intersects (2 of 2 overloads)]


Determine if there is at least one intersection. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool intersects(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);




[variablelist
  
[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

]


[heading Return Value]
      
true if there are intersection(s), else false 




[endsect]


[endsect]

[section:is_linear is_linear]


Meta-function defining "true" for linear types (linestring,ring), "false" for non-linear typse. 


  template<
      typename Geometry >
  struct is_linear

[heading Remarks]
      
Used for tag dispatching and meta-function finetuning 



[heading Requirements]

[*Header: ][^boost/geometry/core/is_linear.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:is_multi is_multi]


Meta-function defining "true" for multi geometries (multi\_point, etc). 


  template<
      typename Geometry >
  struct is_multi
[heading Requirements]

[*Header: ][^boost/geometry/core/is_multi.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:is_radian is_radian]


Meta-function to verify if a coordinate system is radian. 


  template<
      typename CoordinateSystem >
  struct is_radian
[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:length length]

[indexterm1 length] 
      
  template<
      typename Geometry >
  length_result< Geometry >::type ``[link boost_geometry.reference.length.overload1 length]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.length.overload1 more...]]``

  template<
      typename Geometry ,
      typename Strategy >
  length_result< Geometry >::type ``[link boost_geometry.reference.length.overload2 length]``(
      Geometry const & geometry,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.length.overload2 more...]]``

The length algorithm is implemented for the linestring and the multi\_linestring geometry and results in the length of the linestring. If the points of a linestring have coordinates expressed in kilometers, the length of the line is expressed in kilometers as well. 
[heading Example:]
  
Example showing length calculation  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/length.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 length (1 of 2 overloads)]


Calculate length of a geometry. 


  template<
      typename Geometry >
  length_result< Geometry >::type length(
      Geometry const & geometry);


The function length returns the length of a geometry, using the default distance-calculation-strategy 
[heading Parameters]
    

[variablelist
  
[[geometry][the geometry, being a [link boost_geometry.reference.linestring `linestring`], vector, iterator pair, or any other boost compatible range ]]

]


[heading Return Value]
      
the length Example showing length calculation on a vector  








[endsect]



[section:overload2 length (2 of 2 overloads)]


Calculate length of a geometry. 


  template<
      typename Geometry ,
      typename Strategy >
  length_result< Geometry >::type length(
      Geometry const & geometry,
      Strategy const & strategy);


The function length returns the length of a geometry, using specified strategy 
[heading Parameters]
    

[variablelist
  
[[geometry][the geometry, being a [link boost_geometry.reference.linestring `linestring`], vector, iterator pair, or any other boost compatible range ]]

[[strategy][strategy to be used for distance calculations. ]]

]


[heading Return Value]
      
the length 


[heading Example:]
  
Example showing length calculation using iterators and the Vincenty strategy  








[endsect]


[endsect]

[section:linear_ring linear_ring]


A [link boost_geometry.reference.linear_ring `linear_ring`] (linear [link boost_geometry.reference.linear_ring `linear_ring`]) is a closed line which should not be selfintersecting. 


  template<
      typename ``[link boost_geometry.reference.P P]``,
      template< typename, typename > class ``[link boost_geometry.reference.V V]`` = std::vector,
      bool ``[link boost_geometry.reference.ClockWise ClockWise]`` = true,
      template< typename > class ``[link boost_geometry.reference.A A]`` = std::allocator>
  class linear_ring


[variablelist
  
[[P][point type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/linear_ring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:linestring linestring]


A linestring (named so by OGC) is a collection (default a vector) of points. 


  template<
      typename P ,
      template< typename, typename > class ``[link boost_geometry.reference.V V]`` = std::vector,
      template< typename > class ``[link boost_geometry.reference.A A]`` = std::allocator>
  class linestring


[variablelist
  
[[P][point type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type (see http://accu.org/index.php/journals/427#ftn.d0e249 ) ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/linestring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:linestring_2d linestring_2d]

[indexterm1 linestring_2d] 

  typedef linestring< point_2d > linestring_2d;


[heading Typedef Description]
    


[variablelist
  
[[P][point type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type (see http://accu.org/index.php/journals/427#ftn.d0e249 ) ]]

]





[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:linestring_3d linestring_3d]

[indexterm1 linestring_3d] 

  typedef linestring< point_3d > linestring_3d;


[heading Typedef Description]
    


[variablelist
  
[[P][point type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type (see http://accu.org/index.php/journals/427#ftn.d0e249 ) ]]

]





[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:linestring_tag linestring_tag]


OGC Linestring identifying tag. 


  struct linestring_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:make make]

[indexterm1 make] 
Make a geometry. 

    
  template<
      typename Geometry ,
      typename T >
  Geometry ``[link boost_geometry.reference.make.overload1 make]``(
      T const & c1,
      T const & c2);
  ``  [''''&raquo;''' [link boost_geometry.reference.make.overload1 more...]]``

  template<
      typename Geometry ,
      typename T >
  Geometry ``[link boost_geometry.reference.make.overload2 make]``(
      T const & c1,
      T const & c2,
      T const & c3);
  ``  [''''&raquo;''' [link boost_geometry.reference.make.overload2 more...]]``

  template<
      typename Geometry ,
      typename T >
  Geometry ``[link boost_geometry.reference.make.overload3 make]``(
      T const & c1,
      T const & c2,
      T const & c3,
      T const & c4);
  ``  [''''&raquo;''' [link boost_geometry.reference.make.overload3 more...]]``

  template<
      typename Geometry ,
      typename Range >
  Geometry ``[link boost_geometry.reference.make.overload4 make]``(
      Range const & range);
  ``  [''''&raquo;''' [link boost_geometry.reference.make.overload4 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/make.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 make (1 of 4 overloads)]


Make a geometry. 


  template<
      typename Geometry ,
      typename T >
  Geometry make(
      T const & c1,
      T const & c2);


the Generic Geometry Library uses concepts for all its geometries. Therefore it does not rely on constructors. The "make" functions are object generators creating geometries. There are overloads with two, three, four or six values, which are implemented depending on the geometry specified. 
[heading Remarks]
      
It does not work with array-point types, like int[2] 



[variablelist
  
[[G][the geometry type ]]

[[T][the coordinate type ]]

]


[heading Return Value]
      
the geometry 




[endsect]



[section:overload2 make (2 of 4 overloads)]


Make a geometry. 


  template<
      typename Geometry ,
      typename T >
  Geometry make(
      T const & c1,
      T const & c2,
      T const & c3);



[heading Return Value]
      
a 3D point 




[endsect]



[section:overload3 make (3 of 4 overloads)]



  template<
      typename Geometry ,
      typename T >
  Geometry make(
      T const & c1,
      T const & c2,
      T const & c3,
      T const & c4);



[endsect]



[section:overload4 make (4 of 4 overloads)]



  template<
      typename Geometry ,
      typename Range >
  Geometry make(
      Range const & range);



[endsect]


[endsect]


[section:make_buffer make_buffer]

[indexterm1 make_buffer] 
Calculate and return buffer (= new geometry) around specified distance of geometry. 


  template<
      typename Output ,
      typename Input ,
      typename T >
  Output make_buffer(
      Input const & geometry,
      T const & distance,
      T const & chord_length = -1);



[heading Parameters]
    

[variablelist
  
[[geometry][input geometry ]]

[[distance][the distance used in buffer ]]

[[chord_length][length of the chord's in the generated arcs around points or bends ]]

]


[heading Return Value]
      
the buffered geometry 


[heading Remarks]
      
See also: buffer 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/buffer.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:make_centroid make_centroid]

[indexterm1 make_centroid] 
Calculate and return centroid. 

    
  template<
      typename Point ,
      typename Geometry >
  Point ``[link boost_geometry.reference.make_centroid.overload1 make_centroid]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.make_centroid.overload1 more...]]``

  template<
      typename Point ,
      typename Geometry ,
      typename Strategy >
  Point ``[link boost_geometry.reference.make_centroid.overload2 make_centroid]``(
      Geometry const & geometry,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.make_centroid.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/centroid.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 make_centroid (1 of 2 overloads)]


Calculate and return centroid. 


  template<
      typename Point ,
      typename Geometry >
  Point make_centroid(
      Geometry const & geometry);



[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to calculate centroid from ]]

]


[heading Return Value]
      
the centroid 




[endsect]



[section:overload2 make_centroid (2 of 2 overloads)]


Calculate and return centroid, using a specified strategy. 


  template<
      typename Point ,
      typename Geometry ,
      typename Strategy >
  Point make_centroid(
      Geometry const & geometry,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to calculate centroid from ]]

[[strategy][Calculation strategy for centroid ]]

]


[heading Return Value]
      
the centroid 




[endsect]


[endsect]


[section:make_envelope make_envelope]

[indexterm1 make_envelope] 
Calculate and return envelope of a geometry. 


  template<
      typename Box ,
      typename Geometry >
  Box make_envelope(
      Geometry const & geometry);



[heading Parameters]
    

[variablelist
  
[[geometry][the geometry ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/envelope.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:make_inverse make_inverse]

[indexterm1 make_inverse] 
Create a box with inverse infinite coordinates. 


  template<
      typename Geometry >
  Geometry make_inverse();


The make\_inverse function initialize a 2D or 3D box with large coordinates, the min corner is very large, the max corner is very small 

[variablelist
  
[[Geometry][the geometry type ]]

]


[heading Return Value]
      
the box 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/make.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:make_zero make_zero]

[indexterm1 make_zero] 
Create a geometry with "zero" coordinates. 


  template<
      typename Geometry >
  Geometry make_zero();


The make\_zero function initializes a 2D or 3D point or box with coordinates of zero 

[variablelist
  
[[Geometry][the geometry type ]]

]


[heading Return Value]
      
the geometry 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/make.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:max_corner max_corner]

[indexterm1 max_corner] 
Index of maximum corner of the box. 


  const int max_corner = 1;


[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:min_corner min_corner]

[indexterm1 min_corner] 
Index of minimum corner of the box. 


  const int min_corner = 0;


[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:multiply_point multiply_point]

[indexterm1 multiply_point] 
Multiplies a point by another. 


  template<
      typename Point1 ,
      typename Point2 >
  void multiply_point(
      Point1 & p1,
      Point2 const & p2);


The coordinates of the second point will be multiplied by those of the first point. The second point is not modified. 
[heading Parameters]
    

[variablelist
  
[[p1][first point ]]

[[p2][second point ]]

]


[heading Remarks]
      
This is *not* a dot, cross or wedge product. It is a mere field-by-field multiplication. 



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:multiply_value multiply_value]

[indexterm1 multiply_value] 
Multiplies each coordinate of a point by a value. 


  template<
      typename Point >
  void multiply_value(
      Point & p,
      typename detail::param< Point >::type value);



[heading Parameters]
    

[variablelist
  
[[p][point ]]

[[value][value to multiply by ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:num_geometries num_geometries]

[indexterm1 num_geometries] 
Function to get the number of geometries of a composite geometry. For a single geometry it is always 0 (also for a polygon with holes). 


  template<
      typename Geometry >
  std::size_t num_geometries(
      Geometry const & geometry);




[variablelist
  
[[Geometry][geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the polygon or other geometry ]]

]


[heading Return Value]
      
the number of interior rings of the geometry 



[heading Requirements]

[*Header: ][^boost/geometry/core/num_geometries.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:num_interior_rings num_interior_rings]

[indexterm1 num_interior_rings] 
Function to get the number of interior rings of a polygon. 


  template<
      typename Geometry >
  std::size_t num_interior_rings(
      Geometry const & geometry);



[heading Remarks]
      
Defined by OGC as "numInteriorRing". To be consistent with "numPoints" letter "s" is appended 

Can be used for any geometry, returning 0 for geometries not having interior rings 



[variablelist
  
[[Geometry][geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the polygon or other geometry ]]

]


[heading Return Value]
      
the number of interior rings of the geometry 



[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:num_points num_points]

[indexterm1 num_points] 
get number of points 


  template<
      typename Geometry >
  std::size_t num_points(
      Geometry const & geometry);




[variablelist
  
[[Geometry][geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to get number of points from ]]

]


[heading Return Value]
      
number of points 


[heading Remarks]
      
For linestrings/rings also boost::size or .size() could be used, however, for polygons this is less obvious. So this function is provided. Besides that it is described by OGC (numPoints) 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/num_points.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:order_selector order_selector]

[indexterm1 order_selector] 

  enum order_selector

[indexterm2 clockwise..order_selector]
[indexterm2 counterclockwise..order_selector]
[indexterm2 order_undetermined..order_selector]

[heading Values]
[variablelist

  [
    [clockwise]
    []
  ]

  [
    [counterclockwise]
    []
  ]

  [
    [order_undetermined]
    []
  ]

]


[heading Requirements]

[*Header: ][^boost/geometry/core/point_order.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:overlaps overlaps]

[indexterm1 overlaps] 
Determines overlap between two geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool overlaps(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);



[heading Return Value]
      
true if there is overlap 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlaps.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:parse parse]

[indexterm1 parse] 
      
  template<
      typename Geometry >
  void ``[link boost_geometry.reference.parse.overload1 parse]``(
      Geometry & geometry,
      std::string const & c1,
      std::string const & c2);
  ``  [''''&raquo;''' [link boost_geometry.reference.parse.overload1 more...]]``

  template<
      typename Geometry ,
      typename S >
  void ``[link boost_geometry.reference.parse.overload2 parse]``(
      Geometry & geometry,
      std::string const & c1,
      std::string const & c2,
      S const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.parse.overload2 more...]]``

  template<
      typename Geometry >
  Geometry ``[link boost_geometry.reference.parse.overload3 parse]``(
      std::string const & c1,
      std::string const & c2);
  ``  [''''&raquo;''' [link boost_geometry.reference.parse.overload3 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/parse.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 parse (1 of 3 overloads)]


parse two strings to a spherical/geographic point, using W/E/N/S 


  template<
      typename Geometry >
  void parse(
      Geometry & geometry,
      std::string const & c1,
      std::string const & c2);



[endsect]



[section:overload2 parse (2 of 3 overloads)]


parse two strings to a spherical/geographic point, using a specified strategy 


  template<
      typename Geometry ,
      typename S >
  void parse(
      Geometry & geometry,
      std::string const & c1,
      std::string const & c2,
      S const & strategy);


user can use N/E/S/O or N/O/Z/W or other formats 


[endsect]



[section:overload3 parse (3 of 3 overloads)]



  template<
      typename Geometry >
  Geometry parse(
      std::string const & c1,
      std::string const & c2);



[endsect]


[endsect]

[section:perimeter perimeter]

[indexterm1 perimeter] 
      
  template<
      typename Geometry >
  length_result< Geometry >::type ``[link boost_geometry.reference.perimeter.overload1 perimeter]``(
      Geometry const & geometry);
  ``  [''''&raquo;''' [link boost_geometry.reference.perimeter.overload1 more...]]``

  template<
      typename Geometry ,
      typename Strategy >
  length_result< Geometry >::type ``[link boost_geometry.reference.perimeter.overload2 perimeter]``(
      Geometry const & geometry,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.perimeter.overload2 more...]]``


[heading Geometries:]
  

* polygon 

* box 

* linear_ring 

* multi_polygon 





[heading Requirements]

[*Header: ][^boost/geometry/algorithms/perimeter.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 perimeter (1 of 2 overloads)]


Calculate perimeter of a geometry. 


  template<
      typename Geometry >
  length_result< Geometry >::type perimeter(
      Geometry const & geometry);


The function perimeter returns the perimeter of a geometry, using the default distance-calculation-strategy 
[heading Parameters]
    

[variablelist
  
[[geometry][the geometry, be it a geometry::ring, vector, iterator pair, or any other boost compatible range ]]

]


[heading Return Value]
      
the perimeter 




[endsect]



[section:overload2 perimeter (2 of 2 overloads)]


Calculate perimeter of a geometry. 


  template<
      typename Geometry ,
      typename Strategy >
  length_result< Geometry >::type perimeter(
      Geometry const & geometry,
      Strategy const & strategy);


The function perimeter returns the perimeter of a geometry, using specified strategy 
[heading Parameters]
    

[variablelist
  
[[geometry][the geometry, be it a geometry::ring, vector, iterator pair, or any other boost compatible range ]]

[[strategy][strategy to be used for distance calculations. ]]

]


[heading Return Value]
      
the perimeter 




[endsect]


[endsect]

[section:point point]


Basic point class, having coordinates defined in a neutral way. 


  template<
      typename T,
      std::size_t ``[link boost_geometry.reference.D D]``,
      typename ``[link boost_geometry.reference.C C]``>
  class point

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point.coordinate_system [*coordinate_system]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point.coordinate_type [*coordinate_type]]]
    []
  
  ]

]

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point.get [*get]]]
    [Compile time access to coordinate values. ]
  ]
  
  [
    [[link boost_geometry.reference.point.point [*point]]]
    [Default constructor, no initialization at all. 

     Constructs with one, or optionally two or three values. ]
  ]
  
  [
    [[link boost_geometry.reference.point.set [*set]]]
    []
  ]
  
]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point.coordinate_count [*coordinate_count]]]
    []
  ]

]



[variablelist
  
[[T][numeric type, for example double, float, int ]]

[[D][coordinate dimension as number of coordinates, for example 2 ]]

[[C][coordinate system, for example [link boost_geometry.reference.cs__cartesian `cs::cartesian`] ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:coordinate_count point::coordinate_count]

[indexterm2 coordinate_count..point] 

  static const std::size_t coordinate_count = D;



[endsect]



[section:coordinate_system point::coordinate_system]

[indexterm2 coordinate_system..point] 

  typedef C coordinate_system;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:coordinate_type point::coordinate_type]

[indexterm2 coordinate_type..point] 

  typedef T coordinate_type;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:get point::get]

[indexterm2 get..point] 
Compile time access to coordinate values. 


  template<
      std::size_t ``[link boost_geometry.reference.K K]``>
  T const & get() const;



[endsect]


[section:point point::point]

[indexterm2 point..point] 
Default constructor, no initialization at all. 


  ``[link boost_geometry.reference.point.point.overload1 point]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.point.point.overload1 more...]]``


Constructs with one, or optionally two or three values. 


  ``[link boost_geometry.reference.point.point.overload2 point]``(
      T const & v0,
      T const & v1 = 0,
      T const & v2 = 0);
  ``  [''''&raquo;''' [link boost_geometry.reference.point.point.overload2 more...]]``


[section:overload1 point::point (1 of 2 overloads)]


Default constructor, no initialization at all. 


  point();



[endsect]



[section:overload2 point::point (2 of 2 overloads)]


Constructs with one, or optionally two or three values. 


  point(
      T const & v0,
      T const & v1 = 0,
      T const & v2 = 0);



[endsect]


[endsect]


[section:set point::set]

[indexterm2 set..point] 

  template<
      std::size_t ``[link boost_geometry.reference.K K]``>
  void set(
      T value);



[endsect]



[endsect]


[section:point_2d point_2d]

[indexterm1 point_2d] 

  typedef point_xy< double, cs::cartesian > point_2d;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_xy.coordinate_system [*coordinate_system]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point_xy.coordinate_type [*coordinate_type]]]
    []
  
  ]

]

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_xy.get [*get]]]
    [Compile time access to coordinate values. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.point_xy [*point_xy]]]
    [Default constructor, does not initialize anything. 

     Constructor with x/y values. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.set [*set]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.point_xy.x [*x]]]
    [Get x-value. 

     Set x-value. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.y [*y]]]
    [Get y-value. 

     Set y-value. ]
  ]
  
]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_xy.coordinate_count [*coordinate_count]]]
    []
  ]

]

[heading Typedef Description]
    


[variablelist
  
[[T][numeric type, arguments can be, for example, double, float, int ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:point_3d point_3d]

[indexterm1 point_3d] 

  typedef point< double, 3, cs::cartesian > point_3d;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point.coordinate_system [*coordinate_system]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point.coordinate_type [*coordinate_type]]]
    []
  
  ]

]

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point.get [*get]]]
    [Compile time access to coordinate values. ]
  ]
  
  [
    [[link boost_geometry.reference.point.point [*point]]]
    [Default constructor, no initialization at all. 

     Constructs with one, or optionally two or three values. ]
  ]
  
  [
    [[link boost_geometry.reference.point.set [*set]]]
    []
  ]
  
]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point.coordinate_count [*coordinate_count]]]
    []
  ]

]

[heading Typedef Description]
    


[variablelist
  
[[T][numeric type, for example double, float, int ]]

[[D][coordinate dimension as number of coordinates, for example 2 ]]

[[C][coordinate system, for example [link boost_geometry.reference.cs__cartesian `cs::cartesian`] ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:point_order point_order]


Meta-function which defines point type of any geometry. 


  template<
      typename Geometry >
  struct point_order

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_order.ncg [*ncg]]]
    []
  
  ]

]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_order.value [*value]]]
    []
  ]

]

[heading Requirements]

[*Header: ][^boost/geometry/core/point_order.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:ncg point_order::ncg]

[indexterm2 ncg..point_order] 

  typedef boost::remove_const< Geometry >::type ncg;



[heading Requirements]

[*Header: ][^boost/geometry/core/point_order.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:value point_order::value]

[indexterm2 value..point_order] 

  static const order_selector value = core_dispatch::point_order
        <
            typename tag<Geometry>::type,
            ncg
        >::value;



[endsect]



[endsect]

[section:point_tag point_tag]


OGC Point identifying tag. 


  struct point_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:point_type point_type]


Meta-function which defines point type of any geometry. 


  template<
      typename Geometry >
  struct point_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_type.ncg [*ncg]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point_type.type [*type]]]
    []
  
  ]

]

[heading Requirements]

[*Header: ][^boost/geometry/core/point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:ncg point_type::ncg]

[indexterm2 ncg..point_type] 

  typedef boost::remove_const< Geometry >::type ncg;



[heading Requirements]

[*Header: ][^boost/geometry/core/point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:type point_type::type]

[indexterm2 type..point_type] 

  typedef core_dispatch::point_type< typename tag< Geometry >::type, ncg >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their geometry type (point, linestring, polygon, etc) by implementing a tag traits class. This meta-function uses that traits class to retrieve the tag. If the input type is not a geometry at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][geometry ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:point_xy point_xy]


2D point in Cartesian coordinate system 


  template<
      typename T ,
      typename C  = cs::cartesian>
  class point_xy :    public point< T, 2, C >

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.point_xy.coordinate_system [*coordinate_system]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.point_xy.coordinate_type [*coordinate_type]]]
    []
  
  ]

]

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_xy.get [*get]]]
    [Compile time access to coordinate values. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.point_xy [*point_xy]]]
    [Default constructor, does not initialize anything. 

     Constructor with x/y values. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.set [*set]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.point_xy.x [*x]]]
    [Get x-value. 

     Set x-value. ]
  ]
  
  [
    [[link boost_geometry.reference.point_xy.y [*y]]]
    [Get y-value. 

     Set y-value. ]
  ]
  
]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.point_xy.coordinate_count [*coordinate_count]]]
    []
  ]

]



[variablelist
  
[[T][numeric type, arguments can be, for example, double, float, int ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point_xy.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:coordinate_count point_xy::coordinate_count]


['Inherited from point.]

[indexterm2 coordinate_count..point_xy] 

  static const std::size_t coordinate_count;



[endsect]



[section:coordinate_system point_xy::coordinate_system]


['Inherited from point.]

[indexterm2 coordinate_system..point_xy] 

  typedef C coordinate_system;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point_xy.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:coordinate_type point_xy::coordinate_type]


['Inherited from point.]

[indexterm2 coordinate_type..point_xy] 

  typedef T coordinate_type;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/point_xy.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:get point_xy::get]


['Inherited from point.]

[indexterm2 get..point_xy] 
Compile time access to coordinate values. 


  T const & get() const;



[endsect]


[section:point_xy point_xy::point_xy]

[indexterm2 point_xy..point_xy] 
Default constructor, does not initialize anything. 


  ``[link boost_geometry.reference.point_xy.point_xy.overload1 point_xy]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.point_xy.overload1 more...]]``


Constructor with x/y values. 


  ``[link boost_geometry.reference.point_xy.point_xy.overload2 point_xy]``(
      T const & x,
      T const & y);
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.point_xy.overload2 more...]]``


[section:overload1 point_xy::point_xy (1 of 2 overloads)]


Default constructor, does not initialize anything. 


  point_xy();



[endsect]



[section:overload2 point_xy::point_xy (2 of 2 overloads)]


Constructor with x/y values. 


  point_xy(
      T const & x,
      T const & y);



[endsect]


[endsect]


[section:set point_xy::set]


['Inherited from point.]

[indexterm2 set..point_xy] 

  void set(
      T value);



[endsect]


[section:x point_xy::x]

[indexterm2 x..point_xy] 
Get x-value. 


  T const & ``[link boost_geometry.reference.point_xy.x.overload1 x]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.x.overload1 more...]]``


Set x-value. 


  void ``[link boost_geometry.reference.point_xy.x.overload2 x]``(
      T const & v);
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.x.overload2 more...]]``


[section:overload1 point_xy::x (1 of 2 overloads)]


Get x-value. 


  T const & x() const;



[endsect]



[section:overload2 point_xy::x (2 of 2 overloads)]


Set x-value. 


  void x(
      T const & v);



[endsect]


[endsect]

[section:y point_xy::y]

[indexterm2 y..point_xy] 
Get y-value. 


  T const & ``[link boost_geometry.reference.point_xy.y.overload1 y]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.y.overload1 more...]]``


Set y-value. 


  void ``[link boost_geometry.reference.point_xy.y.overload2 y]``(
      T const & v);
  ``  [''''&raquo;''' [link boost_geometry.reference.point_xy.y.overload2 more...]]``


[section:overload1 point_xy::y (1 of 2 overloads)]


Get y-value. 


  T const & y() const;



[endsect]



[section:overload2 point_xy::y (2 of 2 overloads)]


Set y-value. 


  void y(
      T const & v);



[endsect]


[endsect]


[endsect]

[section:polygon polygon]


The polygon contains an outer ring and zero or more inner rings. 


  template<
      typename Point ,
      template< typename, typename > class ``[link boost_geometry.reference.PointList PointList]`` = std::vector,
      template< typename, typename > class ``[link boost_geometry.reference.RingList RingList]`` = std::vector,
      bool ``[link boost_geometry.reference.ClockWise ClockWise]`` = true,
      template< typename > class ``[link boost_geometry.reference.PointAlloc PointAlloc]`` = std::allocator,
      template< typename > class ``[link boost_geometry.reference.RingAlloc RingAlloc]`` = std::allocator>
  class polygon

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.polygon.inner_container_type [*inner_container_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.ring_type [*ring_type]]]
    []
  
  ]

]

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.polygon.clear [*clear]]]
    [Utility method, clears outer and inner rings. ]
  ]
  
  [
    [[link boost_geometry.reference.polygon.inners [*inners]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.polygon.outer [*outer]]]
    []
  ]
  
]



[variablelist
  
[[P][point type ]]

[[PointList][optional container type for points, for example std::vector, std::list, std::deque ]]

[[RingList][optional container type for inner rings, for example std::vector, std::list, std::deque ]]

[[ClockWise][optional parameter, true for clockwise direction, false for CounterClockWise direction ]]

[[PointAlloc][container-allocator-type ]]

[[RingAlloc][container-allocator-type ]]

]


[heading Remarks]
      
The container collecting the points in the rings can be different from the container collecting the inner rings. They all default to vector. 



[heading Requirements]

[*Header: ][^boost/geometry/geometries/polygon.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:clear polygon::clear]

[indexterm2 clear..polygon] 
Utility method, clears outer and inner rings. 


  void clear();



[endsect]



[section:inner_container_type polygon::inner_container_type]

[indexterm2 inner_container_type..polygon] 

  typedef RingList< ring_type, RingAlloc< ring_type > > inner_container_type;


[heading Typedef Description]
    


[variablelist
  
[[P][point type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/polygon.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:inners polygon::inners]

[indexterm2 inners..polygon] 

  inner_container_type const & ``[link boost_geometry.reference.polygon.inners.overload1 inners]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.polygon.inners.overload1 more...]]``

  inner_container_type & ``[link boost_geometry.reference.polygon.inners.overload2 inners]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.polygon.inners.overload2 more...]]``


[section:overload1 polygon::inners (1 of 2 overloads)]



  inner_container_type const & inners() const;



[endsect]



[section:overload2 polygon::inners (2 of 2 overloads)]



  inner_container_type & inners();



[endsect]


[endsect]

[section:outer polygon::outer]

[indexterm2 outer..polygon] 

  ring_type const & ``[link boost_geometry.reference.polygon.outer.overload1 outer]``() const;
  ``  [''''&raquo;''' [link boost_geometry.reference.polygon.outer.overload1 more...]]``

  ring_type & ``[link boost_geometry.reference.polygon.outer.overload2 outer]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.polygon.outer.overload2 more...]]``


[section:overload1 polygon::outer (1 of 2 overloads)]



  ring_type const & outer() const;



[endsect]



[section:overload2 polygon::outer (2 of 2 overloads)]



  ring_type & outer();



[endsect]


[endsect]


[section:point_type polygon::point_type]

[indexterm2 point_type..polygon] 

  typedef Point point_type;



[heading Requirements]

[*Header: ][^boost/geometry/geometries/polygon.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:ring_type polygon::ring_type]

[indexterm2 ring_type..polygon] 

  typedef linear_ring< Point, PointList, ClockWise, PointAlloc > ring_type;


[heading Typedef Description]
    


[variablelist
  
[[P][point type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/polygon.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]


[section:polygon_2d polygon_2d]

[indexterm1 polygon_2d] 

  typedef polygon< point_2d > polygon_2d;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.polygon.inner_container_type [*inner_container_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.ring_type [*ring_type]]]
    []
  
  ]

]

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.polygon.clear [*clear]]]
    [Utility method, clears outer and inner rings. ]
  ]
  
  [
    [[link boost_geometry.reference.polygon.inners [*inners]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.polygon.outer [*outer]]]
    []
  ]
  
]

[heading Typedef Description]
    


[variablelist
  
[[P][point type ]]

[[PointList][optional container type for points, for example std::vector, std::list, std::deque ]]

[[RingList][optional container type for inner rings, for example std::vector, std::list, std::deque ]]

[[ClockWise][optional parameter, true for clockwise direction, false for CounterClockWise direction ]]

[[PointAlloc][container-allocator-type ]]

[[RingAlloc][container-allocator-type ]]

]


[heading Remarks]
      
The container collecting the points in the rings can be different from the container collecting the inner rings. They all default to vector. 




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:polygon_3d polygon_3d]

[indexterm1 polygon_3d] 

  typedef polygon< point_3d > polygon_3d;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.polygon.inner_container_type [*inner_container_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.point_type [*point_type]]]
    []
  
  ]

  [

    [[link boost_geometry.reference.polygon.ring_type [*ring_type]]]
    []
  
  ]

]

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.polygon.clear [*clear]]]
    [Utility method, clears outer and inner rings. ]
  ]
  
  [
    [[link boost_geometry.reference.polygon.inners [*inners]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.polygon.outer [*outer]]]
    []
  ]
  
]

[heading Typedef Description]
    


[variablelist
  
[[P][point type ]]

[[PointList][optional container type for points, for example std::vector, std::list, std::deque ]]

[[RingList][optional container type for inner rings, for example std::vector, std::list, std::deque ]]

[[ClockWise][optional parameter, true for clockwise direction, false for CounterClockWise direction ]]

[[PointAlloc][container-allocator-type ]]

[[RingAlloc][container-allocator-type ]]

]


[heading Remarks]
      
The container collecting the points in the rings can be different from the container collecting the inner rings. They all default to vector. 




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:polygon_tag polygon_tag]


OGC Polygon identifying tag. 


  struct polygon_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:radian radian]


Unit of plane angle: Radians. 


  class radian
[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:replace_point_type replace_point_type]



  template<
      typename Geometry ,
      typename NewPointType >
  struct replace_point_type
[heading Requirements]

[*Header: ][^boost/geometry/core/replace_point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:reverse reverse]

[indexterm1 reverse] 

  template<
      typename Geometry >
  void reverse(
      Geometry & geometry);




[variablelist
  
[[Geometry][geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to make reverse ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/reverse.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:reverse_dispatch reverse_dispatch]



  template<
      typename Geometry1 ,
      typename Geometry2 >
  struct reverse_dispatch
[heading Requirements]

[*Header: ][^boost/geometry/core/reverse_dispatch.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:ring_2d ring_2d]

[indexterm1 ring_2d] 

  typedef linear_ring< point_2d > ring_2d;


[heading Typedef Description]
    


[variablelist
  
[[P][point type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:ring_3d ring_3d]

[indexterm1 ring_3d] 

  typedef linear_ring< point_3d > ring_3d;


[heading Typedef Description]
    


[variablelist
  
[[P][point type ]]

[[V][optional container type, for example std::vector, std::list, std::deque ]]

[[A][optional container-allocator-type ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian3d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:ring_tag ring_tag]


Convenience (linear) ring identifying tag. 


  struct ring_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:ring_type ring_type]


Meta-function which defines ring type of (multi)polygon geometry. 


  template<
      typename Geometry >
  struct ring_type

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.ring_type.type [*type]]]
    []
  
  ]

]

a polygon contains one exterior ring and zero or more interior rings (holes). This meta function retrieves the type of the rings 
[heading Remarks]
      
Exterior ring and interior rings must have the same ring-type. 



[heading Requirements]

[*Header: ][^boost/geometry/core/ring_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type ring_type::type]

[indexterm2 type..ring_type] 

  typedef core_dispatch::ring_type< typename tag< Geometry >::type, Geometry >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries tell their geometry type (point, linestring, polygon, etc) by implementing a tag traits class. This meta-function uses that traits class to retrieve the tag. If the input type is not a geometry at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][geometry ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/ring_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:section section]


Structure containing section information. 


  template<
      typename Box ,
      std::size_t ``[link boost_geometry.reference.DimensionCount DimensionCount]``>
  struct section

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.section.box_type [*box_type]]]
    []
  
  ]

]

[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.section.section [*section]]]
    []
  ]
  
]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.section.begin_index [*begin_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.bounding_box [*bounding_box]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.count [*count]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.directions [*directions]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.duplicate [*duplicate]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.end_index [*end_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.id [*id]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.multi_index [*multi_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.non_duplicate_index [*non_duplicate_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.range_count [*range_count]]]
    []
  ]

  [
    [[link boost_geometry.reference.section.ring_index [*ring_index]]]
    []
  ]

]

Section information consists of a bounding box, direction information (if it is increasing or decreasing, per dimension), index information (begin-end, ring, multi) and the number of segments in this section



[variablelist
  
[[Box][box-type ]]

[[DimensionCount][number of dimensions for this section ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:begin_index section::begin_index]

[indexterm2 begin_index..section] 

  int begin_index;



[endsect]



[section:bounding_box section::bounding_box]

[indexterm2 bounding_box..section] 

  Box bounding_box;



[endsect]



[section:box_type section::box_type]

[indexterm2 box_type..section] 

  typedef Box box_type;



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:count section::count]

[indexterm2 count..section] 

  std::size_t count;



[endsect]



[section:directions section::directions]

[indexterm2 directions..section] 

  int directions;



[endsect]



[section:duplicate section::duplicate]

[indexterm2 duplicate..section] 

  bool duplicate;



[endsect]



[section:end_index section::end_index]

[indexterm2 end_index..section] 

  int end_index;



[endsect]



[section:id section::id]

[indexterm2 id..section] 

  int id;



[endsect]



[section:multi_index section::multi_index]

[indexterm2 multi_index..section] 

  int multi_index;



[endsect]



[section:non_duplicate_index section::non_duplicate_index]

[indexterm2 non_duplicate_index..section] 

  int non_duplicate_index;



[endsect]



[section:range_count section::range_count]

[indexterm2 range_count..section] 

  std::size_t range_count;



[endsect]



[section:ring_index section::ring_index]

[indexterm2 ring_index..section] 

  int ring_index;



[endsect]



[section:section section::section]

[indexterm2 section..section] 

  section();



[endsect]



[endsect]


[section:sectionalize sectionalize]

[indexterm1 sectionalize] 
Split a geometry into monotonic sections. 


  template<
      typename Geometry ,
      typename Sections >
  void sectionalize(
      Geometry const & geometry,
      Sections & sections);




[variablelist
  
[[Geometry][type of geometry to check ]]

[[Sections][type of sections to create ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry to create sections from ]]

[[sections][structure with sections ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:sections sections]


Structure containing a collection of sections. 


  template<
      typename Box ,
      std::size_t ``[link boost_geometry.reference.DimensionCount DimensionCount]``>
  struct sections

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.sections.box_type [*box_type]]]
    []
  
  ]

]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.sections.value [*value]]]
    []
  ]

]


[heading Remarks]
      
Derived from a vector, proves to be faster than of deque 

vector might be templated in the future 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:box_type sections::box_type]

[indexterm2 box_type..sections] 

  typedef Box box_type;



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sectionalize.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:value sections::value]

[indexterm2 value..sections] 

  static const std::size_t value = DimensionCount;



[endsect]



[endsect]

[section:segment segment]


Class segment: small class containing two (templatized) point references. 


  template<
      typename ConstOrNonConstPoint >
  class segment
[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.segment [*segment]]]
    []
  ]
  
]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.first [*first]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment.second [*second]]]
    []
  ]

]

From Wikipedia: In geometry, a line segment is a part of a line that is bounded by two distinct end points, and contains every point on the line between its end points. 
[heading Remarks]
      
The structure is like std::pair, and can often be used interchangeable. Difference is that it refers to points, does not have points. 

Like std::pair, points are public available. 

type is const or non const, so geometry::segment<P> or geometry::segment<const P> 

We cannot derive from std::pair<P&, P&> because of reference assignments. 



[variablelist
  
[[ConstOrNonConstPoint][point type of the segment, maybe a point or a const point ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/geometries/segment.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:first segment::first]

[indexterm2 first..segment] 

  point_type & first;



[endsect]



[section:second segment::second]

[indexterm2 second..segment] 

  point_type & second;



[endsect]



[section:segment segment::segment]

[indexterm2 segment..segment] 

  segment(
      point_type & p1,
      point_type & p2);



[endsect]



[endsect]


[section:segment_2d segment_2d]

[indexterm1 segment_2d] 

  typedef segment< point_2d > segment_2d;


[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.segment [*segment]]]
    []
  ]
  
]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment.first [*first]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment.second [*second]]]
    []
  ]

]

[heading Typedef Description]
    
From Wikipedia: In geometry, a line segment is a part of a line that is bounded by two distinct end points, and contains every point on the line between its end points. 
[heading Remarks]
      
The structure is like std::pair, and can often be used interchangeable. Difference is that it refers to points, does not have points. 

Like std::pair, points are public available. 

type is const or non const, so geometry::segment<P> or geometry::segment<const P> 

We cannot derive from std::pair<P&, P&> because of reference assignments. 



[variablelist
  
[[ConstOrNonConstPoint][point type of the segment, maybe a point or a const point ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/geometries/cartesian2d.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:segment_identifier segment_identifier]



  struct segment_identifier
[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment_identifier.operator_lt_ [*operator<]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.segment_identifier.operator_eq__eq_ [*operator==]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.segment_identifier.segment_identifier [*segment_identifier]]]
    []
  ]
  
]

[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.segment_identifier.multi_index [*multi_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment_identifier.ring_index [*ring_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment_identifier.segment_index [*segment_index]]]
    []
  ]

  [
    [[link boost_geometry.reference.segment_identifier.source_index [*source_index]]]
    []
  ]

]

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/segment_identifier.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:multi_index segment_identifier::multi_index]

[indexterm2 multi_index..segment_identifier] 

  int multi_index;



[endsect]



[section:operator_lt_ segment_identifier::operator<]

[indexterm2 operator<..segment_identifier] 

  bool operator<(
      segment_identifier const & other) const;



[endsect]



[section:operator_eq__eq_ segment_identifier::operator==]

[indexterm2 operator==..segment_identifier] 

  bool operator==(
      segment_identifier const & other) const;



[endsect]



[section:ring_index segment_identifier::ring_index]

[indexterm2 ring_index..segment_identifier] 

  int ring_index;



[endsect]


[section:segment_identifier segment_identifier::segment_identifier]

[indexterm2 segment_identifier..segment_identifier] 

  ``[link boost_geometry.reference.segment_identifier.segment_identifier.overload1 segment_identifier]``();
  ``  [''''&raquo;''' [link boost_geometry.reference.segment_identifier.segment_identifier.overload1 more...]]``

  ``[link boost_geometry.reference.segment_identifier.segment_identifier.overload2 segment_identifier]``(
      int src,
      int mul,
      int rin,
      int seg);
  ``  [''''&raquo;''' [link boost_geometry.reference.segment_identifier.segment_identifier.overload2 more...]]``


[section:overload1 segment_identifier::segment_identifier (1 of 2 overloads)]



  segment_identifier();



[endsect]



[section:overload2 segment_identifier::segment_identifier (2 of 2 overloads)]



  segment_identifier(
      int src,
      int mul,
      int rin,
      int seg);



[endsect]


[endsect]


[section:segment_index segment_identifier::segment_index]

[indexterm2 segment_index..segment_identifier] 

  int segment_index;



[endsect]



[section:source_index segment_identifier::source_index]

[indexterm2 source_index..segment_identifier] 

  int source_index;



[endsect]



[endsect]

[section:segment_tag segment_tag]


Convenience segment (2-points) identifying tag. 


  struct segment_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:set set]

[indexterm1 set] 
set coordinate value of a Point ( / Sphere) 

    
  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void ``[link boost_geometry.reference.set.overload1 set]``(
      Geometry & geometry,
      typename coordinate_type< Geometry >::type const & value);
  ``  [''''&raquo;''' [link boost_geometry.reference.set.overload1 more...]]``

  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void ``[link boost_geometry.reference.set.overload2 set]``(
      Geometry & geometry,
      typename coordinate_type< Geometry >::type const & value);
  ``  [''''&raquo;''' [link boost_geometry.reference.set.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 set (1 of 2 overloads)]


set coordinate value of a Point ( / Sphere) 


  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void set(
      Geometry & geometry,
      typename coordinate_type< Geometry >::type const & value);




[variablelist
  
[[Dimension][dimension ]]

[[Geometry][geometry ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry to assign coordinate to ]]

[[value][coordinate value to assign ]]

]




[endsect]



[section:overload2 set (2 of 2 overloads)]


set coordinate value of a Box / Segment 


  template<
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void set(
      Geometry & geometry,
      typename coordinate_type< Geometry >::type const & value);




[variablelist
  
[[Index][for Point: do not specifyfor Box: min\_corner or max\_cornerfor Segment: 0 / 1 
]]

[[Dimension][dimension ]]

[[Geometry][geometry ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry to assign coordinate to ]]

[[value][coordinate value to assign ]]

]




[endsect]


[endsect]


[section:set_from_radian set_from_radian]

[indexterm1 set_from_radian] 
set coordinate value (in radian) to a point 


  template<
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``,
      typename Geometry >
  void set_from_radian(
      Geometry & geometry,
      const typename coordinate_type< Geometry >::type & radians);


Coordinate value will be set correctly, if coordinate system of point is in Degree, Radian value will be converted to Degree



[variablelist
  
[[Dimension][dimension ]]

[[Geometry][geometry ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][geometry to assign coordinate to ]]

[[radians][coordinate value to assign ]]

]


[heading Remarks]
      
Only applicable to coordinate systems templatized by units, e.g. spherical or geographic coordinate systems 



[heading Requirements]

[*Header: ][^boost/geometry/core/radian_access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:simplify simplify]

[indexterm1 simplify] 
      
  template<
      typename Geometry ,
      typename Strategy >
  void ``[link boost_geometry.reference.simplify.overload1 simplify]``(
      Geometry const & geometry,
      Geometry & out,
      double max_distance,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.simplify.overload1 more...]]``

  template<
      typename Geometry >
  void ``[link boost_geometry.reference.simplify.overload2 simplify]``(
      Geometry const & geometry,
      Geometry & out,
      double max_distance);
  ``  [''''&raquo;''' [link boost_geometry.reference.simplify.overload2 more...]]``


[heading Source description:]
  

* Wikipedia: given a 'curve' composed of line segments to find a curve not too dissimilar but that has fewer points





[heading Performance]
  

* Performance is measured on simplification of a collection of rings, such that 10% of the points is kept.

* 2776 counties of US are simplified in 0.7 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Simplify1)




[heading Geometries]
  

* linestring: 
 This US Road originally contained 34 points, the simplified version contains 7 points




* polygon: 
 This country (Belgium) originally contained 55 points, the simplified version contains 24 points




[heading Remarks]
      
simplifying a valid simple polygon (which never intersects itself) might result in an invalid polygon, where the simplified rings intersect themselves or one of the other outer or inner rings. Efficient simplification of a ring/polygon is still an "Open Problem" (http://maven.smith.edu/~orourke/TOPP/P24.html#Problem.24)


* multi_linestring 

* multi_polygon 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/simplify.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 simplify (1 of 2 overloads)]


Simplify a geometry using a specified strategy. 


  template<
      typename Geometry ,
      typename Strategy >
  void simplify(
      Geometry const & geometry,
      Geometry & out,
      double max_distance,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry][input geometry, to be simplified ]]

[[out][output geometry, simplified version of the input geometry ]]

[[max_distance][distance (in units of input coordinates) of a vertex to other segments to be removed ]]

[[strategy][simplify strategy to be used for simplification, might include point-distance strategy ]]

]




[endsect]



[section:overload2 simplify (2 of 2 overloads)]


Simplify a geometry. 


  template<
      typename Geometry >
  void simplify(
      Geometry const & geometry,
      Geometry & out,
      double max_distance);



[heading Remarks]
      
This version of simplify simplifies a geometry using the default strategy (Douglas Peucker), 


[heading Parameters]
    

[variablelist
  
[[geometry][input geometry, to be simplified ]]

[[out][output geometry, simplified version of the input geometry ]]

[[max_distance][distance (in units of input coordinates) of a vertex to other segments to be removed ]]

]


[heading Example:]
  
The simplify algorithm can be used as following:  








[endsect]


[endsect]

[section:simplify_inserter simplify_inserter]

[indexterm1 simplify_inserter] 
Simplify a geometry, using an output iterator and a specified strategy. 

    
  template<
      typename Geometry ,
      typename OutputIterator ,
      typename Strategy >
  void ``[link boost_geometry.reference.simplify_inserter.overload1 simplify_inserter]``(
      Geometry const & geometry,
      OutputIterator out,
      double max_distance,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.simplify_inserter.overload1 more...]]``

  template<
      typename Geometry ,
      typename OutputIterator >
  void ``[link boost_geometry.reference.simplify_inserter.overload2 simplify_inserter]``(
      Geometry const & geometry,
      OutputIterator out,
      double max_distance);
  ``  [''''&raquo;''' [link boost_geometry.reference.simplify_inserter.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/simplify.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 simplify_inserter (1 of 2 overloads)]


Simplify a geometry, using an output iterator and a specified strategy. 


  template<
      typename Geometry ,
      typename OutputIterator ,
      typename Strategy >
  void simplify_inserter(
      Geometry const & geometry,
      OutputIterator out,
      double max_distance,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry][input geometry, to be simplified ]]

[[out][output iterator, outputs all simplified points ]]

[[max_distance][distance (in units of input coordinates) of a vertex to other segments to be removed ]]

[[strategy][simplify strategy to be used for simplification, might include point-distance strategy ]]

]


[heading Example:]
  
simplify\_inserter with strategy is used as following:  








[endsect]



[section:overload2 simplify_inserter (2 of 2 overloads)]


Simplify a geometry, using an output iterator. 


  template<
      typename Geometry ,
      typename OutputIterator >
  void simplify_inserter(
      Geometry const & geometry,
      OutputIterator out,
      double max_distance);



[heading Parameters]
    

[variablelist
  
[[geometry][input geometry, to be simplified ]]

[[out][output iterator, outputs all simplified points ]]

[[max_distance][distance (in units of input coordinates) of a vertex to other segments to be removed ]]

]




[endsect]


[endsect]

[section:spherical_tag spherical_tag]


Tag indicating Spherical coordinate system family (spherical,celestial,...). 


  struct spherical_tag
[heading Requirements]

[*Header: ][^boost/geometry/core/tags.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:strategy__intersection__liang_barsky strategy::intersection::liang_barsky]


Strategy: line clipping algorithm after Liang Barsky. 


  template<
      typename Box ,
      typename Point >
  class liang_barsky
[heading Public Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.strategy__intersection__liang_barsky.apply [*apply]]]
    []
  ]
  
  [
    [[link boost_geometry.reference.strategy__intersection__liang_barsky.clip_segment [*clip_segment]]]
    []
  ]
  
]

The Liang-Barsky line clipping algorithm clips a line with a clipping box. It is slightly adapted in the sense that it returns which points are clipped 

[variablelist
  
[[B][input box type of clipping box ]]

[[P][input/output point-type of segments to be clipped ]]

]


[heading Remarks]
      
The algorithm is currently only implemented for 2D Cartesian points 

Though it is implemented in namespace strategy, and theoretically another strategy could be used, it is not (yet) updated to the general strategy concepts, and not (yet) splitted into a file in folder strategies 


Barend Gehrels, and the following recourses
* A tutorial: http://www.skytopia.com/project/articles/compsci/clipping.html

* a German applet (link broken): http://ls7-www.cs.uni-dortmund.de/students/projectgroups/acit/lineclip.shtml 





[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/clip_linestring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:apply strategy::intersection::liang_barsky::apply]

[indexterm2 apply..strategy::intersection::liang_barsky] 

  template<
      typename Linestring ,
      typename OutputIterator >
  void apply(
      Linestring & line_out,
      OutputIterator out) const;



[endsect]



[section:clip_segment strategy::intersection::liang_barsky::clip_segment]

[indexterm2 clip_segment..strategy::intersection::liang_barsky] 

  bool clip_segment(
      Box const & b,
      segment_type & s,
      bool & sp1_clipped,
      bool & sp2_clipped) const;



[endsect]



[endsect]


[section:subtract_point subtract_point]

[indexterm1 subtract_point] 
Subtracts a point to another. 


  template<
      typename Point1 ,
      typename Point2 >
  void subtract_point(
      Point1 & p1,
      Point2 const & p2);


The coordinates of the second point will be subtracted to those of the first point. The second point is not modified. 
[heading Parameters]
    

[variablelist
  
[[p1][first point ]]

[[p2][second point ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:subtract_value subtract_value]

[indexterm1 subtract_value] 
Subtracts a value to each coordinate of a point. 


  template<
      typename Point >
  void subtract_value(
      Point & p,
      typename detail::param< Point >::type value);



[heading Parameters]
    

[variablelist
  
[[p][point ]]

[[value][value to subtract ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/arithmetic/arithmetic.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[section:sym_difference sym_difference]

[indexterm1 sym_difference] 

  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Collection >
  void sym_difference(
      Geometry1 geometry1,
      Geometry2 geometry2,
      Collection & output_collection);




[variablelist
  
[[Geometry][geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to make symmetric difference ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/sym_difference.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:tag tag]


Meta-function to get the tag of any geometry type. 


  template<
      typename Geometry >
  struct tag

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.tag.type [*type]]]
    []
  
  ]

]

All geometries tell their geometry type (point, linestring, polygon, etc) by implementing a tag traits class. This meta-function uses that traits class to retrieve the tag. If the input type is not a geometry at all, a [link boost_geometry.reference.geometry_not_recognized_tag `geometry_not_recognized_tag`] will be returned. 

[variablelist
  
[[Geometry][geometry ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/tag.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type tag::type]

[indexterm2 type..tag] 

  typedef traits::tag< typename boost::remove_const< Geometry >::type >::type type;



[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.traits__tag.type [*type]]]
    []
  
  ]

]

[heading Typedef Description]
    
All geometries should implement a `traits::tag<G>::type` metafunction to indicate their own geometry type.


[heading Geometries:]
  

* all geometries 




[heading Specializations should provide:]
  

* typedef XXX_tag type; (point_tag, box_tag, ...) 





[variablelist
  
[[Geometry][geometry ]]

]




[heading Requirements]

[*Header: ][^boost/geometry/core/tag.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:topological_dimension topological_dimension]


Meta-function returning the topological dimension of a geometry. 


  template<
      typename Geometry >
  struct topological_dimension
The topological dimension defines a point as 0-dimensional, a linestring as 1-dimensional, and a ring or polygon as 2-dimensional. 


[heading Requirements]

[*Header: ][^boost/geometry/core/topological_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__access traits::access]


Traits class which gives access (get,set) to points. 


  template<
      typename Geometry ,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``>
  struct access

[heading Geometries:]
  

* point 




[heading Specializations should provide, per Dimension]
  

* static inline T get(const G&) 

* static inline void set(G&, T const&) 





[variablelist
  
[[Geometry][geometry-type ]]

[[Dimension][dimension to access ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__append_point traits::append_point]


Traits class, optional, might be implemented to append a point. 


  template<
      typename Geometry ,
      typename Point >
  struct append_point
If a geometry type should not use the std "push\_back" then it can specialize the "use\_std" traits class to false, it should then implement (a.o.) [link boost_geometry.reference.traits__append_point `traits::append_point`]


[heading Geometries:]
  

* linestring

* linear_ring 




[heading Specializations should provide:]
  

* apply 





[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__clear traits::clear]


Traits class, optional, might be implemented to clear a geometry. 


  template<
      typename Geometry >
  struct clear
If a geometry type should not use the std ".clear()" then it can specialize the "use\_std" traits class to false, it should then implement (a.o.) clear


[heading Geometries:]
  

* linestring

* linear_ring 




[heading Specializations should provide:]
  

* apply 





[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__coordinate_system traits::coordinate_system]


Traits class defining the coordinate system of a point, important for strategy selection. 


  template<
      typename P >
  struct coordinate_system

[heading Geometries:]
  

* point 




[heading Specializations should provide:]
  

* typedef CS type; (cs::cartesian, cs::spherical, etc) 





[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_system.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__coordinate_type traits::coordinate_type]


Traits class which indicate the coordinate type (double,float,...) of a point. 


  template<
      typename P >
  struct coordinate_type

[heading Geometries:]
  

* point 




[heading Specializations should provide:]
  

* typedef T type; (double,float,int,etc) 





[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__cs_tag traits::cs_tag]


Traits class defining coordinate system tag, bound to coordinate system. 


  template<
      typename CoordinateSystem >
  struct cs_tag


[variablelist
  
[[CoordinateSystem][coordinate system ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/cs.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__dimension traits::dimension]


Traits class indicating the number of dimensions of a point. 


  template<
      typename P >
  struct dimension

[heading Geometries:]
  

* point 




[heading Specializations should provide:]
  

* value (should be derived from boost::mpl::int_<D> 





[heading Requirements]

[*Header: ][^boost/geometry/core/coordinate_dimension.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__exterior_ring traits::exterior_ring]


Traits class defining access to [link boost_geometry.reference.traits__exterior_ring `traits::exterior_ring`] of a polygon. 


  template<
      typename Polygon >
  struct exterior_ring
Should define const and non const access



[variablelist
  
[[Polygon][the polygon type ]]

]


[heading Geometries:]
  

* polygon 




[heading Specializations should provide:]
  

* static inline RING& get(POLY& )

* static inline const RING& get(const POLY& ) 





[heading Requirements]

[*Header: ][^boost/geometry/core/exterior_ring.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__indexed_access traits::indexed_access]


Traits class defining "get" and "set" to get and set point coordinate values. 


  template<
      typename Geometry ,
      std::size_t ``[link boost_geometry.reference.Index Index]``,
      std::size_t ``[link boost_geometry.reference.Dimension Dimension]``>
  struct indexed_access


[variablelist
  
[[Geometry][geometry (box, segment) ]]

[[Index][index (min\_corner/max\_corner for box, 0/1 for segment) ]]

[[Dimension][dimension ]]

]


[heading Geometries:]
  

* box

* segment 




[heading Specializations should provide:]
  

* static inline T get(const G&)

* static inline void set(G&, T const&) 





[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__interior_rings traits::interior_rings]


Traits class defining access to [link boost_geometry.reference.traits__interior_rings `traits::interior_rings`] of a polygon. 


  template<
      typename Geometry >
  struct interior_rings
defines access (const and non const) to interior ring


[heading Geometries:]
  

* polygon 




[heading Specializations should provide:]
  

* static inline INTERIOR& get(POLY&)

* static inline const INTERIOR& get(const POLY&) 





[variablelist
  
[[Geometry][geometry ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__interior_type traits::interior_type]


Traits class indicating interior container type of a polygon. 


  template<
      typename Geometry >
  struct interior_type
defines inner container type, so the container containing the interior rings


[heading Geometries:]
  

* polygon 




[heading Specializations should provide:]
  

* typedef X type ( e.g. std::vector<myring<P>> ) 





[variablelist
  
[[Geometry][geometry ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/interior_rings.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__point_order traits::point_order]


Traits class indicating the order of contained points within a ring or (multi)polygon, clockwise, counter clockwise or not known. 


  template<
      typename G >
  struct point_order
[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.traits__point_order.value [*value]]]
    []
  ]

]


[heading Geometries:]
  

* ring

* polygon

* multi polygon 




[heading Specializations should provide:]
  

* typedef P type (where P should fulfil the Point concept) 





[variablelist
  
[[G][geometry ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/point_order.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:value traits::point_order::value]

[indexterm2 value..traits::point_order] 

  static const order_selector value = clockwise;



[endsect]



[endsect]

[section:traits__point_type traits::point_type]


Traits class indicating the type of contained points. 


  template<
      typename G >
  struct point_type

[heading Geometries:]
  

* all geometries except point 




[heading Specializations should provide:]
  

* typedef P type (where P should fulfil the Point concept) 





[variablelist
  
[[G][geometry ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/point_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__ring_type traits::ring_type]


Traits class to indicate ring-type of a polygon's exterior ring/interior rings. 


  template<
      typename Geometry >
  struct ring_type

[heading Geometries:]
  

* polygon 




[heading Specializations should provide:]
  

* typedef XXX type ( e.g. linear_ring



) 

[variablelist
  
[[Geometry][geometry ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/ring_type.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]

[section:traits__tag traits::tag]


Traits class to attach a tag to a geometry. 


  template<
      typename ``[link boost_geometry.reference.Geometry Geometry]``>
  struct tag

[heading Public Types]
[table
  [[Name][Description]]

  [

    [[link boost_geometry.reference.traits__tag.type [*type]]]
    []
  
  ]

]

All geometries should implement a `traits::tag<G>::type` metafunction to indicate their own geometry type.


[heading Geometries:]
  

* all geometries 




[heading Specializations should provide:]
  

* typedef XXX_tag type; (point_tag, box_tag, ...) 





[variablelist
  
[[Geometry][geometry ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/core/tag.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:type traits::tag::type]

[indexterm2 type..traits::tag] 

  typedef geometry_not_recognized_tag type;


[heading Typedef Description]
    

[heading Requirements]

[*Header: ][^boost/geometry/core/tag.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]



[endsect]

[section:traits__use_std traits::use_std]


Traits class, optional, indicating that the std-library should be used. 


  template<
      typename Geometry >
  struct use_std
[heading Public Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_geometry.reference.traits__use_std.value [*value]]]
    []
  ]

]

The default geometry (linestring, ring, multi*) follow std:: for its modifying operations (push\_back, clear, size, resize, reserve, etc) If they NOT follow the std:: library they should specialize this traits class


[heading Geometries:]
  

* linestring

* linear_ring 




[heading Specializations should provide:]
  

* value (defaults to true) 





[heading Requirements]

[*Header: ][^boost/geometry/core/access.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:value traits::use_std::value]

[indexterm2 value..traits::use_std] 

  static const bool value = true;



[endsect]



[endsect]

[section:transform transform]

[indexterm1 transform] 
Transforms from one geometry to another geometry, optionally using a strategy. 

      
  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  bool ``[link boost_geometry.reference.transform.overload1 transform]``(
      Geometry1 const & geometry1,
      Geometry2 & geometry2,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.transform.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool ``[link boost_geometry.reference.transform.overload2 transform]``(
      Geometry1 const & geometry1,
      Geometry2 & geometry2);
  ``  [''''&raquo;''' [link boost_geometry.reference.transform.overload2 more...]]``

The transform algorithm automatically transforms from one coordinate system to another coordinate system. If the coordinate system of both geometries are the same, the geometry is copied. All point(s of the geometry) are transformed.

There is a version without a strategy, transforming automatically, and there is a version with a strategy.

This function has a lot of appliances, for example
* transform from spherical coordinates to cartesian coordinates, and back

* transform from geographic coordinates to cartesian coordinates (projections) and back

* transform from degree to radian, and back

* transform from and to cartesian coordinates (mapping, translations, etc)



The automatic transformations look to the coordinate system family, and dimensions, of the point type and by this apply the strategy (internally bounded by traits classes).


[heading Examples:]
  
The example below shows automatic transformations to go from one coordinate system to another one:  





The next example takes another approach and transforms from Cartesian to Cartesian: 






[heading Remarks]
      
Not every possibility is yet worked out, e.g. polar coordinate system is ignored until now 

This "transform" is broader then geodetic datum transformations, those are currently not worked out 



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/transform.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 transform (1 of 2 overloads)]


Transforms from one geometry to another geometry using a strategy. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  bool transform(
      Geometry1 const & geometry1,
      Geometry2 & geometry2,
      Strategy const & strategy);




[variablelist
  
[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

[[Strategy][strategy ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

[[strategy][the strategy to be used for transformation ]]

]




[endsect]



[section:overload2 transform (2 of 2 overloads)]


Transforms from one geometry to another geometry using a strategy. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool transform(
      Geometry1 const & geometry1,
      Geometry2 & geometry2);




[variablelist
  
[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

]


[heading Return Value]
      
true if the transformation could be done 




[endsect]


[endsect]


[section:traverse traverse]

[indexterm1 traverse] 
Traverses through intersection points / geometries. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Turns ,
      typename Rings >
  void traverse(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      detail::overlay::operation_type operation,
      Turns & turns,
      Rings & rings);


[heading Requirements]

[*Header: ][^boost/geometry/algorithms/overlay/traverse.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:union_inserter union_inserter]

[indexterm1 union_inserter] 
Combines two geometries which each other. 

    
  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator ``[link boost_geometry.reference.union_inserter.overload1 union_inserter]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.union_inserter.overload1 more...]]``

  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator >
  OutputIterator ``[link boost_geometry.reference.union_inserter.overload2 union_inserter]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out);
  ``  [''''&raquo;''' [link boost_geometry.reference.union_inserter.overload2 more...]]``

[heading Requirements]

[*Header: ][^boost/geometry/algorithms/union.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 union_inserter (1 of 2 overloads)]


Combines two geometries which each other. 


  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator ,
      typename Strategy >
  OutputIterator union_inserter(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out,
      Strategy const & strategy);




[variablelist
  
[[GeometryOut][output geometry type, must be specified ]]

[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

[[OutputIterator][output iterator ]]

[[Strategy][compound strategy for intersection ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

[[out][the output iterator, outputting polygons ]]

[[strategy][the strategy ]]

]


[heading Return Value]
      
the output iterator 




[endsect]



[section:overload2 union_inserter (2 of 2 overloads)]


Combines two geometries which each other. 


  template<
      typename GeometryOut ,
      typename Geometry1 ,
      typename Geometry2 ,
      typename OutputIterator >
  OutputIterator union_inserter(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      OutputIterator out);




[variablelist
  
[[GeometryOut][output geometry type, must be specified ]]

[[Geometry1][first geometry type ]]

[[Geometry2][second geometry type ]]

[[OutputIterator][output iterator ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry1][first geometry ]]

[[geometry2][second geometry ]]

[[out][the output iterator, outputting polygons ]]

]


[heading Return Value]
      
the output iterator 




[endsect]


[endsect]


[section:unique unique]

[indexterm1 unique] 

  template<
      typename Geometry >
  void unique(
      Geometry & geometry);




[variablelist
  
[[Geometry][geometry type ]]

]


[heading Parameters]
    

[variablelist
  
[[geometry][the geometry to make unique ]]

]



[heading Requirements]

[*Header: ][^boost/geometry/algorithms/unique.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[endsect]


[section:within within]

[indexterm1 within] 
      
  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool ``[link boost_geometry.reference.within.overload1 within]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);
  ``  [''''&raquo;''' [link boost_geometry.reference.within.overload1 more...]]``

  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  bool ``[link boost_geometry.reference.within.overload2 within]``(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);
  ``  [''''&raquo;''' [link boost_geometry.reference.within.overload2 more...]]``


[heading Source descriptions:]
  

* OGC: Returns 1 (TRUE) if this geometric object is "spatially within" another Geometry.




[heading Performance]
  

* 2776 within determinations using bounding box and polygon are done in 0.05 seconds (http://trac.osgeo.org/ggl/wiki/Performance#Within1)

* note that using another strategy the performance can be increased:winding : 0.093 sfranklin : 0.062 sCrossings-multiply : 0.047 s


* but note also that the last two do not detect point-on-border cases




[heading Geometries:]
  

* point + polygon: The well-known point-in-polygon, returning true if a point falls within a polygon (and not within one of its holes) 


* point + ring: returns true if point is completely within a ring 


* point + box 

* box + box 




[heading Example:]
  
The within algorithm is used as following:  







[heading Requirements]

[*Header: ][^boost/geometry/algorithms/within.hpp]

[*Convenience header: ][^boost/geometry.hpp]


[section:overload1 within (1 of 2 overloads)]


Within, examine if a geometry is within another geometry. 


  template<
      typename Geometry1 ,
      typename Geometry2 >
  bool within(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2);



[heading Parameters]
    

[variablelist
  
[[geometry1][geometry which might be within the second geometry ]]

[[geometry2][geometry which might contain the first geometry ]]

]


[heading Return Value]
      
true if geometry1 is completely contained within geometry2, else false 


[heading Remarks]
      
The default strategy is used for within detection 




[endsect]



[section:overload2 within (2 of 2 overloads)]


Within, examine if a geometry is within another geometry, using a specified strategy. 


  template<
      typename Geometry1 ,
      typename Geometry2 ,
      typename Strategy >
  bool within(
      Geometry1 const & geometry1,
      Geometry2 const & geometry2,
      Strategy const & strategy);



[heading Parameters]
    

[variablelist
  
[[geometry1][geometry which might be within the second geometry ]]

[[geometry2][geometry which might contain the first geometry ]]

[[strategy][strategy to be used ]]

]


[heading Return Value]
      
true if geometry1 is completely contained within geometry2, else false 




[endsect]


[endsect]

[endsect]