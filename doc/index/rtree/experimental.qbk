[/============================================================================
  Boost.Geometry Index

  Copyright (c) 2011-2013 Adam Wulkiewicz.

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section Experimental features]

This section describes experimental features which are implemented but unavailable by default.
Be aware that they may not be released in the future or functionalities may be released but
behind different interface.

To enable them one must define `BOOST_GEOMETRY_INDEX_DETAIL_EXPERIMENTAL` in compiler's command line or before
including spatial index.

[heading Nearest query distance calculation]

It is possible to define how distance to the non-point `__value__` should be calculated. To do this one may pass
a relation object instead of a Point to the nearest predicate, as follows:

 /* caluclate distance to the Indexables' nearest points */
 rtree.query(index::nearest(index::to_nearest(pt), k), std::back_inserter(returned_values)); // same as default

 /* caluclate distance to the Indexables' centroid */
 rtree.query(index::nearest(index::to_centroid(pt), k), std::back_inserter(returned_values));

 /* caluclate distance to the Indexables' furthest points */
 rtree.query(index::nearest(index::to_furthest(pt), k), std::back_inserter(returned_values));

[heading Incremental queries]

Sometimes there is a need to brake querying at some desired point because it depends on objects already
returned or to pause it in order to resume later. For this purpose iterators may be used.

In this library incremental queries are implemented as input (single pass) const iterators, relatively
big fat-iterators storing stack used in the tree-traversing process. Because the type of predicates passed
to the query varies, the type of the iterator varies as well.

Therefore to use query iterators one must pass them to some function template, then types will be deduced
automatically. If iterators objects must be stored one may use Boost.Typeof library to retrieve a type from
an expression or use C++11 `auto` or `decltype`.

 /* function call */
 std::copy(rtree.qbegin(index::intersects(box)), rtree.qend(index::intersects(box)), std::back_inserter(returned_values));
 
 /* Boost.Typeof */
 typedef BOOST_TYPEOF(rtree.qbegin(index::nearest(pt, 5))) const_query_iterator;
 const_query_iterator first = rtree.qbegin(index::nearest(pt, 5));
 const_query_iterator last = rtree.qend(index::nearest(pt, 5));
 // ...
 for ( ; first != last ; ++first )
     *first; // do domething with Value
 
 /* C++11 */
 auto first = rtree.qbegin(index::nearest(pt, 5));
 auto last = rtree.qend(index::nearest(pt, 5));
 // ...
 for ( ; first != last ; ++first )
     *first; // do domething with Value

`qend()` method is overloaded to return a different, lighter type of iterator which may be compared
with query iterator to check if the querying was finished. But since it has different type than the one returned by
`qbegin(Pred)` it can't be used with STL-like functions like `std::copy()` which expect that `first` and `last`
iterators have the same type.

 /* function call */
 template <typename First, typename Last, typename Out>
 void my_copy(First first, Last last, Out out)
 {
     for ( ; first != last ; ++out, ++first )
         *out = *first;
 }
 // ...
 my_copy(rtree.qbegin(index::intersects(box)), rtree.qend(), std::back_inserter(returned_values));
 
 /* Boost.Typeof */
 typedef BOOST_TYPEOF(rtree.qbegin(index::nearest(pt, 5))) const_query_iterator;
 typedef BOOST_TYPEOF(rtree.qend()) end_iterator;
 const_query_iterator first = rtree.qbegin(index::nearest(pt, 5));
 end_iterator last = rtree.qend();
 // ...
 for ( ; first != last ; ++first )
     *first; // do domething with Value
 
 /* C++11 */
 auto first = rtree.qbegin(index::nearest(pt, 5));
 auto last = rtree.qend();
 // ...
 for ( ; first != last ; ++first )
     *first; // do domething with Value

[endsect] [/ Experimental features /]
